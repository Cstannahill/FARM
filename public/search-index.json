{
  "documents": [
    {
      "id": "architectural-sketches-detailed-phase1-ai_ml_integration_points",
      "title": "Ai_ml_integration_points",
      "url": "/architectural-sketches-detailed/phase1/ai_ml_integration_points",
      "content": "# AI/ML Integration Points\r\n\r\n## Overview\r\n\r\nFARM provides first-class AI/ML integration with seamless local-to-cloud workflows. The framework supports multiple AI providers (Ollama, OpenAI, HuggingFace) with automatic provider switching, unified APIs, and intelligent resource management. This enables developers to use local models (Ollama) during development and cloud models in production without code changes.\r\n\r\n---\r\n\r\n## High-Level AI Integration Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                      FARM AI Integration Layer                  │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │   Ollama    │  │   OpenAI    │  │ HuggingFace │  │ Custom  │ │\r\n│  │  (Local)    │  │  (Cloud)    │  │  (Cloud)    │  │Provider │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Provider    │  │ Model       │  │ GPU         │  │Streaming│ │\r\n│  │ Router      │  │ Manager     │  │ Manager     │  │ Handler │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Response    │  │ Error       │  │ Performance │  │ Type    │ │\r\n│  │ Cache       │  │ Handler     │  │ Monitor     │  │ Safety  │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Components\r\n\r\n### 1. AI Provider Abstraction Layer\r\n\r\n**Purpose:** Unified interface across different AI providers\r\n\r\n**Implementation:**\r\n```python\r\n# apps/api/src/ai/providers/base.py\r\nfrom abc import ABC, abstractmethod\r\nfrom typing import AsyncIterator, Dict, Any, Optional\r\nfrom pydantic import BaseModel\r\n\r\nclass AIProvider(ABC):\r\n    \"\"\"Base class for all AI providers\"\"\"\r\n    \r\n    def __init__(self, config: Dict[str, Any]):\r\n        self.config = config\r\n        self.models = {}\r\n        \r\n    @abstractmethod\r\n    async def load_model(self, model_name: str) -> bool:\r\n        \"\"\"Load a specific model\"\"\"\r\n        pass\r\n        \r\n    @abstractmethod\r\n    async def generate(self, prompt: str, model: str, **kwargs) -> str:\r\n        \"\"\"Generate text completion\"\"\"\r\n        pass\r\n        \r\n    @abstractmethod\r\n    async def generate_stream(self, prompt: str, model: str, **kwargs) -> AsyncIterator[str]:\r\n        \"\"\"Generate streaming text completion\"\"\"\r\n        pass\r\n        \r\n    @abstractmethod\r\n    async def embed(self, text: str, model: str) -> List[float]:\r\n        \"\"\"Generate embeddings\"\"\"\r\n        pass\r\n        \r\n    @abstractmethod\r\n    async def health_check(self) -> bool:\r\n        \"\"\"Check if provider is healthy\"\"\"\r\n        pass\r\n\r\nclass ChatMessage(BaseModel):\r\n    role: str  # system, user, assistant\r\n    content: str\r\n\r\nclass GenerationRequest(BaseModel):\r\n    messages: List[ChatMessage]\r\n    model: str\r\n    temperature: float = 0.7\r\n    max_tokens: int = 1000\r\n    stream: bool = False\r\n```\r\n\r\n### 2. Ollama Provider Implementation\r\n\r\n**Purpose:** Local AI model serving with Ollama\r\n\r\n**Implementation:**\r\n```python\r\n# apps/api/src/ai/providers/ollama.py\r\nimport asyncio\r\nimport httpx\r\nfrom typing import AsyncIterator, List\r\nfrom .base import AIProvider, ChatMessage\r\n\r\nclass OllamaProvider(AIProvider):\r\n    \"\"\"Ollama local AI provider\"\"\"\r\n    \r\n    def __init__(self, config: Dict[str, Any]):\r\n        super().__init__(config)\r\n        self.base_url = config.get('url', 'http://localhost:11434')\r\n        self.client = httpx.AsyncClient(base_url=self.base_url, timeout=60.0)\r\n        \r\n    async def load_model(self, model_name: str) -> bool:\r\n        \"\"\"Load/pull model if not available\"\"\"\r\n        try:\r\n            # Check if model exists\r\n            response = await self.client.get('/api/tags')\r\n            models = [m['name'] for m in response.json().get('models', [])]\r\n            \r\n            if model_name not in models:\r\n                print(f\"📥 Pulling Ollama model: {model_name}\")\r\n                # Pull model (this can take time for large models)\r\n                async with self.client.stream('POST', '/api/pull', \r\n                    json={'name': model_name}) as response:\r\n                    async for chunk in response.aiter_lines():\r\n                        if chunk:\r\n                            data = json.loads(chunk)\r\n                            if 'status' in data:\r\n                                print(f\"📦 {data['status']}\")\r\n                                \r\n            self.models[model_name] = True\r\n            return True\r\n        except Exception as e:\r\n            print(f\"❌ Failed to load Ollama model {model_name}: {e}\")\r\n            return False\r\n    \r\n    async def generate(self, prompt: str, model: str, **kwargs) -> str:\r\n        \"\"\"Generate completion using Ollama\"\"\"\r\n        if model not in self.models:\r\n            await self.load_model(model)\r\n            \r\n        response = await self.client.post('/api/generate', json={\r\n            'model': model,\r\n            'prompt': prompt,\r\n            'stream': False,\r\n            'options': {\r\n                'temperature': kwargs.get('temperature', 0.7),\r\n                'num_predict': kwargs.get('max_tokens', 1000)\r\n            }\r\n        })\r\n        \r\n        result = response.json()\r\n        return result.get('response', '')\r\n    \r\n    async def generate_stream(self, prompt: str, model: str, **kwargs) -> AsyncIterator[str]:\r\n        \"\"\"Stream completion from Ollama\"\"\"\r\n        if model not in self.models:\r\n            await self.load_model(model)\r\n            \r\n        async with self.client.stream('POST', '/api/generate', json={\r\n            'model': model,\r\n            'prompt': prompt,\r\n            'stream': True,\r\n            'options': {\r\n                'temperature': kwargs.get('temperature', 0.7),\r\n                'num_predict': kwargs.get('max_tokens', 1000)\r\n            }\r\n        }) as response:\r\n            async for chunk in response.aiter_lines():\r\n                if chunk:\r\n                    data = json.loads(chunk)\r\n                    if 'response' in data:\r\n                        yield data['response']\r\n    \r\n    async def chat(self, messages: List[ChatMessage], model: str, **kwargs) -> str:\r\n        \"\"\"Chat completion using Ollama\"\"\"\r\n        if model not in self.models:\r\n            await self.load_model(model)\r\n            \r\n        response = await self.client.post('/api/chat', json={\r\n            'model': model,\r\n            'messages': [{'role': msg.role, 'content': msg.content} for msg in messages],\r\n            'stream': False,\r\n            'options': {\r\n                'temperature': kwargs.get('temperature', 0.7),\r\n                'num_predict': kwargs.get('max_tokens', 1000)\r\n            }\r\n        })\r\n        \r\n        result = response.json()\r\n        return result.get('message', {}).get('content', '')\r\n    \r\n    async def chat_stream(self, messages: List[ChatMessage], model: str, **kwargs) -> AsyncIterator[str]:\r\n        \"\"\"Stream chat completion from Ollama\"\"\"\r\n        if model not in self.models:\r\n            await self.load_model(model)\r\n            \r\n        async with self.client.stream('POST', '/api/chat', json={\r\n            'model': model,\r\n            'messages': [{'role': msg.role, 'content': msg.content} for msg in messages],\r\n            'stream': True,\r\n            'options': {\r\n                'temperature': kwargs.get('temperature', 0.7),\r\n                'num_predict': kwargs.get('max_tokens', 1000)\r\n            }\r\n        }) as response:\r\n            async for chunk in response.aiter_lines():\r\n                if chunk:\r\n                    data = json.loads(chunk)\r\n                    if 'message' in data and 'content' in data['message']:\r\n                        yield data['message']['content']\r\n    \r\n    async def health_check(self) -> bool:\r\n        \"\"\"Check if Ollama is running\"\"\"\r\n        try:\r\n            response = await self.client.get('/api/tags')\r\n            return response.status_code == 200\r\n        except:\r\n            return False\r\n```\r\n\r\n### 3. OpenAI Provider Implementation\r\n\r\n**Purpose:** Cloud AI provider for production\r\n\r\n**Implementation:**\r\n```python\r\n# apps/api/src/ai/providers/openai.py\r\nimport openai\r\nfrom typing import AsyncIterator, List\r\nfrom .base import AIProvider, ChatMessage\r\n\r\nclass OpenAIProvider(AIProvider):\r\n    \"\"\"OpenAI cloud AI provider\"\"\"\r\n    \r\n    def __init__(self, config: Dict[str, Any]):\r\n        super().__init__(config)\r\n        openai.api_key = config.get('api_key')\r\n        self.client = openai.AsyncClient()\r\n        \r\n    async def load_model(self, model_name: str) -> bool:\r\n        \"\"\"OpenAI models don't need explicit loading\"\"\"\r\n        self.models[model_name] = True\r\n        return True\r\n    \r\n    async def generate(self, prompt: str, model: str, **kwargs) -> str:\r\n        \"\"\"Generate completion using OpenAI\"\"\"\r\n        response = await self.client.completions.create(\r\n            model=model,\r\n            prompt=prompt,\r\n            temperature=kwargs.get('temperature', 0.7),\r\n            max_tokens=kwargs.get('max_tokens', 1000)\r\n        )\r\n        return response.choices[0].text\r\n    \r\n    async def generate_stream(self, prompt: str, model: str, **kwargs) -> AsyncIterator[str]:\r\n        \"\"\"Stream completion from OpenAI\"\"\"\r\n        response = await self.client.completions.create(\r\n            model=model,\r\n            prompt=prompt,\r\n            temperature=kwargs.get('temperature', 0.7),\r\n            max_tokens=kwargs.get('max_tokens', 1000),\r\n            stream=True\r\n        )\r\n        \r\n        async for chunk in response:\r\n            if chunk.choices[0].text:\r\n                yield chunk.choices[0].text\r\n    \r\n    async def chat(self, messages: List[ChatMessage], model: str, **kwargs) -> str:\r\n        \"\"\"Chat completion using OpenAI\"\"\"\r\n        response = await self.client.chat.completions.create(\r\n            model=model,\r\n            messages=[{\"role\": msg.role, \"content\": msg.content} for msg in messages],\r\n            temperature=kwargs.get('temperature', 0.7),\r\n            max_tokens=kwargs.get('max_tokens', 1000)\r\n        )\r\n        return response.choices[0].message.content\r\n    \r\n    async def chat_stream(self, messages: List[ChatMessage], model: str, **kwargs) -> AsyncIterator[str]:\r\n        \"\"\"Stream chat completion from OpenAI\"\"\"\r\n        response = await self.client.chat.completions.create(\r\n            model=model,\r\n            messages=[{\"role\": msg.role, \"content\": msg.content} for msg in messages],\r\n            temperature=kwargs.get('temperature', 0.7),\r\n            max_tokens=kwargs.get('max_tokens', 1000),\r\n            stream=True\r\n        )\r\n        \r\n        async for chunk in response:\r\n            if chunk.choices[0].delta.content:\r\n                yield chunk.choices[0].delta.content\r\n    \r\n    async def health_check(self) -> bool:\r\n        \"\"\"Check OpenAI API availability\"\"\"\r\n        try:\r\n            await self.client.models.list()\r\n            return True\r\n        except:\r\n            return False\r\n```\r\n\r\n### 4. HuggingFace Provider Implementation\r\n\r\n**Purpose:** Open-source models and inference\r\n\r\n**Implementation:**\r\n```python\r\n# apps/api/src/ai/providers/huggingface.py\r\nfrom transformers import pipeline, AutoTokenizer, AutoModelForCausalLM\r\nimport torch\r\nfrom typing import AsyncIterator, List\r\nfrom .base import AIProvider, ChatMessage\r\n\r\nclass HuggingFaceProvider(AIProvider):\r\n    \"\"\"HuggingFace local/cloud AI provider\"\"\"\r\n    \r\n    def __init__(self, config: Dict[str, Any]):\r\n        super().__init__(config)\r\n        self.device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\r\n        self.pipelines = {}\r\n        \r\n    async def load_model(self, model_name: str) -> bool:\r\n        \"\"\"Load HuggingFace model\"\"\"\r\n        try:\r\n            print(f\"📥 Loading HuggingFace model: {model_name}\")\r\n            \r\n            # Load tokenizer and model\r\n            tokenizer = AutoTokenizer.from_pretrained(model_name)\r\n            model = AutoModelForCausalLM.from_pretrained(\r\n                model_name,\r\n                device_map=\"auto\" if self.device == \"cuda\" else None,\r\n                torch_dtype=torch.float16 if self.device == \"cuda\" else torch.float32\r\n            )\r\n            \r\n            # Create pipeline\r\n            self.pipelines[model_name] = pipeline(\r\n                \"text-generation\",\r\n                model=model,\r\n                tokenizer=tokenizer,\r\n                device=0 if self.device == \"cuda\" else -1\r\n            )\r\n            \r\n            self.models[model_name] = True\r\n            print(f\"✅ HuggingFace model {model_name} loaded successfully\")\r\n            return True\r\n        except Exception as e:\r\n            print(f\"❌ Failed to load HuggingFace model {model_name}: {e}\")\r\n            return False\r\n    \r\n    async def generate(self, prompt: str, model: str, **kwargs) -> str:\r\n        \"\"\"Generate completion using HuggingFace\"\"\"\r\n        if model not in self.pipelines:\r\n            await self.load_model(model)\r\n            \r\n        pipeline = self.pipelines[model]\r\n        result = pipeline(\r\n            prompt,\r\n            max_length=len(prompt.split()) + kwargs.get('max_tokens', 100),\r\n            temperature=kwargs.get('temperature', 0.7),\r\n            do_sample=True,\r\n            pad_token_id=pipeline.tokenizer.eos_token_id\r\n        )\r\n        \r\n        generated_text = result[0]['generated_text']\r\n        # Return only the new text (remove the prompt)\r\n        return generated_text[len(prompt):].strip()\r\n    \r\n    async def health_check(self) -> bool:\r\n        \"\"\"Check if HuggingFace is available\"\"\"\r\n        return True  # Always available if properly configured\r\n```\r\n\r\n### 5. AI Provider Router\r\n\r\n**Purpose:** Route requests to appropriate AI providers based on configuration\r\n\r\n**Implementation:**\r\n```python\r\n# apps/api/src/ai/router.py\r\nfrom typing import Dict, Any, Optional\r\nfrom .providers.ollama import OllamaProvider\r\nfrom .providers.openai import OpenAIProvider\r\nfrom .providers.huggingface import HuggingFaceProvider\r\nfrom ..core.config import settings\r\n\r\nclass AIRouter:\r\n    \"\"\"Routes AI requests to appropriate providers\"\"\"\r\n    \r\n    def __init__(self):\r\n        self.providers = {}\r\n        self.default_provider = None\r\n        self.setup_providers()\r\n    \r\n    def setup_providers(self):\r\n        \"\"\"Initialize AI providers based on configuration\"\"\"\r\n        ai_config = settings.ai\r\n        \r\n        # Setup Ollama (local development)\r\n        if ai_config.get('ollama', {}).get('enabled', False):\r\n            self.providers['ollama'] = OllamaProvider(ai_config['ollama'])\r\n            \r\n        # Setup OpenAI (cloud)\r\n        if ai_config.get('openai', {}).get('enabled', False):\r\n            self.providers['openai'] = OpenAIProvider(ai_config['openai'])\r\n            \r\n        # Setup HuggingFace\r\n        if ai_config.get('huggingface', {}).get('enabled', False):\r\n            self.providers['huggingface'] = HuggingFaceProvider(ai_config['huggingface'])\r\n        \r\n        # Set default provider based on environment\r\n        routing = ai_config.get('routing', {})\r\n        env = settings.environment\r\n        self.default_provider = routing.get(env, 'ollama')\r\n    \r\n    def get_provider(self, provider_name: Optional[str] = None) -> AIProvider:\r\n        \"\"\"Get AI provider by name or use default\"\"\"\r\n        provider_name = provider_name or self.default_provider\r\n        \r\n        if provider_name not in self.providers:\r\n            raise ValueError(f\"AI provider '{provider_name}' not configured\")\r\n            \r\n        return self.providers[provider_name]\r\n    \r\n    async def health_check_all(self) -> Dict[str, bool]:\r\n        \"\"\"Check health of all providers\"\"\"\r\n        results = {}\r\n        for name, provider in self.providers.items():\r\n            results[name] = await provider.health_check()\r\n        return results\r\n\r\n# Global router instance\r\nai_router = AIRouter()\r\n```\r\n\r\n### 6. FastAPI Integration\r\n\r\n**Purpose:** Expose AI services through REST API\r\n\r\n**Implementation:**\r\n```python\r\n# apps/api/src/routes/ai.py\r\nfrom fastapi import APIRouter, HTTPException, BackgroundTasks\r\nfrom fastapi.responses import StreamingResponse\r\nfrom typing import List, Optional\r\nfrom ..ai.router import ai_router\r\nfrom ..ai.providers.base import ChatMessage, GenerationRequest\r\nfrom ..models.ai import (\r\n    ChatRequest, ChatResponse, GenerateRequest, GenerateResponse,\r\n    ModelInfo, ProviderStatus\r\n)\r\n\r\nrouter = APIRouter(prefix=\"/ai\", tags=[\"AI\"])\r\n\r\n@router.post(\"/chat\", response_model=ChatResponse)\r\nasync def chat_completion(request: ChatRequest):\r\n    \"\"\"Generate chat completion\"\"\"\r\n    try:\r\n        provider = ai_router.get_provider(request.provider)\r\n        \r\n        response = await provider.chat(\r\n            messages=request.messages,\r\n            model=request.model,\r\n            temperature=request.temperature,\r\n            max_tokens=request.max_tokens\r\n        )\r\n        \r\n        return ChatResponse(\r\n            response=response,\r\n            model=request.model,\r\n            provider=request.provider or ai_router.default_provider\r\n        )\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n@router.post(\"/chat/stream\")\r\nasync def chat_completion_stream(request: ChatRequest):\r\n    \"\"\"Stream chat completion\"\"\"\r\n    try:\r\n        provider = ai_router.get_provider(request.provider)\r\n        \r\n        async def generate_stream():\r\n            async for chunk in provider.chat_stream(\r\n                messages=request.messages,\r\n                model=request.model,\r\n                temperature=request.temperature,\r\n                max_tokens=request.max_tokens\r\n            ):\r\n                yield f\"data: {json.dumps({'content': chunk})}\\n\\n\"\r\n            yield \"data: [DONE]\\n\\n\"\r\n        \r\n        return StreamingResponse(\r\n            generate_stream(),\r\n            media_type=\"text/event-stream\",\r\n            headers={\r\n                \"Cache-Control\": \"no-cache\",\r\n                \"Connection\": \"keep-alive\",\r\n            }\r\n        )\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n@router.get(\"/models\", response_model=List[ModelInfo])\r\nasync def list_models(provider: Optional[str] = None):\r\n    \"\"\"List available models for a provider\"\"\"\r\n    try:\r\n        if provider:\r\n            ai_provider = ai_router.get_provider(provider)\r\n            # Implementation depends on provider capabilities\r\n            return []\r\n        else:\r\n            # Return models from all providers\r\n            return []\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n@router.get(\"/health\", response_model=Dict[str, ProviderStatus])\r\nasync def health_check():\r\n    \"\"\"Check health of all AI providers\"\"\"\r\n    health_results = await ai_router.health_check_all()\r\n    \r\n    return {\r\n        name: ProviderStatus(\r\n            name=name,\r\n            status=\"healthy\" if healthy else \"unhealthy\",\r\n            models=list(ai_router.providers[name].models.keys()) if healthy else []\r\n        )\r\n        for name, healthy in health_results.items()\r\n    }\r\n\r\n@router.post(\"/models/{model_name}/load\")\r\nasync def load_model(model_name: str, provider: Optional[str] = None, background_tasks: BackgroundTasks):\r\n    \"\"\"Load a specific model\"\"\"\r\n    try:\r\n        ai_provider = ai_router.get_provider(provider)\r\n        \r\n        # Load model in background to avoid request timeout\r\n        background_tasks.add_task(ai_provider.load_model, model_name)\r\n        \r\n        return {\"message\": f\"Loading model {model_name}...\"}\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n```\r\n\r\n---\r\n\r\n## Configuration System\r\n\r\n### FARM Configuration for AI\r\n\r\n**Local Development with Ollama:**\r\n```javascript\r\n// farm.config.js\r\nmodule.exports = {\r\n  ai: {\r\n    providers: {\r\n      ollama: {\r\n        enabled: true,\r\n        url: 'http://localhost:11434',\r\n        models: ['llama3.1', 'codestral', 'phi3', 'mistral'],\r\n        defaultModel: 'llama3.1',\r\n        autoStart: true,  // Start Ollama service with farm dev\r\n        autoPull: ['llama3.1']  // Auto-pull these models on first run\r\n      },\r\n      openai: {\r\n        enabled: true,\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n        models: ['gpt-4', 'gpt-3.5-turbo'],\r\n        defaultModel: 'gpt-3.5-turbo'\r\n      },\r\n      huggingface: {\r\n        enabled: true,\r\n        models: ['microsoft/DialoGPT-medium', 'gpt2'],\r\n        device: 'auto'  // auto, cpu, cuda\r\n      }\r\n    },\r\n    routing: {\r\n      development: 'ollama',     // Use local Ollama in dev\r\n      staging: 'openai',         // Use OpenAI in staging\r\n      production: 'openai'       // Use OpenAI in production\r\n    },\r\n    features: {\r\n      streaming: true,           // Enable streaming responses\r\n      caching: true,            // Cache responses\r\n      rateLimiting: true,       // Rate limit requests\r\n      fallback: true            // Fallback to other providers on failure\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Environment-Specific Configuration\r\n\r\n**Development (.env.development):**\r\n```bash\r\n# Local development with Ollama\r\nAI_PROVIDER=ollama\r\nOLLAMA_URL=http://localhost:11434\r\nAI_DEFAULT_MODEL=llama3.1\r\n\r\n# Optional cloud providers for testing\r\nOPENAI_API_KEY=sk-...\r\nHUGGINGFACE_TOKEN=hf_...\r\n```\r\n\r\n**Production (.env.production):**\r\n```bash\r\n# Production with OpenAI\r\nAI_PROVIDER=openai\r\nOPENAI_API_KEY=sk-...\r\nAI_DEFAULT_MODEL=gpt-3.5-turbo\r\n\r\n# Fallback configurations\r\nAI_FALLBACK_PROVIDER=huggingface\r\nAI_RATE_LIMIT=100\r\n```\r\n\r\n---\r\n\r\n## Development Server Integration\r\n\r\n### Ollama Service Management\r\n\r\n**Auto-start Ollama with Development Server:**\r\n```javascript\r\n// Addition to tools/dev-server/service_config.js\r\nexport const SERVICES = {\r\n  // ... existing services\r\n  \r\n  ollama: {\r\n    name: 'Ollama',\r\n    command: {\r\n      cmd: 'docker',\r\n      args: ['run', '-d', '--name', 'farm-ollama', '-p', '11434:11434', \r\n             '-v', 'ollama:/root/.ollama', 'ollama/ollama']\r\n    },\r\n    healthCheck: 'http://localhost:11434/api/tags',\r\n    required: false, // Only if AI + Ollama enabled\r\n    order: 1.5, // Start after database, before backend\r\n    autoStart: true,\r\n    postStart: async () => {\r\n      // Auto-pull configured models\r\n      const config = await loadFarmConfig();\r\n      const autoPull = config.ai?.providers?.ollama?.autoPull || [];\r\n      \r\n      for (const model of autoPull) {\r\n        console.log(`📥 Auto-pulling Ollama model: ${model}`);\r\n        // Trigger model pull in background\r\n      }\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n### Hot Model Reloading\r\n\r\n**Model Hot-Swap Without Service Restart:**\r\n```python\r\n# apps/api/src/ai/hot_reload.py\r\nclass AIModelHotReloader:\r\n    def __init__(self, ai_router):\r\n        self.ai_router = ai_router\r\n        \r\n    async def reload_model(self, provider_name: str, model_name: str):\r\n        \"\"\"Hot reload a specific model\"\"\"\r\n        try:\r\n            provider = self.ai_router.get_provider(provider_name)\r\n            \r\n            # Unload existing model if needed\r\n            if model_name in provider.models:\r\n                await self.unload_model(provider, model_name)\r\n            \r\n            # Load new/updated model\r\n            success = await provider.load_model(model_name)\r\n            \r\n            if success:\r\n                print(f\"🔥 Hot-reloaded model: {model_name}\")\r\n                return True\r\n            else:\r\n                print(f\"❌ Failed to hot-reload model: {model_name}\")\r\n                return False\r\n                \r\n        except Exception as e:\r\n            print(f\"❌ Model hot-reload error: {e}\")\r\n            return False\r\n    \r\n    async def unload_model(self, provider, model_name: str):\r\n        \"\"\"Unload model to free resources\"\"\"\r\n        if hasattr(provider, 'unload_model'):\r\n            await provider.unload_model(model_name)\r\n        else:\r\n            # Generic cleanup\r\n            if model_name in provider.models:\r\n                del provider.models[model_name]\r\n```\r\n\r\n---\r\n\r\n## Frontend Integration\r\n\r\n### Generated TypeScript Types\r\n\r\n**Auto-generated AI Types:**\r\n```typescript\r\n// apps/web/src/types/ai.ts (generated)\r\nexport interface ChatMessage {\r\n  role: 'system' | 'user' | 'assistant';\r\n  content: string;\r\n}\r\n\r\nexport interface ChatRequest {\r\n  messages: ChatMessage[];\r\n  model: string;\r\n  provider?: string;\r\n  temperature?: number;\r\n  maxTokens?: number;\r\n  stream?: boolean;\r\n}\r\n\r\nexport interface ChatResponse {\r\n  response: string;\r\n  model: string;\r\n  provider: string;\r\n  usage?: {\r\n    promptTokens: number;\r\n    completionTokens: number;\r\n    totalTokens: number;\r\n  };\r\n}\r\n\r\nexport interface ModelInfo {\r\n  name: string;\r\n  provider: string;\r\n  size?: string;\r\n  description?: string;\r\n}\r\n\r\nexport interface ProviderStatus {\r\n  name: string;\r\n  status: 'healthy' | 'unhealthy' | 'loading';\r\n  models: string[];\r\n}\r\n```\r\n\r\n### Generated API Client\r\n\r\n**Auto-generated AI API Client:**\r\n```typescript\r\n// apps/web/src/services/ai.ts (generated)\r\nimport { ApiClient } from '@farm/api-client';\r\nimport type * as AI from '../types/ai';\r\n\r\nconst client = new ApiClient({\r\n  baseURL: process.env.VITE_API_URL || 'http://localhost:8000'\r\n});\r\n\r\nexport const aiApi = {\r\n  // Chat completion\r\n  chat: (request: AI.ChatRequest): Promise<AI.ChatResponse> =>\r\n    client.post('/api/ai/chat', request),\r\n\r\n  // Streaming chat\r\n  chatStream: (request: AI.ChatRequest): EventSource =>\r\n    client.streamPost('/api/ai/chat/stream', request),\r\n\r\n  // List models\r\n  listModels: (provider?: string): Promise<AI.ModelInfo[]> =>\r\n    client.get('/api/ai/models', { params: { provider } }),\r\n\r\n  // Health check\r\n  healthCheck: (): Promise<Record<string, AI.ProviderStatus>> =>\r\n    client.get('/api/ai/health'),\r\n\r\n  // Load model\r\n  loadModel: (modelName: string, provider?: string): Promise<{message: string}> =>\r\n    client.post(`/api/ai/models/${modelName}/load`, { provider })\r\n};\r\n```\r\n\r\n### Generated React Hooks\r\n\r\n**Auto-generated AI Hooks:**\r\n```typescript\r\n// apps/web/src/hooks/ai.ts (generated)\r\nimport { useState, useEffect } from 'react';\r\nimport { useMutation, useQuery } from '@tanstack/react-query';\r\nimport { aiApi } from '../services/ai';\r\nimport type * as AI from '../types/ai';\r\n\r\nexport function useStreamingChat(initialMessages: AI.ChatMessage[] = []) {\r\n  const [messages, setMessages] = useState<AI.ChatMessage[]>(initialMessages);\r\n  const [isStreaming, setIsStreaming] = useState(false);\r\n\r\n  const sendMessage = async (content: string, options: Partial<AI.ChatRequest> = {}) => {\r\n    const userMessage: AI.ChatMessage = { role: 'user', content };\r\n    setMessages(prev => [...prev, userMessage]);\r\n    setIsStreaming(true);\r\n\r\n    try {\r\n      const eventSource = aiApi.chatStream({\r\n        messages: [...messages, userMessage],\r\n        model: options.model || 'llama3.1',\r\n        provider: options.provider || 'ollama',\r\n        ...options\r\n      });\r\n\r\n      let assistantMessage = '';\r\n      \r\n      eventSource.onmessage = (event) => {\r\n        if (event.data === '[DONE]') {\r\n          setIsStreaming(false);\r\n          eventSource.close();\r\n          return;\r\n        }\r\n\r\n        const data = JSON.parse(event.data);\r\n        assistantMessage += data.content;\r\n        \r\n        setMessages(prev => {\r\n          const newMessages = [...prev];\r\n          const lastMessage = newMessages[newMessages.length - 1];\r\n          \r\n          if (lastMessage?.role === 'assistant') {\r\n            lastMessage.content = assistantMessage;\r\n          } else {\r\n            newMessages.push({ role: 'assistant', content: assistantMessage });\r\n          }\r\n          \r\n          return newMessages;\r\n        });\r\n      };\r\n\r\n      eventSource.onerror = () => {\r\n        setIsStreaming(false);\r\n        eventSource.close();\r\n      };\r\n      \r\n    } catch (error) {\r\n      setIsStreaming(false);\r\n      console.error('Chat error:', error);\r\n    }\r\n  };\r\n\r\n  return {\r\n    messages,\r\n    sendMessage,\r\n    isStreaming,\r\n    clearMessages: () => setMessages([])\r\n  };\r\n}\r\n\r\nexport function useAIModels(provider?: string) {\r\n  return useQuery({\r\n    queryKey: ['ai-models', provider],\r\n    queryFn: () => aiApi.listModels(provider)\r\n  });\r\n}\r\n\r\nexport function useAIHealth() {\r\n  return useQuery({\r\n    queryKey: ['ai-health'],\r\n    queryFn: () => aiApi.healthCheck(),\r\n    refetchInterval: 30000 // Check every 30 seconds\r\n  });\r\n}\r\n\r\nexport function useLoadModel() {\r\n  return useMutation({\r\n    mutationFn: ({ modelName, provider }: { modelName: string; provider?: string }) =>\r\n      aiApi.loadModel(modelName, provider)\r\n  });\r\n}\r\n```\r\n\r\n---\r\n\r\n## Performance Optimization\r\n\r\n### GPU Resource Management\r\n\r\n**Intelligent GPU Allocation:**\r\n```python\r\n# apps/api/src/ai/gpu_manager.py\r\nimport torch\r\nimport psutil\r\nfrom typing import Dict, Optional\r\n\r\nclass GPUManager:\r\n    def __init__(self):\r\n        self.gpu_available = torch.cuda.is_available()\r\n        self.gpu_count = torch.cuda.device_count() if self.gpu_available else 0\r\n        self.model_assignments = {}  # model -> gpu mapping\r\n        \r\n    def allocate_gpu(self, model_name: str) -> Optional[int]:\r\n        \"\"\"Allocate optimal GPU for model\"\"\"\r\n        if not self.gpu_available:\r\n            return None\r\n            \r\n        # Find GPU with most free memory\r\n        best_gpu = 0\r\n        max_free_memory = 0\r\n        \r\n        for i in range(self.gpu_count):\r\n            torch.cuda.set_device(i)\r\n            free_memory = torch.cuda.get_device_properties(i).total_memory - torch.cuda.memory_allocated(i)\r\n            \r\n            if free_memory > max_free_memory:\r\n                max_free_memory = free_memory\r\n                best_gpu = i\r\n        \r\n        self.model_assignments[model_name] = best_gpu\r\n        return best_gpu\r\n    \r\n    def get_gpu_stats(self) -> Dict:\r\n        \"\"\"Get current GPU utilization\"\"\"\r\n        if not self.gpu_available:\r\n            return {\"available\": False}\r\n            \r\n        stats = {\"available\": True, \"devices\": []}\r\n        \r\n        for i in range(self.gpu_count):\r\n            torch.cuda.set_device(i)\r\n            props = torch.cuda.get_device_properties(i)\r\n            \r\n            stats[\"devices\"].append({\r\n                \"id\": i,\r\n                \"name\": props.name,\r\n                \"memory_total\": props.total_memory,\r\n                \"memory_used\": torch.cuda.memory_allocated(i),\r\n                \"memory_free\": props.total_memory - torch.cuda.memory_allocated(i)\r\n            })\r\n            \r\n        return stats\r\n```\r\n\r\n### Response Caching\r\n\r\n**Intelligent Response Caching:**\r\n```python\r\n# apps/api/src/ai/cache.py\r\nimport hashlib\r\nimport json\r\nfrom typing import Optional, Any\r\nfrom redis import Redis\r\n\r\nclass AIResponseCache:\r\n    def __init__(self, redis_url: str = \"redis://localhost:6379\"):\r\n        self.redis = Redis.from_url(redis_url)\r\n        self.default_ttl = 3600  # 1 hour\r\n        \r\n    def _generate_key(self, prompt: str, model: str, **kwargs) -> str:\r\n        \"\"\"Generate cache key from request parameters\"\"\"\r\n        cache_data = {\r\n            \"prompt\": prompt,\r\n            \"model\": model,\r\n            **kwargs\r\n        }\r\n        key_string = json.dumps(cache_data, sort_keys=True)\r\n        return f\"ai_cache:{hashlib.md5(key_string.encode()).hexdigest()}\"\r\n    \r\n    async def get(self, prompt: str, model: str, **kwargs) -> Optional[str]:\r\n        \"\"\"Get cached response if available\"\"\"\r\n        key = self._generate_key(prompt, model, **kwargs)\r\n        cached = self.redis.get(key)\r\n        \r\n        if cached:\r\n            return cached.decode('utf-8')\r\n        return None\r\n    \r\n    async def set(self, prompt: str, model: str, response: str, ttl: Optional[int] = None, **kwargs):\r\n        \"\"\"Cache AI response\"\"\"\r\n        key = self._generate_key(prompt, model, **kwargs)\r\n        self.redis.setex(key, ttl or self.default_ttl, response)\r\n```\r\n\r\n---\r\n\r\n## Error Handling & Fallbacks\r\n\r\n### Provider Fallback System\r\n\r\n**Automatic Provider Switching:**\r\n```python\r\n# apps/api/src/ai/fallback.py\r\nclass AIFallbackManager:\r\n    def __init__(self, ai_router):\r\n        self.ai_router = ai_router\r\n        self.fallback_order = ['ollama', 'openai', 'huggingface']\r\n        \r\n    async def execute_with_fallback(self, operation: str, *args, **kwargs):\r\n        \"\"\"Execute AI operation with automatic fallback\"\"\"\r\n        last_error = None\r\n        \r\n        for provider_name in self.fallback_order:\r\n            if provider_name not in self.ai_router.providers:\r\n                continue\r\n                \r\n            try:\r\n                provider = self.ai_router.get_provider(provider_name)\r\n                \r\n                # Check if provider is healthy\r\n                if not await provider.health_check():\r\n                    continue\r\n                    \r\n                # Execute operation\r\n                if operation == 'chat':\r\n                    return await provider.chat(*args, **kwargs)\r\n                elif operation == 'generate':\r\n                    return await provider.generate(*args, **kwargs)\r\n                # ... other operations\r\n                    \r\n            except Exception as e:\r\n                last_error = e\r\n                print(f\"⚠️ Provider {provider_name} failed: {e}\")\r\n                continue\r\n        \r\n        # All providers failed\r\n        raise Exception(f\"All AI providers failed. Last error: {last_error}\")\r\n```\r\n\r\n---\r\n\r\n*Status: ✅ Completed - Ready for implementation*\r\n",
      "excerpt": "FARM provides first-class AI/ML integration with seamless local-to-cloud workflows.",
      "category": "architectural-sketches-detailed/phase1",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "farm",
        "typescript",
        "python"
      ],
      "lastModified": "2025-06-12T21:57:32.774Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase1",
        "Ai_ml_integration_points"
      ],
      "headings": [
        {
          "level": 1,
          "text": "AI/ML Integration Points",
          "id": "aiml-integration-points"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "High-Level AI Integration Architecture",
          "id": "high-level-ai-integration-architecture"
        },
        {
          "level": 2,
          "text": "Core Components",
          "id": "core-components"
        },
        {
          "level": 3,
          "text": "1. AI Provider Abstraction Layer",
          "id": "1-ai-provider-abstraction-layer"
        },
        {
          "level": 1,
          "text": "apps/api/src/ai/providers/base.py",
          "id": "appsapisrcaiprovidersbasepy"
        },
        {
          "level": 3,
          "text": "2. Ollama Provider Implementation",
          "id": "2-ollama-provider-implementation"
        },
        {
          "level": 1,
          "text": "apps/api/src/ai/providers/ollama.py",
          "id": "appsapisrcaiprovidersollamapy"
        },
        {
          "level": 3,
          "text": "3. OpenAI Provider Implementation",
          "id": "3-openai-provider-implementation"
        },
        {
          "level": 1,
          "text": "apps/api/src/ai/providers/openai.py",
          "id": "appsapisrcaiprovidersopenaipy"
        },
        {
          "level": 3,
          "text": "4. HuggingFace Provider Implementation",
          "id": "4-huggingface-provider-implementation"
        },
        {
          "level": 1,
          "text": "apps/api/src/ai/providers/huggingface.py",
          "id": "appsapisrcaiprovidershuggingfacepy"
        },
        {
          "level": 3,
          "text": "5. AI Provider Router",
          "id": "5-ai-provider-router"
        },
        {
          "level": 1,
          "text": "apps/api/src/ai/router.py",
          "id": "appsapisrcairouterpy"
        },
        {
          "level": 1,
          "text": "Global router instance",
          "id": "global-router-instance"
        },
        {
          "level": 3,
          "text": "6. FastAPI Integration",
          "id": "6-fastapi-integration"
        },
        {
          "level": 1,
          "text": "apps/api/src/routes/ai.py",
          "id": "appsapisrcroutesaipy"
        },
        {
          "level": 2,
          "text": "Configuration System",
          "id": "configuration-system"
        },
        {
          "level": 3,
          "text": "FARM Configuration for AI",
          "id": "farm-configuration-for-ai"
        },
        {
          "level": 3,
          "text": "Environment-Specific Configuration",
          "id": "environment-specific-configuration"
        },
        {
          "level": 1,
          "text": "Local development with Ollama",
          "id": "local-development-with-ollama"
        },
        {
          "level": 1,
          "text": "Optional cloud providers for testing",
          "id": "optional-cloud-providers-for-testing"
        },
        {
          "level": 1,
          "text": "Production with OpenAI",
          "id": "production-with-openai"
        },
        {
          "level": 1,
          "text": "Fallback configurations",
          "id": "fallback-configurations"
        },
        {
          "level": 2,
          "text": "Development Server Integration",
          "id": "development-server-integration"
        },
        {
          "level": 3,
          "text": "Ollama Service Management",
          "id": "ollama-service-management"
        },
        {
          "level": 3,
          "text": "Hot Model Reloading",
          "id": "hot-model-reloading"
        },
        {
          "level": 1,
          "text": "apps/api/src/ai/hot_reload.py",
          "id": "appsapisrcaihot_reloadpy"
        },
        {
          "level": 2,
          "text": "Frontend Integration",
          "id": "frontend-integration"
        },
        {
          "level": 3,
          "text": "Generated TypeScript Types",
          "id": "generated-typescript-types"
        },
        {
          "level": 3,
          "text": "Generated API Client",
          "id": "generated-api-client"
        },
        {
          "level": 3,
          "text": "Generated React Hooks",
          "id": "generated-react-hooks"
        },
        {
          "level": 2,
          "text": "Performance Optimization",
          "id": "performance-optimization"
        },
        {
          "level": 3,
          "text": "GPU Resource Management",
          "id": "gpu-resource-management"
        },
        {
          "level": 1,
          "text": "apps/api/src/ai/gpu_manager.py",
          "id": "appsapisrcaigpu_managerpy"
        },
        {
          "level": 3,
          "text": "Response Caching",
          "id": "response-caching"
        },
        {
          "level": 1,
          "text": "apps/api/src/ai/cache.py",
          "id": "appsapisrcaicachepy"
        },
        {
          "level": 2,
          "text": "Error Handling & Fallbacks",
          "id": "error-handling-fallbacks"
        },
        {
          "level": 3,
          "text": "Provider Fallback System",
          "id": "provider-fallback-system"
        },
        {
          "level": 1,
          "text": "apps/api/src/ai/fallback.py",
          "id": "appsapisrcaifallbackpy"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase1-cli_command_structure",
      "title": "Cli_command_structure",
      "url": "/architectural-sketches-detailed/phase1/cli_command_structure",
      "content": "# CLI Command Structure & Flow\r\n\r\n## Overview\r\n\r\nThe FARM CLI follows the Next.js model of comprehensive argument support with intelligent prompting - respecting both \"quick start\" developers and \"I know exactly what I want\" developers.\r\n\r\n---\r\n\r\n## `farm create` Command\r\n\r\n### Command Syntax\r\n```bash\r\nfarm create <project-name> [options]\r\n```\r\n\r\n### Core Arguments & Options\r\n\r\n#### Templates (`--template`, `-t`)\r\n```bash\r\n--template basic          # Simple React + FastAPI + MongoDB\r\n--template ai-chat        # Chat app with streaming AI responses\r\n--template ai-dashboard   # Data dashboard with ML insights  \r\n--template ecommerce      # E-commerce platform with payments\r\n--template cms            # Content management system\r\n--template api-only       # FastAPI backend only (no React)\r\n--template custom         # Custom template from URL/path\r\n```\r\n\r\n#### Features (`--features`, `-f`)\r\n```bash\r\n--features auth                    # Single feature\r\n--features auth,ai,realtime        # Multiple features\r\n--no-features                      # Disable all optional features\r\n\r\n# Available features:\r\n# - auth: JWT authentication + user management\r\n# - ai: AI/ML model serving + inference endpoints\r\n# - realtime: WebSocket support + real-time features\r\n# - payments: Stripe/PayPal integration\r\n# - email: Email service integration\r\n# - storage: File upload + cloud storage\r\n# - search: Full-text search with MongoDB/Elasticsearch\r\n# - analytics: User analytics and tracking\r\n```\r\n\r\n#### Database (`--database`, `-d`)\r\n```bash\r\n--database mongodb        # MongoDB (default)\r\n--database postgresql     # PostgreSQL with SQLAlchemy\r\n--database mysql          # MySQL with SQLAlchemy  \r\n--database sqlite         # SQLite for development\r\n```\r\n\r\n#### Development Options\r\n```bash\r\n--typescript              # Enable TypeScript (default: true)\r\n--no-typescript          # Use JavaScript instead\r\n--docker                 # Include Docker setup (default: true)\r\n--no-docker              # Skip Docker configuration\r\n--testing                # Include test setup (default: true)\r\n--no-testing             # Skip testing configuration\r\n```\r\n\r\n#### Setup Options\r\n```bash\r\n--git                     # Initialize git repo (default: true)\r\n--no-git                 # Skip git initialization\r\n--install                # Install dependencies (default: true)\r\n--no-install             # Skip dependency installation\r\n--interactive            # Force interactive mode\r\n--no-interactive         # Skip all prompts (use defaults/args only)\r\n```\r\n\r\n---\r\n\r\n## Interactive Prompt Flow\r\n\r\n**When `farm create my-app` is run without arguments:**\r\n\r\n```\r\n🌾 Welcome to FARM Stack Framework!\r\n\r\n? What template would you like to use?\r\n  ❯ Basic Web App\r\n    AI Chat Application  \r\n    AI Dashboard\r\n    E-commerce Platform\r\n    Content Management System\r\n    API Only (Backend)\r\n    Custom Template\r\n\r\n? Which features would you like to enable? (Press <space> to select)\r\n  ✓ Authentication & User Management\r\n  ✓ AI/ML Integration\r\n  ○ Real-time Features (WebSocket)\r\n  ○ Payment Processing\r\n  ○ Email Service\r\n  ○ File Storage\r\n  ○ Full-text Search\r\n  ○ Analytics\r\n\r\n? Which database would you like to use?\r\n  ❯ MongoDB (Recommended)\r\n    PostgreSQL\r\n    MySQL\r\n    SQLite\r\n\r\n? Additional setup options:\r\n  ✓ TypeScript\r\n  ✓ Docker configuration\r\n  ✓ Testing setup\r\n  ✓ Git repository\r\n  ✓ Install dependencies\r\n```\r\n\r\n---\r\n\r\n## Smart Prompting Logic\r\n\r\n**Example scenarios:**\r\n\r\n```bash\r\n# Scenario 1: Template specified, prompt for features\r\nfarm create my-app --template ai-chat\r\n# → Prompts for features, database, setup options\r\n\r\n# Scenario 2: Template + some features, prompt for remaining\r\nfarm create my-app --template ai-chat --features auth,ai\r\n# → Prompts for database, setup options (skips feature selection)\r\n\r\n# Scenario 3: Almost everything specified\r\nfarm create my-app --template ai-chat --features auth,ai --database mongodb\r\n# → Only prompts for setup options (TypeScript, Docker, etc.)\r\n\r\n# Scenario 4: Completely specified\r\nfarm create my-app --template ai-chat --features auth,ai --database mongodb --typescript --docker --no-interactive\r\n# → No prompts, creates project immediately\r\n```\r\n\r\n---\r\n\r\n## Command Examples\r\n\r\n```bash\r\n# Quick start - interactive for everything\r\nfarm create my-ai-app\r\n\r\n# Specific template with prompts for rest\r\nfarm create my-ai-app --template ai-chat\r\n\r\n# Power user - exactly what they want\r\nfarm create my-ai-app \\\r\n  --template ai-chat \\\r\n  --features auth,ai,realtime \\\r\n  --database mongodb \\\r\n  --typescript \\\r\n  --docker \\\r\n  --no-interactive\r\n\r\n# Backend only project\r\nfarm create my-api --template api-only --features auth,ai --database postgresql\r\n\r\n# Custom template from GitHub\r\nfarm create my-app --template https://github.com/user/farm-template-custom\r\n```\r\n\r\n---\r\n\r\n## Additional CLI Commands (Future Planning)\r\n\r\n### Development Commands\r\n```bash\r\nfarm dev [--frontend-only] [--backend-only] [--port <port>]\r\nfarm dev --watch [--verbose]\r\n```\r\n\r\n### Code Generation Commands\r\n```bash\r\nfarm generate model <name> [--fields <fields>]\r\nfarm generate route <name> [--methods <methods>]\r\nfarm generate page <name> [--crud]\r\nfarm generate component <name>\r\n```\r\n\r\n### Database Commands\r\n```bash\r\nfarm db migrate [--create] [--upgrade] [--downgrade]\r\nfarm db seed [--file <file>]\r\nfarm db studio\r\n```\r\n\r\n### AI/ML Commands\r\n```bash\r\nfarm ml serve <model> [--port <port>]\r\nfarm ml train <script> [--gpu]\r\nfarm ml deploy <model> [--platform <platform>]\r\n```\r\n\r\n### Build & Deployment Commands\r\n```bash\r\nfarm build [--production] [--analyze]\r\nfarm deploy [--platform <platform>] [--config <config>]\r\nfarm docker build [--tag <tag>]\r\n```\r\n\r\n---\r\n\r\n*Status: ✅ Completed - Ready for implementation*\r\n",
      "excerpt": "The FARM CLI follows the Next.",
      "category": "architectural-sketches-detailed/phase1",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.775Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase1",
        "Cli_command_structure"
      ],
      "headings": [
        {
          "level": 1,
          "text": "CLI Command Structure & Flow",
          "id": "cli-command-structure-flow"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "`farm create` Command",
          "id": "farm-create-command"
        },
        {
          "level": 3,
          "text": "Command Syntax",
          "id": "command-syntax"
        },
        {
          "level": 3,
          "text": "Core Arguments & Options",
          "id": "core-arguments-options"
        },
        {
          "level": 4,
          "text": "Templates (`--template`, `-t`)",
          "id": "templates---template--t"
        },
        {
          "level": 4,
          "text": "Features (`--features`, `-f`)",
          "id": "features---features--f"
        },
        {
          "level": 1,
          "text": "Available features:",
          "id": "available-features"
        },
        {
          "level": 1,
          "text": "- auth: JWT authentication + user management",
          "id": "--auth-jwt-authentication-user-management"
        },
        {
          "level": 1,
          "text": "- ai: AI/ML model serving + inference endpoints",
          "id": "--ai-aiml-model-serving-inference-endpoints"
        },
        {
          "level": 1,
          "text": "- realtime: WebSocket support + real-time features",
          "id": "--realtime-websocket-support-real-time-features"
        },
        {
          "level": 1,
          "text": "- payments: Stripe/PayPal integration",
          "id": "--payments-stripepaypal-integration"
        },
        {
          "level": 1,
          "text": "- email: Email service integration",
          "id": "--email-email-service-integration"
        },
        {
          "level": 1,
          "text": "- storage: File upload + cloud storage",
          "id": "--storage-file-upload-cloud-storage"
        },
        {
          "level": 1,
          "text": "- search: Full-text search with MongoDB/Elasticsearch",
          "id": "--search-full-text-search-with-mongodbelasticsearch"
        },
        {
          "level": 1,
          "text": "- analytics: User analytics and tracking",
          "id": "--analytics-user-analytics-and-tracking"
        },
        {
          "level": 4,
          "text": "Database (`--database`, `-d`)",
          "id": "database---database--d"
        },
        {
          "level": 4,
          "text": "Development Options",
          "id": "development-options"
        },
        {
          "level": 4,
          "text": "Setup Options",
          "id": "setup-options"
        },
        {
          "level": 2,
          "text": "Interactive Prompt Flow",
          "id": "interactive-prompt-flow"
        },
        {
          "level": 2,
          "text": "Smart Prompting Logic",
          "id": "smart-prompting-logic"
        },
        {
          "level": 1,
          "text": "Scenario 1: Template specified, prompt for features",
          "id": "scenario-1-template-specified-prompt-for-features"
        },
        {
          "level": 1,
          "text": "→ Prompts for features, database, setup options",
          "id": "-prompts-for-features-database-setup-options"
        },
        {
          "level": 1,
          "text": "Scenario 2: Template + some features, prompt for remaining",
          "id": "scenario-2-template-some-features-prompt-for-remaining"
        },
        {
          "level": 1,
          "text": "→ Prompts for database, setup options (skips feature selection)",
          "id": "-prompts-for-database-setup-options-skips-feature-selection"
        },
        {
          "level": 1,
          "text": "Scenario 3: Almost everything specified",
          "id": "scenario-3-almost-everything-specified"
        },
        {
          "level": 1,
          "text": "→ Only prompts for setup options (TypeScript, Docker, etc.)",
          "id": "-only-prompts-for-setup-options-typescript-docker-etc"
        },
        {
          "level": 1,
          "text": "Scenario 4: Completely specified",
          "id": "scenario-4-completely-specified"
        },
        {
          "level": 1,
          "text": "→ No prompts, creates project immediately",
          "id": "-no-prompts-creates-project-immediately"
        },
        {
          "level": 2,
          "text": "Command Examples",
          "id": "command-examples"
        },
        {
          "level": 1,
          "text": "Quick start - interactive for everything",
          "id": "quick-start---interactive-for-everything"
        },
        {
          "level": 1,
          "text": "Specific template with prompts for rest",
          "id": "specific-template-with-prompts-for-rest"
        },
        {
          "level": 1,
          "text": "Power user - exactly what they want",
          "id": "power-user---exactly-what-they-want"
        },
        {
          "level": 1,
          "text": "Backend only project",
          "id": "backend-only-project"
        },
        {
          "level": 1,
          "text": "Custom template from GitHub",
          "id": "custom-template-from-github"
        },
        {
          "level": 2,
          "text": "Additional CLI Commands (Future Planning)",
          "id": "additional-cli-commands-future-planning"
        },
        {
          "level": 3,
          "text": "Development Commands",
          "id": "development-commands"
        },
        {
          "level": 3,
          "text": "Code Generation Commands",
          "id": "code-generation-commands"
        },
        {
          "level": 3,
          "text": "Database Commands",
          "id": "database-commands"
        },
        {
          "level": 3,
          "text": "AI/ML Commands",
          "id": "aiml-commands"
        },
        {
          "level": 3,
          "text": "Build & Deployment Commands",
          "id": "build-deployment-commands"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase1-code_generation_pipeline",
      "title": "Code_generation_pipeline",
      "url": "/architectural-sketches-detailed/phase1/code_generation_pipeline",
      "content": "# Code Generation Pipeline Architecture\r\n\r\n## Overview\r\n\r\nThe code generation pipeline is the core \"magic\" that enables type-safe full-stack development in FARM. It automatically transforms Python Pydantic models and FastAPI routes into TypeScript types and API client functions, maintaining perfect synchronization between backend and frontend.\r\n\r\n---\r\n\r\n## Generation Flow Architecture\r\n\r\n```\r\n┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐\r\n│ Pydantic Models │───▶│ OpenAPI Schema   │───▶│ TypeScript Types│\r\n│ (Python)        │    │ (JSON)           │    │ (Generated)     │\r\n└─────────────────┘    └──────────────────┘    └─────────────────┘\r\n         │                        │                        │\r\n         ▼                        ▼                        ▼\r\n┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐\r\n│ FastAPI Routes  │───▶│ API Endpoints    │───▶│ API Client      │\r\n│ (Python)        │    │ (OpenAPI)        │    │ (Generated)     │\r\n└─────────────────┘    └──────────────────┘    └─────────────────┘\r\n         │                        │                        │\r\n         ▼                        ▼                        ▼\r\n┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐\r\n│ File Watcher    │───▶│ Hot Reload       │───▶│ Frontend Update │\r\n│ (Development)   │    │ Trigger          │    │ (Live)          │\r\n└─────────────────┘    └──────────────────┘    └─────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Components\r\n\r\n### 1. OpenAPI Schema Extraction\r\n\r\n**Purpose:** Extract comprehensive schema from FastAPI application\r\n\r\n**Implementation:**\r\n```python\r\n# tools/codegen/openapi_extractor.py\r\nfrom fastapi.openapi.utils import get_openapi\r\nfrom fastapi import FastAPI\r\nimport json\r\n\r\nclass OpenAPIExtractor:\r\n    def __init__(self, app: FastAPI):\r\n        self.app = app\r\n    \r\n    def extract_schema(self) -> dict:\r\n        \"\"\"Extract OpenAPI schema from FastAPI app\"\"\"\r\n        return get_openapi(\r\n            title=self.app.title,\r\n            version=self.app.version,\r\n            openapi_version=self.app.openapi_version,\r\n            description=self.app.description,\r\n            routes=self.app.routes,\r\n            servers=self.app.servers\r\n        )\r\n    \r\n    def save_schema(self, output_path: str):\r\n        \"\"\"Save schema to file for generation\"\"\"\r\n        schema = self.extract_schema()\r\n        with open(output_path, 'w') as f:\r\n            json.dump(schema, f, indent=2)\r\n```\r\n\r\n### 2. TypeScript Type Generator\r\n\r\n**Purpose:** Convert OpenAPI schemas to TypeScript interfaces\r\n\r\n**Generated File Structure:**\r\n```\r\napps/web/src/types/\r\n├── index.ts                 # Main export file\r\n├── api.ts                   # API-related types\r\n├── ai.ts                    # AI provider types (Ollama, OpenAI, HuggingFace)\r\n├── models/                  # Model interfaces\r\n│   ├── user.ts              # Generated from User model\r\n│   ├── conversation.ts      # Generated from Conversation model (AI apps)\r\n│   ├── message.ts           # Generated from Message model (AI apps)\r\n│   └── index.ts             # Model exports\r\n└── requests/                # Request/Response types\r\n    ├── auth.ts              # Auth-related requests\r\n    ├── users.ts             # User CRUD requests\r\n    ├── ai.ts                # AI provider requests/responses\r\n    └── index.ts             # Request exports\r\n```\r\n\r\n**Generation Logic:**\r\n```typescript\r\n// tools/codegen/typescript_generator.js\r\nclass TypeScriptGenerator {\r\n  constructor(openAPISchema) {\r\n    this.schema = openAPISchema;\r\n  }\r\n\r\n  generateTypes() {\r\n    const types = {};\r\n    \r\n    // Generate model interfaces from components/schemas\r\n    for (const [name, schema] of Object.entries(this.schema.components?.schemas || {})) {\r\n      types[name] = this.generateInterface(name, schema);\r\n    }\r\n    \r\n    // Generate request/response types from paths\r\n    for (const [path, methods] of Object.entries(this.schema.paths || {})) {\r\n      for (const [method, operation] of Object.entries(methods)) {\r\n        types[`${operation.operationId}Request`] = this.generateRequestType(operation);\r\n        types[`${operation.operationId}Response`] = this.generateResponseType(operation);\r\n      }\r\n    }\r\n    \r\n    return types;\r\n  }\r\n\r\n  generateInterface(name, schema) {\r\n    // Convert OpenAPI schema to TypeScript interface\r\n    // Handle: objects, arrays, unions, enums, optionals\r\n  }\r\n}\r\n```\r\n\r\n### 3. API Client Generator\r\n\r\n**Purpose:** Generate type-safe API client functions\r\n\r\n**Generated API Client:**\r\n```typescript\r\n// apps/web/src/services/api.ts (generated)\r\nimport { ApiClient } from '@farm/api-client';\r\nimport type * as Types from '../types';\r\n\r\nconst client = new ApiClient({\r\n  baseURL: process.env.VITE_API_URL || 'http://localhost:8000'\r\n});\r\n\r\n// User operations\r\nexport const userApi = {\r\n  // GET /api/users\r\n  list: (params?: Types.ListUsersRequest): Promise<Types.PaginatedResponse<Types.User>> =>\r\n    client.get('/api/users', { params }),\r\n  \r\n  // POST /api/users\r\n  create: (data: Types.CreateUserRequest): Promise<Types.User> =>\r\n    client.post('/api/users', data),\r\n  \r\n  // GET /api/users/{id}\r\n  getById: (id: string): Promise<Types.User> =>\r\n    client.get(`/api/users/${id}`),\r\n  \r\n  // PATCH /api/users/{id}\r\n  update: (id: string, data: Types.UpdateUserRequest): Promise<Types.User> =>\r\n    client.patch(`/api/users/${id}`, data),\r\n  \r\n  // DELETE /api/users/{id}\r\n  delete: (id: string): Promise<void> =>\r\n    client.delete(`/api/users/${id}`)\r\n};\r\n\r\n// AI operations with provider support\r\nexport const aiApi = {\r\n  // POST /api/ai/chat - Defaults to Ollama in development\r\n  chat: (data: Types.ChatRequest): Promise<Types.ChatResponse> =>\r\n    client.post('/api/ai/chat', data),\r\n  \r\n  // POST /api/ai/chat/stream - Streaming with Ollama/OpenAI\r\n  chatStream: (data: Types.ChatRequest): EventSource =>\r\n    client.streamPost('/api/ai/chat/stream', data),\r\n\r\n  // GET /api/ai/models - List models by provider\r\n  listModels: (provider?: 'ollama' | 'openai' | 'huggingface'): Promise<Types.ModelInfo[]> =>\r\n    client.get('/api/ai/models', { params: { provider } }),\r\n\r\n  // GET /api/ai/health - Check all AI provider health\r\n  healthCheck: (): Promise<Record<string, Types.ProviderStatus>> =>\r\n    client.get('/api/ai/health'),\r\n\r\n  // POST /api/ai/models/{model}/load - Load Ollama model\r\n  loadModel: (modelName: string, provider?: string): Promise<{message: string}> =>\r\n    client.post(`/api/ai/models/${modelName}/load`, { provider })\r\n};\r\n```\r\n\r\n### 4. React Hook Generator\r\n\r\n**Purpose:** Generate custom hooks for API operations\r\n\r\n**Generated Hooks:**\r\n```typescript\r\n// apps/web/src/hooks/api.ts (generated)\r\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\r\nimport { userApi, aiApi } from '../services/api';\r\nimport type * as Types from '../types';\r\n\r\n// User hooks\r\nexport function useUsers(params?: Types.ListUsersRequest) {\r\n  return useQuery({\r\n    queryKey: ['users', params],\r\n    queryFn: () => userApi.list(params)\r\n  });\r\n}\r\n\r\nexport function useUser(id: string) {\r\n  return useQuery({\r\n    queryKey: ['users', id],\r\n    queryFn: () => userApi.getById(id),\r\n    enabled: !!id\r\n  });\r\n}\r\n\r\nexport function useCreateUser() {\r\n  const queryClient = useQueryClient();\r\n  \r\n  return useMutation({\r\n    mutationFn: userApi.create,\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: ['users'] });\r\n    }\r\n  });\r\n}\r\n\r\n// AI hooks with Ollama support\r\nexport function useAIChat(provider: 'ollama' | 'openai' = 'ollama') {\r\n  return useMutation({\r\n    mutationFn: (request: Types.ChatRequest) => \r\n      aiApi.chat({ ...request, provider })\r\n  });\r\n}\r\n\r\nexport function useAIModels(provider?: 'ollama' | 'openai') {\r\n  return useQuery({\r\n    queryKey: ['ai-models', provider],\r\n    queryFn: () => aiApi.listModels(provider),\r\n    staleTime: 5 * 60 * 1000 // 5 minutes\r\n  });\r\n}\r\n\r\nexport function useAIProviderHealth() {\r\n  return useQuery({\r\n    queryKey: ['ai-health'],\r\n    queryFn: () => aiApi.healthCheck(),\r\n    refetchInterval: 30000 // Check every 30 seconds\r\n  });\r\n}\r\n\r\nexport function useStreamingChat(defaultProvider: 'ollama' | 'openai' = 'ollama') {\r\n  // Custom streaming hook for real-time AI responses\r\n  // Defaults to Ollama for local development, OpenAI for production\r\n  const [messages, setMessages] = useState<Types.ChatMessage[]>([]);\r\n  const [isStreaming, setIsStreaming] = useState(false);\r\n  \r\n  // Implementation handles EventSource streaming from Ollama/OpenAI\r\n  // ...\r\n}\r\n```\r\n\r\n---\r\n\r\n## Generation Triggers\r\n\r\n### 1. Development Mode (File Watching)\r\n\r\n**File Watcher Configuration:**\r\n```javascript\r\n// tools/codegen/file_watcher.js\r\nimport chokidar from 'chokidar';\r\nimport { CodeGenerator } from './generator.js';\r\n\r\nclass FarmFileWatcher {\r\n  constructor(projectPath) {\r\n    this.projectPath = projectPath;\r\n    this.generator = new CodeGenerator(projectPath);\r\n  }\r\n\r\n  start() {\r\n    // Watch Python model files\r\n    const modelWatcher = chokidar.watch('apps/api/src/models/**/*.py', {\r\n      ignoreInitial: true\r\n    });\r\n\r\n    // Watch FastAPI route files\r\n    const routeWatcher = chokidar.watch('apps/api/src/routes/**/*.py', {\r\n      ignoreInitial: true\r\n    });\r\n\r\n    // Trigger regeneration on changes\r\n    [modelWatcher, routeWatcher].forEach(watcher => {\r\n      watcher.on('change', this.onPythonFileChange.bind(this));\r\n      watcher.on('add', this.onPythonFileChange.bind(this));\r\n      watcher.on('unlink', this.onPythonFileChange.bind(this));\r\n    });\r\n  }\r\n\r\n  async onPythonFileChange(path) {\r\n    console.log(`🔄 Python file changed: ${path}`);\r\n    console.log('🏗️  Regenerating TypeScript types...');\r\n    \r\n    try {\r\n      await this.generator.regenerateTypes();\r\n      console.log('✅ Types regenerated successfully');\r\n      \r\n      // Trigger frontend hot reload\r\n      this.triggerHotReload();\r\n    } catch (error) {\r\n      console.error('❌ Type generation failed:', error);\r\n    }\r\n  }\r\n\r\n  triggerHotReload() {\r\n    // Send HMR signal to Vite dev server\r\n    // This ensures frontend picks up new types immediately\r\n  }\r\n}\r\n```\r\n\r\n### 2. Build Time Generation\r\n\r\n**Build Integration:**\r\n```javascript\r\n// apps/web/vite.config.ts\r\nimport { defineConfig } from 'vite';\r\nimport { farmCodegenPlugin } from '@farm/vite-plugin';\r\n\r\nexport default defineConfig({\r\n  plugins: [\r\n    farmCodegenPlugin({\r\n      // Generate types before build starts\r\n      generateOnBuild: true,\r\n      // Path to FastAPI app\r\n      apiPath: '../api/src/main.py',\r\n      // Output directory for generated files\r\n      outputDir: './src/types'\r\n    })\r\n  ]\r\n});\r\n```\r\n\r\n### 3. Manual Generation\r\n\r\n**CLI Command:**\r\n```bash\r\n# Regenerate all types and API clients\r\nfarm generate types\r\n\r\n# Regenerate specific model types\r\nfarm generate types --models User,Product\r\n\r\n# Regenerate API client only\r\nfarm generate client\r\n```\r\n\r\n---\r\n\r\n## Generation Process Detail\r\n\r\n### Step 1: Schema Extraction\r\n\r\n```python\r\n# Extract OpenAPI schema from running FastAPI app\r\ndef extract_openapi_schema(api_module_path: str) -> dict:\r\n    \"\"\"\r\n    Import FastAPI app and extract OpenAPI schema\r\n    \"\"\"\r\n    # Import the FastAPI app dynamically\r\n    app = import_fastapi_app(api_module_path)\r\n    \r\n    # Extract schema\r\n    schema = get_openapi(\r\n        title=app.title,\r\n        version=app.version,\r\n        routes=app.routes\r\n    )\r\n    \r\n    return schema\r\n```\r\n\r\n### Step 2: Type Transformation\r\n\r\n```typescript\r\n// Transform OpenAPI schema types to TypeScript\r\nfunction transformSchemaToTypeScript(schema: OpenAPISchema): string {\r\n  switch (schema.type) {\r\n    case 'object':\r\n      return generateInterfaceFromObject(schema);\r\n    case 'array':\r\n      return `Array<${transformSchemaToTypeScript(schema.items)}>`;\r\n    case 'string':\r\n      return schema.enum ? generateEnumType(schema.enum) : 'string';\r\n    case 'integer':\r\n    case 'number':\r\n      return 'number';\r\n    case 'boolean':\r\n      return 'boolean';\r\n    default:\r\n      return 'unknown';\r\n  }\r\n}\r\n\r\nfunction generateInterfaceFromObject(schema: ObjectSchema): string {\r\n  const properties = Object.entries(schema.properties || {})\r\n    .map(([key, prop]) => {\r\n      const optional = !schema.required?.includes(key) ? '?' : '';\r\n      const type = transformSchemaToTypeScript(prop);\r\n      return `  ${key}${optional}: ${type};`;\r\n    })\r\n    .join('\\n');\r\n\r\n  return `{\\n${properties}\\n}`;\r\n}\r\n```\r\n\r\n### Step 3: API Client Generation\r\n\r\n```typescript\r\n// Generate API client methods from OpenAPI paths\r\nfunction generateApiClientFromPaths(paths: OpenAPIPaths): string {\r\n  const methods = Object.entries(paths).flatMap(([path, pathItem]) =>\r\n    Object.entries(pathItem).map(([method, operation]) =>\r\n      generateClientMethod(method, path, operation)\r\n    )\r\n  );\r\n\r\n  return `export const api = {\\n${methods.join(',\\n')}\\n};`;\r\n}\r\n\r\nfunction generateClientMethod(method: string, path: string, operation: OperationObject): string {\r\n  const operationId = operation.operationId;\r\n  const requestType = `${operationId}Request`;\r\n  const responseType = `${operationId}Response`;\r\n  \r\n  return `  ${operationId}: (data: ${requestType}): Promise<${responseType}> =>\r\n    client.${method}('${path}', data)`;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Error Handling & Validation\r\n\r\n### Schema Validation\r\n```python\r\ndef validate_generated_schema(schema: dict) -> bool:\r\n    \"\"\"Validate OpenAPI schema before generation\"\"\"\r\n    required_fields = ['openapi', 'info', 'paths']\r\n    \r\n    for field in required_fields:\r\n        if field not in schema:\r\n            raise ValueError(f\"Missing required field: {field}\")\r\n    \r\n    return True\r\n```\r\n\r\n### Type Generation Errors\r\n```typescript\r\nclass TypeGenerationError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public schemaPath: string,\r\n    public originalError?: Error\r\n  ) {\r\n    super(`Type generation failed at ${schemaPath}: ${message}`);\r\n  }\r\n}\r\n\r\n// Handle unsupported types gracefully\r\nfunction handleUnsupportedType(schema: any, path: string): string {\r\n  console.warn(`Unsupported schema type at ${path}:`, schema);\r\n  return 'any'; // Fallback to 'any' type\r\n}\r\n```\r\n\r\n---\r\n\r\n## Caching & Performance\r\n\r\n### Schema Caching\r\n```javascript\r\nclass SchemaCache {\r\n  constructor() {\r\n    this.cache = new Map();\r\n    this.checksums = new Map();\r\n  }\r\n\r\n  shouldRegenerate(schemaPath: string, currentChecksum: string): boolean {\r\n    const lastChecksum = this.checksums.get(schemaPath);\r\n    return lastChecksum !== currentChecksum;\r\n  }\r\n\r\n  updateCache(schemaPath: string, schema: any, checksum: string) {\r\n    this.cache.set(schemaPath, schema);\r\n    this.checksums.set(schemaPath, checksum);\r\n  }\r\n}\r\n```\r\n\r\n### Incremental Generation\r\n```typescript\r\n// Only regenerate changed types, not entire type system\r\nfunction generateIncrementalTypes(\r\n  previousSchema: OpenAPISchema,\r\n  currentSchema: OpenAPISchema\r\n): GenerationResult {\r\n  const changedModels = findChangedModels(previousSchema, currentSchema);\r\n  const changedPaths = findChangedPaths(previousSchema, currentSchema);\r\n  \r\n  return {\r\n    modelsToRegenerate: changedModels,\r\n    clientMethodsToRegenerate: changedPaths,\r\n    fullRegeneration: false\r\n  };\r\n}\r\n```\r\n\r\n---\r\n\r\n## Integration Points\r\n\r\n### Development Server Integration\r\n```python\r\n# apps/api/src/main.py\r\nfrom fastapi import FastAPI\r\nfrom farm.codegen import enable_auto_generation\r\n\r\napp = FastAPI()\r\n\r\n# Enable automatic type generation in development\r\nif os.getenv('FARM_ENV') == 'development':\r\n    enable_auto_generation(app, output_dir='../web/src/types')\r\n```\r\n\r\n### Build System Integration\r\n```javascript\r\n// package.json scripts\r\n{\r\n  \"scripts\": {\r\n    \"dev\": \"farm dev\",\r\n    \"build\": \"farm generate types && farm build\",\r\n    \"type-check\": \"farm generate types && tsc --noEmit\"\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n*Status: ✅ Completed - Ready for implementation*\r\n",
      "excerpt": "The code generation pipeline is the core \"magic\" that enables type-safe full-stack development in FARM.",
      "category": "architectural-sketches-detailed/phase1",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "farm",
        "typescript",
        "python"
      ],
      "lastModified": "2025-06-12T21:57:32.775Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase1",
        "Code_generation_pipeline"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Code Generation Pipeline Architecture",
          "id": "code-generation-pipeline-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "Generation Flow Architecture",
          "id": "generation-flow-architecture"
        },
        {
          "level": 2,
          "text": "Core Components",
          "id": "core-components"
        },
        {
          "level": 3,
          "text": "1. OpenAPI Schema Extraction",
          "id": "1-openapi-schema-extraction"
        },
        {
          "level": 1,
          "text": "tools/codegen/openapi_extractor.py",
          "id": "toolscodegenopenapi_extractorpy"
        },
        {
          "level": 3,
          "text": "2. TypeScript Type Generator",
          "id": "2-typescript-type-generator"
        },
        {
          "level": 3,
          "text": "3. API Client Generator",
          "id": "3-api-client-generator"
        },
        {
          "level": 3,
          "text": "4. React Hook Generator",
          "id": "4-react-hook-generator"
        },
        {
          "level": 2,
          "text": "Generation Triggers",
          "id": "generation-triggers"
        },
        {
          "level": 3,
          "text": "1. Development Mode (File Watching)",
          "id": "1-development-mode-file-watching"
        },
        {
          "level": 3,
          "text": "2. Build Time Generation",
          "id": "2-build-time-generation"
        },
        {
          "level": 3,
          "text": "3. Manual Generation",
          "id": "3-manual-generation"
        },
        {
          "level": 1,
          "text": "Regenerate all types and API clients",
          "id": "regenerate-all-types-and-api-clients"
        },
        {
          "level": 1,
          "text": "Regenerate specific model types",
          "id": "regenerate-specific-model-types"
        },
        {
          "level": 1,
          "text": "Regenerate API client only",
          "id": "regenerate-api-client-only"
        },
        {
          "level": 2,
          "text": "Generation Process Detail",
          "id": "generation-process-detail"
        },
        {
          "level": 3,
          "text": "Step 1: Schema Extraction",
          "id": "step-1-schema-extraction"
        },
        {
          "level": 1,
          "text": "Extract OpenAPI schema from running FastAPI app",
          "id": "extract-openapi-schema-from-running-fastapi-app"
        },
        {
          "level": 3,
          "text": "Step 2: Type Transformation",
          "id": "step-2-type-transformation"
        },
        {
          "level": 3,
          "text": "Step 3: API Client Generation",
          "id": "step-3-api-client-generation"
        },
        {
          "level": 2,
          "text": "Error Handling & Validation",
          "id": "error-handling-validation"
        },
        {
          "level": 3,
          "text": "Schema Validation",
          "id": "schema-validation"
        },
        {
          "level": 3,
          "text": "Type Generation Errors",
          "id": "type-generation-errors"
        },
        {
          "level": 2,
          "text": "Caching & Performance",
          "id": "caching-performance"
        },
        {
          "level": 3,
          "text": "Schema Caching",
          "id": "schema-caching"
        },
        {
          "level": 3,
          "text": "Incremental Generation",
          "id": "incremental-generation"
        },
        {
          "level": 2,
          "text": "Integration Points",
          "id": "integration-points"
        },
        {
          "level": 3,
          "text": "Development Server Integration",
          "id": "development-server-integration"
        },
        {
          "level": 1,
          "text": "apps/api/src/main.py",
          "id": "appsapisrcmainpy"
        },
        {
          "level": 1,
          "text": "Enable automatic type generation in development",
          "id": "enable-automatic-type-generation-in-development"
        },
        {
          "level": 3,
          "text": "Build System Integration",
          "id": "build-system-integration"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase1-configuration_system",
      "title": "Configuration_system",
      "url": "/architectural-sketches-detailed/phase1/configuration_system",
      "content": "# Configuration System Architecture\r\n\r\n## Overview\r\n\r\nFARM uses a TypeScript-first configuration system centered around `farm.config.ts`. This provides type safety, IntelliSense, and modern developer experience while supporting environment-specific overrides, plugin integration, and hot-reload capabilities.\r\n\r\n---\r\n\r\n## Configuration File Structure\r\n\r\n### Primary Configuration (`farm.config.ts`)\r\n\r\n**Type-Safe Configuration with IntelliSense:**\r\n```typescript\r\n// farm.config.ts\r\nimport { defineConfig } from '@farm/core';\r\nimport type { FarmConfig } from '@farm/types';\r\n\r\nexport default defineConfig({\r\n  // Project metadata\r\n  name: 'my-farm-app',\r\n  version: '1.0.0',\r\n  description: 'AI-powered full-stack application',\r\n\r\n  // Template and features\r\n  template: 'ai-chat',\r\n  features: ['auth', 'ai', 'realtime'],\r\n\r\n  // Database configuration\r\n  database: {\r\n    type: 'mongodb',\r\n    url: process.env.DATABASE_URL || 'mongodb://localhost:27017/farmapp',\r\n    options: {\r\n      maxPoolSize: 10,\r\n      serverSelectionTimeoutMS: 5000,\r\n    }\r\n  },\r\n\r\n  // AI/ML configuration\r\n  ai: {\r\n    providers: {\r\n      ollama: {\r\n        enabled: true,\r\n        url: 'http://localhost:11434',\r\n        models: ['llama3.1', 'codestral', 'phi3'],\r\n        defaultModel: 'llama3.1',\r\n        autoStart: true,\r\n        autoPull: ['llama3.1'],\r\n        gpu: true\r\n      },\r\n      openai: {\r\n        enabled: true,\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n        models: ['gpt-4', 'gpt-3.5-turbo'],\r\n        defaultModel: 'gpt-3.5-turbo',\r\n        rateLimiting: {\r\n          requestsPerMinute: 60,\r\n          tokensPerMinute: 40000\r\n        }\r\n      },\r\n      huggingface: {\r\n        enabled: false,\r\n        token: process.env.HUGGINGFACE_TOKEN,\r\n        models: ['microsoft/DialoGPT-medium'],\r\n        device: 'auto'\r\n      }\r\n    },\r\n    routing: {\r\n      development: 'ollama',\r\n      staging: 'openai',\r\n      production: 'openai'\r\n    },\r\n    features: {\r\n      streaming: true,\r\n      caching: true,\r\n      rateLimiting: true,\r\n      fallback: true\r\n    }\r\n  },\r\n\r\n  // Development server configuration\r\n  development: {\r\n    ports: {\r\n      frontend: 3000,\r\n      backend: 8000,\r\n      proxy: 4000,\r\n      ai: 8001\r\n    },\r\n    hotReload: {\r\n      enabled: true,\r\n      typeGeneration: true,\r\n      aiModels: true\r\n    },\r\n    ssl: false\r\n  },\r\n\r\n  // Build configuration\r\n  build: {\r\n    target: 'node18',\r\n    sourcemap: true,\r\n    minify: true,\r\n    splitting: true,\r\n    outDir: 'dist'\r\n  },\r\n\r\n  // Deployment configuration\r\n  deployment: {\r\n    platform: 'vercel',\r\n    regions: ['us-east-1'],\r\n    environment: {\r\n      NODE_ENV: 'production',\r\n      API_URL: 'https://api.myapp.com'\r\n    }\r\n  },\r\n\r\n  // Plugin configuration\r\n  plugins: [\r\n    '@farm/plugin-auth',\r\n    '@farm/plugin-analytics',\r\n    ['@farm/plugin-storage', {\r\n      provider: 's3',\r\n      bucket: 'my-app-storage'\r\n    }]\r\n  ]\r\n});\r\n```\r\n\r\n### Configuration Type Definitions\r\n\r\n**Comprehensive Type System:**\r\n```typescript\r\n// packages/types/src/config.ts\r\nexport interface FarmConfig {\r\n  // Project metadata\r\n  name: string;\r\n  version?: string;\r\n  description?: string;\r\n\r\n  // Template and features\r\n  template: TemplateType;\r\n  features: FeatureType[];\r\n\r\n  // Core system configurations\r\n  database: DatabaseConfig;\r\n  ai?: AIConfig;\r\n  development?: DevelopmentConfig;\r\n  build?: BuildConfig;\r\n  deployment?: DeploymentConfig;\r\n  \r\n  // Plugin system\r\n  plugins?: PluginConfig[];\r\n}\r\n\r\nexport type TemplateType = \r\n  | 'basic' \r\n  | 'ai-chat' \r\n  | 'ai-dashboard' \r\n  | 'ecommerce' \r\n  | 'cms' \r\n  | 'api-only';\r\n\r\nexport type FeatureType = \r\n  | 'auth' \r\n  | 'ai' \r\n  | 'realtime' \r\n  | 'payments' \r\n  | 'email' \r\n  | 'storage' \r\n  | 'search' \r\n  | 'analytics';\r\n\r\nexport interface DatabaseConfig {\r\n  type: 'mongodb' | 'postgresql' | 'mysql' | 'sqlite';\r\n  url: string;\r\n  options?: Record<string, any>;\r\n}\r\n\r\nexport interface AIConfig {\r\n  providers: {\r\n    ollama?: OllamaConfig;\r\n    openai?: OpenAIConfig;\r\n    huggingface?: HuggingFaceConfig;\r\n  };\r\n  routing: {\r\n    development?: string;\r\n    staging?: string;\r\n    production?: string;\r\n  };\r\n  features: {\r\n    streaming?: boolean;\r\n    caching?: boolean;\r\n    rateLimiting?: boolean;\r\n    fallback?: boolean;\r\n  };\r\n}\r\n\r\nexport interface OllamaConfig {\r\n  enabled: boolean;\r\n  url?: string;\r\n  models: string[];\r\n  defaultModel: string;\r\n  autoStart?: boolean;\r\n  autoPull?: string[];\r\n  gpu?: boolean;\r\n}\r\n\r\nexport interface OpenAIConfig {\r\n  enabled: boolean;\r\n  apiKey?: string;\r\n  models: string[];\r\n  defaultModel: string;\r\n  rateLimiting?: {\r\n    requestsPerMinute?: number;\r\n    tokensPerMinute?: number;\r\n  };\r\n}\r\n\r\nexport interface DevelopmentConfig {\r\n  ports: {\r\n    frontend?: number;\r\n    backend?: number;\r\n    proxy?: number;\r\n    ai?: number;\r\n  };\r\n  hotReload?: {\r\n    enabled?: boolean;\r\n    typeGeneration?: boolean;\r\n    aiModels?: boolean;\r\n  };\r\n  ssl?: boolean;\r\n}\r\n\r\nexport interface BuildConfig {\r\n  target?: string;\r\n  sourcemap?: boolean;\r\n  minify?: boolean;\r\n  splitting?: boolean;\r\n  outDir?: string;\r\n}\r\n\r\nexport interface DeploymentConfig {\r\n  platform: 'vercel' | 'netlify' | 'aws' | 'gcp' | 'docker';\r\n  regions?: string[];\r\n  environment?: Record<string, string>;\r\n}\r\n\r\nexport type PluginConfig = string | [string, Record<string, any>];\r\n```\r\n\r\n---\r\n\r\n## Configuration Loading & Validation\r\n\r\n### Configuration Loader\r\n\r\n**TypeScript Configuration Loader:**\r\n```typescript\r\n// packages/core/src/config/loader.ts\r\nimport { pathExists } from 'fs-extra';\r\nimport { register } from 'esbuild-register/dist/node';\r\nimport type { FarmConfig } from '@farm/types';\r\nimport { validateConfig } from './validator';\r\nimport { mergeConfigs } from './merger';\r\n\r\nexport class ConfigLoader {\r\n  private configCache = new Map<string, FarmConfig>();\r\n  \r\n  async loadConfig(configPath?: string): Promise<FarmConfig> {\r\n    const resolvedPath = await this.resolveConfigPath(configPath);\r\n    \r\n    // Check cache first\r\n    if (this.configCache.has(resolvedPath)) {\r\n      return this.configCache.get(resolvedPath)!;\r\n    }\r\n    \r\n    // Register TypeScript support for config files\r\n    register({\r\n      target: 'node16',\r\n      format: 'cjs'\r\n    });\r\n    \r\n    try {\r\n      // Load the configuration file\r\n      const configModule = await import(resolvedPath);\r\n      const config = configModule.default || configModule;\r\n      \r\n      // Validate configuration\r\n      const validatedConfig = await validateConfig(config);\r\n      \r\n      // Apply environment-specific overrides\r\n      const finalConfig = await this.applyEnvironmentOverrides(validatedConfig);\r\n      \r\n      // Cache the result\r\n      this.configCache.set(resolvedPath, finalConfig);\r\n      \r\n      return finalConfig;\r\n    } catch (error) {\r\n      throw new Error(`Failed to load configuration from ${resolvedPath}: ${error.message}`);\r\n    }\r\n  }\r\n  \r\n  private async resolveConfigPath(configPath?: string): Promise<string> {\r\n    if (configPath) {\r\n      return path.resolve(configPath);\r\n    }\r\n    \r\n    const candidates = [\r\n      'farm.config.ts',\r\n      'farm.config.js',\r\n      'farm.config.mjs'\r\n    ];\r\n    \r\n    for (const candidate of candidates) {\r\n      if (await pathExists(candidate)) {\r\n        return path.resolve(candidate);\r\n      }\r\n    }\r\n    \r\n    throw new Error('No configuration file found. Please create farm.config.ts');\r\n  }\r\n  \r\n  private async applyEnvironmentOverrides(config: FarmConfig): Promise<FarmConfig> {\r\n    const envConfig = await this.loadEnvironmentConfig();\r\n    return mergeConfigs(config, envConfig);\r\n  }\r\n  \r\n  private async loadEnvironmentConfig(): Promise<Partial<FarmConfig>> {\r\n    // Load environment-specific configuration\r\n    const env = process.env.NODE_ENV || 'development';\r\n    const envConfigPath = `farm.config.${env}.ts`;\r\n    \r\n    if (await pathExists(envConfigPath)) {\r\n      const envModule = await import(path.resolve(envConfigPath));\r\n      return envModule.default || envModule;\r\n    }\r\n    \r\n    return {};\r\n  }\r\n}\r\n```\r\n\r\n### Configuration Validator\r\n\r\n**Runtime Configuration Validation:**\r\n```typescript\r\n// packages/core/src/config/validator.ts\r\nimport Joi from 'joi';\r\nimport type { FarmConfig } from '@farm/types';\r\n\r\nconst configSchema = Joi.object<FarmConfig>({\r\n  name: Joi.string().required(),\r\n  version: Joi.string().optional(),\r\n  description: Joi.string().optional(),\r\n  \r\n  template: Joi.string().valid(\r\n    'basic', 'ai-chat', 'ai-dashboard', 'ecommerce', 'cms', 'api-only'\r\n  ).required(),\r\n  \r\n  features: Joi.array().items(\r\n    Joi.string().valid(\r\n      'auth', 'ai', 'realtime', 'payments', 'email', 'storage', 'search', 'analytics'\r\n    )\r\n  ).required(),\r\n  \r\n  database: Joi.object({\r\n    type: Joi.string().valid('mongodb', 'postgresql', 'mysql', 'sqlite').required(),\r\n    url: Joi.string().required(),\r\n    options: Joi.object().optional()\r\n  }).required(),\r\n  \r\n  ai: Joi.object({\r\n    providers: Joi.object({\r\n      ollama: Joi.object({\r\n        enabled: Joi.boolean().required(),\r\n        url: Joi.string().optional(),\r\n        models: Joi.array().items(Joi.string()).required(),\r\n        defaultModel: Joi.string().required(),\r\n        autoStart: Joi.boolean().optional(),\r\n        autoPull: Joi.array().items(Joi.string()).optional(),\r\n        gpu: Joi.boolean().optional()\r\n      }).optional(),\r\n      \r\n      openai: Joi.object({\r\n        enabled: Joi.boolean().required(),\r\n        apiKey: Joi.string().optional(),\r\n        models: Joi.array().items(Joi.string()).required(),\r\n        defaultModel: Joi.string().required(),\r\n        rateLimiting: Joi.object({\r\n          requestsPerMinute: Joi.number().optional(),\r\n          tokensPerMinute: Joi.number().optional()\r\n        }).optional()\r\n      }).optional()\r\n    }),\r\n    \r\n    routing: Joi.object({\r\n      development: Joi.string().optional(),\r\n      staging: Joi.string().optional(),\r\n      production: Joi.string().optional()\r\n    }),\r\n    \r\n    features: Joi.object({\r\n      streaming: Joi.boolean().optional(),\r\n      caching: Joi.boolean().optional(),\r\n      rateLimiting: Joi.boolean().optional(),\r\n      fallback: Joi.boolean().optional()\r\n    })\r\n  }).optional(),\r\n  \r\n  development: Joi.object({\r\n    ports: Joi.object({\r\n      frontend: Joi.number().optional(),\r\n      backend: Joi.number().optional(),\r\n      proxy: Joi.number().optional(),\r\n      ai: Joi.number().optional()\r\n    }),\r\n    hotReload: Joi.object({\r\n      enabled: Joi.boolean().optional(),\r\n      typeGeneration: Joi.boolean().optional(),\r\n      aiModels: Joi.boolean().optional()\r\n    }).optional(),\r\n    ssl: Joi.boolean().optional()\r\n  }).optional(),\r\n  \r\n  plugins: Joi.array().items(\r\n    Joi.alternatives().try(\r\n      Joi.string(),\r\n      Joi.array().items(Joi.string(), Joi.object())\r\n    )\r\n  ).optional()\r\n});\r\n\r\nexport async function validateConfig(config: any): Promise<FarmConfig> {\r\n  const { error, value } = configSchema.validate(config, {\r\n    allowUnknown: true,\r\n    stripUnknown: false\r\n  });\r\n  \r\n  if (error) {\r\n    throw new Error(`Configuration validation failed: ${error.message}`);\r\n  }\r\n  \r\n  return value;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Environment-Specific Configuration\r\n\r\n### Environment Override System\r\n\r\n**Environment-Specific Configurations:**\r\n```typescript\r\n// farm.config.development.ts\r\nimport { defineConfig } from '@farm/core';\r\n\r\nexport default defineConfig({\r\n  ai: {\r\n    providers: {\r\n      ollama: {\r\n        enabled: true,\r\n        autoStart: true,\r\n        autoPull: ['llama3.1']\r\n      },\r\n      openai: {\r\n        enabled: false  // Disable in development to save API costs\r\n      }\r\n    },\r\n    routing: {\r\n      development: 'ollama'\r\n    }\r\n  },\r\n  development: {\r\n    hotReload: {\r\n      enabled: true,\r\n      typeGeneration: true,\r\n      aiModels: true\r\n    },\r\n    ssl: false\r\n  }\r\n});\r\n```\r\n\r\n```typescript\r\n// farm.config.production.ts\r\nimport { defineConfig } from '@farm/core';\r\n\r\nexport default defineConfig({\r\n  ai: {\r\n    providers: {\r\n      ollama: {\r\n        enabled: false  // Disable local models in production\r\n      },\r\n      openai: {\r\n        enabled: true,\r\n        rateLimiting: {\r\n          requestsPerMinute: 60,\r\n          tokensPerMinute: 40000\r\n        }\r\n      }\r\n    },\r\n    routing: {\r\n      production: 'openai'\r\n    },\r\n    features: {\r\n      caching: true,\r\n      rateLimiting: true\r\n    }\r\n  },\r\n  build: {\r\n    minify: true,\r\n    sourcemap: false\r\n  }\r\n});\r\n```\r\n\r\n### Environment Variable Integration\r\n\r\n**Secure Environment Variable Handling:**\r\n```typescript\r\n// packages/core/src/config/env.ts\r\nimport { z } from 'zod';\r\n\r\n// Define environment variable schema\r\nconst envSchema = z.object({\r\n  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),\r\n  DATABASE_URL: z.string().url(),\r\n  OPENAI_API_KEY: z.string().optional(),\r\n  HUGGINGFACE_TOKEN: z.string().optional(),\r\n  FARM_PORT: z.coerce.number().default(4000),\r\n  FARM_AI_PROVIDER: z.string().optional(),\r\n});\r\n\r\nexport function loadEnvironmentVariables() {\r\n  try {\r\n    return envSchema.parse(process.env);\r\n  } catch (error) {\r\n    throw new Error(`Environment validation failed: ${error.message}`);\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Plugin Configuration System\r\n\r\n### Plugin Configuration Interface\r\n\r\n**Type-Safe Plugin Configuration:**\r\n```typescript\r\n// packages/types/src/plugins.ts\r\nexport interface PluginDefinition {\r\n  name: string;\r\n  version?: string;\r\n  options?: Record<string, any>;\r\n}\r\n\r\nexport interface PluginContext {\r\n  config: FarmConfig;\r\n  environment: string;\r\n  logger: Logger;\r\n}\r\n\r\nexport interface FarmPlugin {\r\n  name: string;\r\n  configSchema?: any; // Joi schema for validation\r\n  apply(context: PluginContext): void | Promise<void>;\r\n}\r\n```\r\n\r\n### Plugin Configuration Examples\r\n\r\n**Built-in Plugin Configurations:**\r\n```typescript\r\n// farm.config.ts with plugins\r\nexport default defineConfig({\r\n  plugins: [\r\n    // Simple plugin (no configuration)\r\n    '@farm/plugin-auth',\r\n    \r\n    // Plugin with configuration\r\n    ['@farm/plugin-storage', {\r\n      provider: 's3',\r\n      bucket: 'my-app-storage',\r\n      region: 'us-east-1',\r\n      credentials: {\r\n        accessKeyId: process.env.AWS_ACCESS_KEY_ID,\r\n        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY\r\n      }\r\n    }],\r\n    \r\n    // Plugin with environment-specific config\r\n    ['@farm/plugin-analytics', {\r\n      provider: process.env.NODE_ENV === 'production' ? 'mixpanel' : 'console',\r\n      apiKey: process.env.MIXPANEL_API_KEY,\r\n      debug: process.env.NODE_ENV !== 'production'\r\n    }],\r\n    \r\n    // Custom plugin\r\n    ['./plugins/custom-plugin', {\r\n      customOption: 'value'\r\n    }]\r\n  ]\r\n});\r\n```\r\n\r\n---\r\n\r\n## Configuration Hot Reload\r\n\r\n### Hot Reload System\r\n\r\n**Configuration File Watching:**\r\n```typescript\r\n// packages/core/src/config/watcher.ts\r\nimport chokidar from 'chokidar';\r\nimport { EventEmitter } from 'events';\r\nimport { ConfigLoader } from './loader';\r\n\r\nexport class ConfigWatcher extends EventEmitter {\r\n  private loader = new ConfigLoader();\r\n  private watcher?: chokidar.FSWatcher;\r\n  private currentConfig?: FarmConfig;\r\n  \r\n  async start() {\r\n    // Load initial configuration\r\n    this.currentConfig = await this.loader.loadConfig();\r\n    \r\n    // Watch configuration files\r\n    this.watcher = chokidar.watch([\r\n      'farm.config.ts',\r\n      'farm.config.*.ts',\r\n      'farm.config.js',\r\n      'farm.config.*.js'\r\n    ], {\r\n      ignoreInitial: true\r\n    });\r\n    \r\n    this.watcher.on('change', this.handleConfigChange.bind(this));\r\n    this.watcher.on('add', this.handleConfigChange.bind(this));\r\n    this.watcher.on('unlink', this.handleConfigChange.bind(this));\r\n  }\r\n  \r\n  private async handleConfigChange(path: string) {\r\n    try {\r\n      console.log(`⚙️ Configuration file changed: ${path}`);\r\n      \r\n      // Clear require cache for TypeScript modules\r\n      this.clearConfigCache();\r\n      \r\n      // Reload configuration\r\n      const newConfig = await this.loader.loadConfig();\r\n      \r\n      // Compare configurations to determine what changed\r\n      const changes = this.detectChanges(this.currentConfig!, newConfig);\r\n      \r\n      // Emit change events\r\n      this.emit('config-changed', {\r\n        path,\r\n        oldConfig: this.currentConfig,\r\n        newConfig,\r\n        changes\r\n      });\r\n      \r\n      this.currentConfig = newConfig;\r\n      \r\n      console.log('✅ Configuration reloaded successfully');\r\n    } catch (error) {\r\n      console.error('❌ Configuration reload failed:', error.message);\r\n      this.emit('config-error', { path, error });\r\n    }\r\n  }\r\n  \r\n  private clearConfigCache() {\r\n    // Clear Node.js require cache for config files\r\n    Object.keys(require.cache).forEach(key => {\r\n      if (key.includes('farm.config')) {\r\n        delete require.cache[key];\r\n      }\r\n    });\r\n  }\r\n  \r\n  private detectChanges(oldConfig: FarmConfig, newConfig: FarmConfig) {\r\n    // Deep diff to determine what specific parts changed\r\n    // This helps determine which services need restarting\r\n    return {\r\n      database: JSON.stringify(oldConfig.database) !== JSON.stringify(newConfig.database),\r\n      ai: JSON.stringify(oldConfig.ai) !== JSON.stringify(newConfig.ai),\r\n      development: JSON.stringify(oldConfig.development) !== JSON.stringify(newConfig.development),\r\n      plugins: JSON.stringify(oldConfig.plugins) !== JSON.stringify(newConfig.plugins)\r\n    };\r\n  }\r\n  \r\n  stop() {\r\n    this.watcher?.close();\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Configuration Utilities\r\n\r\n### Helper Functions\r\n\r\n**Configuration Utilities:**\r\n```typescript\r\n// packages/core/src/config/utils.ts\r\nexport function defineConfig(config: FarmConfig): FarmConfig {\r\n  return config;\r\n}\r\n\r\nexport function mergeConfigs(base: FarmConfig, override: Partial<FarmConfig>): FarmConfig {\r\n  // Deep merge with array replacement for plugins\r\n  return {\r\n    ...base,\r\n    ...override,\r\n    database: { ...base.database, ...override.database },\r\n    ai: {\r\n      ...base.ai,\r\n      ...override.ai,\r\n      providers: {\r\n        ...base.ai?.providers,\r\n        ...override.ai?.providers\r\n      }\r\n    },\r\n    development: { ...base.development, ...override.development },\r\n    build: { ...base.build, ...override.build },\r\n    deployment: { ...base.deployment, ...override.deployment },\r\n    plugins: override.plugins || base.plugins\r\n  };\r\n}\r\n\r\nexport function getConfigForEnvironment(config: FarmConfig, env: string): FarmConfig {\r\n  // Apply environment-specific routing and settings\r\n  if (config.ai?.routing) {\r\n    const aiProvider = config.ai.routing[env as keyof typeof config.ai.routing];\r\n    if (aiProvider && config.ai.providers?.[aiProvider as keyof typeof config.ai.providers]) {\r\n      // Ensure the selected provider is enabled\r\n      const providers = { ...config.ai.providers };\r\n      Object.keys(providers).forEach(key => {\r\n        if (providers[key as keyof typeof providers]) {\r\n          providers[key as keyof typeof providers]!.enabled = key === aiProvider;\r\n        }\r\n      });\r\n      \r\n      config = {\r\n        ...config,\r\n        ai: {\r\n          ...config.ai,\r\n          providers\r\n        }\r\n      };\r\n    }\r\n  }\r\n  \r\n  return config;\r\n}\r\n```\r\n\r\n### CLI Configuration Commands\r\n\r\n**Configuration Management Commands:**\r\n```bash\r\n# Validate configuration\r\nfarm config validate\r\n\r\n# Show resolved configuration\r\nfarm config show [--env production]\r\n\r\n# Initialize configuration with template\r\nfarm config init --template ai-chat\r\n\r\n# Migrate configuration to new version\r\nfarm config migrate\r\n\r\n# Generate TypeScript types for custom plugins\r\nfarm config types\r\n```\r\n\r\n---\r\n\r\n## Integration with Development Server\r\n\r\n### Configuration Integration\r\n\r\n**Development Server Configuration Usage:**\r\n```typescript\r\n// tools/dev-server/index.ts\r\nimport { ConfigLoader, ConfigWatcher } from '@farm/core/config';\r\n\r\nexport class FarmDevServer {\r\n  private configLoader = new ConfigLoader();\r\n  private configWatcher = new ConfigWatcher();\r\n  \r\n  async start() {\r\n    // Load configuration\r\n    const config = await this.configLoader.loadConfig();\r\n    \r\n    // Start configuration watcher\r\n    await this.configWatcher.start();\r\n    \r\n    // Handle configuration changes\r\n    this.configWatcher.on('config-changed', this.handleConfigChange.bind(this));\r\n    \r\n    // Start services based on configuration\r\n    await this.startServices(config);\r\n  }\r\n  \r\n  private async handleConfigChange(event: any) {\r\n    const { changes, newConfig } = event;\r\n    \r\n    // Restart services based on what changed\r\n    if (changes.database) {\r\n      await this.restartService('database');\r\n    }\r\n    \r\n    if (changes.ai) {\r\n      await this.restartService('ai');\r\n    }\r\n    \r\n    if (changes.development) {\r\n      await this.restartService('frontend');\r\n      await this.restartService('backend');\r\n    }\r\n    \r\n    // Reload plugins if plugin configuration changed\r\n    if (changes.plugins) {\r\n      await this.reloadPlugins(newConfig.plugins);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n*Status: ✅ Completed - Ready for implementation*\r\n",
      "excerpt": "FARM uses a TypeScript-first configuration system centered around.",
      "category": "architectural-sketches-detailed/phase1",
      "type": "reference",
      "tags": [
        "mongodb",
        "farm",
        "typescript",
        "database",
        "api"
      ],
      "lastModified": "2025-06-12T21:57:32.776Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase1",
        "Configuration_system"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Configuration System Architecture",
          "id": "configuration-system-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "Configuration File Structure",
          "id": "configuration-file-structure"
        },
        {
          "level": 3,
          "text": "Primary Configuration (`farm.config.ts`)",
          "id": "primary-configuration-farmconfigts"
        },
        {
          "level": 3,
          "text": "Configuration Type Definitions",
          "id": "configuration-type-definitions"
        },
        {
          "level": 2,
          "text": "Configuration Loading & Validation",
          "id": "configuration-loading-validation"
        },
        {
          "level": 3,
          "text": "Configuration Loader",
          "id": "configuration-loader"
        },
        {
          "level": 3,
          "text": "Configuration Validator",
          "id": "configuration-validator"
        },
        {
          "level": 2,
          "text": "Environment-Specific Configuration",
          "id": "environment-specific-configuration"
        },
        {
          "level": 3,
          "text": "Environment Override System",
          "id": "environment-override-system"
        },
        {
          "level": 3,
          "text": "Environment Variable Integration",
          "id": "environment-variable-integration"
        },
        {
          "level": 2,
          "text": "Plugin Configuration System",
          "id": "plugin-configuration-system"
        },
        {
          "level": 3,
          "text": "Plugin Configuration Interface",
          "id": "plugin-configuration-interface"
        },
        {
          "level": 3,
          "text": "Plugin Configuration Examples",
          "id": "plugin-configuration-examples"
        },
        {
          "level": 2,
          "text": "Configuration Hot Reload",
          "id": "configuration-hot-reload"
        },
        {
          "level": 3,
          "text": "Hot Reload System",
          "id": "hot-reload-system"
        },
        {
          "level": 2,
          "text": "Configuration Utilities",
          "id": "configuration-utilities"
        },
        {
          "level": 3,
          "text": "Helper Functions",
          "id": "helper-functions"
        },
        {
          "level": 3,
          "text": "CLI Configuration Commands",
          "id": "cli-configuration-commands"
        },
        {
          "level": 1,
          "text": "Validate configuration",
          "id": "validate-configuration"
        },
        {
          "level": 1,
          "text": "Show resolved configuration",
          "id": "show-resolved-configuration"
        },
        {
          "level": 1,
          "text": "Initialize configuration with template",
          "id": "initialize-configuration-with-template"
        },
        {
          "level": 1,
          "text": "Migrate configuration to new version",
          "id": "migrate-configuration-to-new-version"
        },
        {
          "level": 1,
          "text": "Generate TypeScript types for custom plugins",
          "id": "generate-typescript-types-for-custom-plugins"
        },
        {
          "level": 2,
          "text": "Integration with Development Server",
          "id": "integration-with-development-server"
        },
        {
          "level": 3,
          "text": "Configuration Integration",
          "id": "configuration-integration"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase1-dev_server_architecture",
      "title": "Dev_server_architecture",
      "url": "/architectural-sketches-detailed/phase1/dev_server_architecture",
      "content": "# Development Server Architecture\r\n\r\n## Overview\r\n\r\nThe FARM development server (`farm dev`) provides a unified development experience by orchestrating multiple services, file watchers, and hot reload systems. It manages the complexity of running React, FastAPI, databases, and AI services while maintaining seamless integration and developer feedback.\r\n\r\n---\r\n\r\n## High-Level Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Development Server                      │\r\n│                         (farm dev)                             │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │    Vite     │  │  FastAPI    │  │  Database   │  │ Ollama  │ │\r\n│  │   (3000)    │  │   (8000)    │  │   Service   │  │ (11434) │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │File Watcher │  │Code Gen     │  │Hot Reload   │  │ Proxy   │ │\r\n│  │   System    │  │  Pipeline   │  │Coordinator  │  │ Manager │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│               Process Manager & Health Monitor                  │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Components\r\n\r\n### 1. Process Manager\r\n\r\n**Purpose:** Spawn, monitor, and manage all development services\r\n\r\n**Implementation:**\r\n```javascript\r\n// tools/dev-server/process_manager.js\r\nimport { spawn } from 'child_process';\r\nimport { EventEmitter } from 'events';\r\n\r\nclass ProcessManager extends EventEmitter {\r\n  constructor() {\r\n    super();\r\n    this.processes = new Map();\r\n    this.healthChecks = new Map();\r\n  }\r\n\r\n  async startService(name, command, options = {}) {\r\n    const process = spawn(command.cmd, command.args, {\r\n      stdio: ['pipe', 'pipe', 'pipe'],\r\n      env: { ...process.env, ...options.env },\r\n      cwd: options.cwd\r\n    });\r\n\r\n    this.processes.set(name, {\r\n      process,\r\n      status: 'starting',\r\n      port: options.port,\r\n      healthCheckUrl: options.healthCheck,\r\n      restartCount: 0\r\n    });\r\n\r\n    this.setupProcessHandlers(name, process);\r\n    await this.waitForHealthy(name);\r\n    \r\n    return process;\r\n  }\r\n\r\n  setupProcessHandlers(name, process) {\r\n    process.stdout.on('data', (data) => {\r\n      this.emit('log', { service: name, type: 'stdout', data: data.toString() });\r\n    });\r\n\r\n    process.stderr.on('data', (data) => {\r\n      this.emit('log', { service: name, type: 'stderr', data: data.toString() });\r\n    });\r\n\r\n    process.on('exit', (code) => {\r\n      this.handleProcessExit(name, code);\r\n    });\r\n  }\r\n\r\n  async waitForHealthy(name, timeout = 30000) {\r\n    const service = this.processes.get(name);\r\n    if (!service.healthCheckUrl) return;\r\n\r\n    const startTime = Date.now();\r\n    while (Date.now() - startTime < timeout) {\r\n      try {\r\n        await fetch(service.healthCheckUrl);\r\n        service.status = 'healthy';\r\n        this.emit('service-ready', name);\r\n        return;\r\n      } catch {\r\n        await new Promise(resolve => setTimeout(resolve, 1000));\r\n      }\r\n    }\r\n    throw new Error(`Service ${name} failed to start within ${timeout}ms`);\r\n  }\r\n\r\n  async shutdown() {\r\n    const shutdownPromises = Array.from(this.processes.keys()).map(name => \r\n      this.stopService(name)\r\n    );\r\n    await Promise.all(shutdownPromises);\r\n  }\r\n}\r\n```\r\n\r\n### 2. Service Configurations\r\n\r\n**Service Definitions:**\r\n```javascript\r\n// tools/dev-server/service_config.js\r\nexport const SERVICES = {\r\n  database: {\r\n    name: 'MongoDB',\r\n    command: {\r\n      cmd: 'docker',\r\n      args: ['compose', 'up', 'mongodb', '-d']\r\n    },\r\n    healthCheck: 'http://localhost:27017',\r\n    required: true,\r\n    order: 1\r\n  },\r\n\r\n  ollama: {\r\n    name: 'Ollama AI',\r\n    command: {\r\n      cmd: 'docker',\r\n      args: ['run', '-d', '--name', 'farm-ollama', '-p', '11434:11434', \r\n             '-v', 'ollama:/root/.ollama', 'ollama/ollama']\r\n    },\r\n    healthCheck: 'http://localhost:11434/api/tags',\r\n    required: false, // Only if AI features enabled\r\n    order: 1.5, // Start after database, before backend\r\n    autoStart: true,\r\n    postStart: async (config) => {\r\n      // Auto-pull configured models\r\n      const autoPull = config.ai?.providers?.ollama?.autoPull || [];\r\n      \r\n      for (const model of autoPull) {\r\n        console.log(`📥 Auto-pulling Ollama model: ${model}`);\r\n        await pullOllamaModel(model);\r\n      }\r\n    }\r\n  },\r\n  \r\n  backend: {\r\n    name: 'FastAPI',\r\n    command: {\r\n      cmd: 'uvicorn',\r\n      args: ['src.main:app', '--reload', '--host', '0.0.0.0', '--port', '8000']\r\n    },\r\n    cwd: 'apps/api',\r\n    healthCheck: 'http://localhost:8000/health',\r\n    env: {\r\n      FARM_ENV: 'development',\r\n      PYTHONPATH: '.',\r\n      OLLAMA_URL: 'http://localhost:11434'\r\n    },\r\n    required: true,\r\n    order: 2\r\n  },\r\n\r\n  frontend: {\r\n    name: 'Vite',\r\n    command: {\r\n      cmd: 'npm',\r\n      args: ['run', 'dev']\r\n    },\r\n    cwd: 'apps/web',\r\n    healthCheck: 'http://localhost:3000',\r\n    required: true,\r\n    order: 3\r\n  }\r\n};\r\n```\r\n\r\n### 3. Proxy Manager\r\n\r\n**Purpose:** Route frontend requests to appropriate backend services\r\n\r\n**Configuration:**\r\n```javascript\r\n// tools/dev-server/proxy_manager.js\r\nimport httpProxy from 'http-proxy-middleware';\r\nimport express from 'express';\r\n\r\nclass ProxyManager {\r\n  constructor() {\r\n    this.app = express();\r\n    this.setupProxyRules();\r\n  }\r\n\r\n  setupProxyRules() {\r\n    // API requests to FastAPI\r\n    this.app.use('/api', httpProxy({\r\n      target: 'http://localhost:8000',\r\n      changeOrigin: true,\r\n      pathRewrite: {\r\n        '^/api': '/api'\r\n      },\r\n      onError: this.handleProxyError.bind(this)\r\n    }));\r\n\r\n    // Ollama API requests (direct proxy for AI operations)\r\n    this.app.use('/ollama', httpProxy({\r\n      target: 'http://localhost:11434',\r\n      changeOrigin: true,\r\n      pathRewrite: {\r\n        '^/ollama': '/api'\r\n      },\r\n      onError: this.handleProxyError.bind(this)\r\n    }));\r\n\r\n    // WebSocket proxying for real-time features\r\n    this.app.use('/ws', httpProxy({\r\n      target: 'http://localhost:8000',\r\n      ws: true,\r\n      changeOrigin: true\r\n    }));\r\n\r\n    // Everything else to Vite\r\n    this.app.use('/', httpProxy({\r\n      target: 'http://localhost:3000',\r\n      changeOrigin: true,\r\n      ws: true // Support Vite HMR WebSocket\r\n    }));\r\n  }\r\n\r\n  handleProxyError(err, req, res) {\r\n    console.error(`Proxy error for ${req.url}:`, err.message);\r\n    res.status(502).json({\r\n      error: 'Service temporarily unavailable',\r\n      message: 'Backend service is starting up...'\r\n    });\r\n  }\r\n\r\n  start(port = 4000) {\r\n    return this.app.listen(port, () => {\r\n      console.log(`🌐 FARM proxy server running on http://localhost:${port}`);\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n### 4. File Watcher Integration\r\n\r\n**Purpose:** Coordinate file watching with code generation and hot reload\r\n\r\n**Implementation:**\r\n```javascript\r\n// tools/dev-server/file_watcher.js\r\nimport chokidar from 'chokidar';\r\nimport { CodeGenerator } from '../codegen/generator.js';\r\n\r\nclass DevFileWatcher {\r\n  constructor(processManager) {\r\n    this.processManager = processManager;\r\n    this.codeGenerator = new CodeGenerator();\r\n    this.watchers = new Map();\r\n  }\r\n\r\n  startWatching() {\r\n    this.setupPythonWatcher();\r\n    this.setupConfigWatcher();\r\n    this.setupMLModelWatcher();\r\n  }\r\n\r\n  setupPythonWatcher() {\r\n    const pythonWatcher = chokidar.watch([\r\n      'apps/api/src/models/**/*.py',\r\n      'apps/api/src/routes/**/*.py'\r\n    ], {\r\n      ignoreInitial: true,\r\n      persistent: true\r\n    });\r\n\r\n    pythonWatcher.on('change', async (path) => {\r\n      console.log(`🔄 Python file changed: ${path}`);\r\n      \r\n      try {\r\n        // Regenerate types\r\n        await this.codeGenerator.regenerateTypes();\r\n        console.log('✅ TypeScript types regenerated');\r\n        \r\n        // Trigger frontend HMR update\r\n        this.triggerFrontendUpdate();\r\n      } catch (error) {\r\n        console.error('❌ Type generation failed:', error);\r\n        this.processManager.emit('generation-error', { path, error });\r\n      }\r\n    });\r\n\r\n    this.watchers.set('python', pythonWatcher);\r\n  }\r\n\r\n  setupConfigWatcher() {\r\n    const configWatcher = chokidar.watch([\r\n      'farm.config.js',\r\n      'apps/api/src/core/config.py',\r\n      'apps/web/vite.config.ts'\r\n    ], {\r\n      ignoreInitial: true\r\n    });\r\n\r\n    configWatcher.on('change', async (path) => {\r\n      console.log(`⚙️ Config file changed: ${path}`);\r\n      \r\n      // Restart affected services\r\n      if (path.includes('farm.config.js')) {\r\n        await this.processManager.restartAllServices();\r\n      } else if (path.includes('vite.config.ts')) {\r\n        await this.processManager.restartService('frontend');\r\n      } else if (path.includes('config.py')) {\r\n        await this.processManager.restartService('backend');\r\n      }\r\n    });\r\n\r\n    this.watchers.set('config', configWatcher);\r\n  }\r\n\r\n  setupMLModelWatcher() {\r\n    const modelWatcher = chokidar.watch([\r\n      'apps/api/models/**/*',\r\n      'apps/api/src/ai/**/*.py',\r\n      'farm.config.ts' // Watch for Ollama model configuration changes\r\n    ], {\r\n      ignoreInitial: true\r\n    });\r\n\r\n    modelWatcher.on('change', async (path) => {\r\n      console.log(`🤖 AI model/service changed: ${path}`);\r\n      \r\n      if (path.includes('farm.config.ts')) {\r\n        // Handle Ollama model configuration changes\r\n        await this.handleOllamaConfigChange();\r\n      } else {\r\n        // Hot reload AI models without restarting service\r\n        try {\r\n          await this.hotReloadAIModels();\r\n        } catch (error) {\r\n          // Fallback to service restart\r\n          await this.processManager.restartService('backend');\r\n        }\r\n      }\r\n    });\r\n\r\n    this.watchers.set('models', modelWatcher);\r\n  }\r\n\r\n  triggerFrontendUpdate() {\r\n    // Send HMR update signal to Vite\r\n    // Vite will automatically pick up new type files\r\n    this.processManager.emit('frontend-update', { \r\n      type: 'types-updated',\r\n      timestamp: Date.now()\r\n    });\r\n  }\r\n\r\n  async hotReloadAIModels() {\r\n    // Send reload signal to AI service through FastAPI\r\n    await fetch('http://localhost:8000/api/ai/reload-models', { method: 'POST' });\r\n  }\r\n\r\n  async handleOllamaConfigChange() {\r\n    console.log('⚙️ Ollama configuration changed, checking for new models...');\r\n    \r\n    try {\r\n      // Reload config and check for new models to pull\r\n      const config = await this.loadFarmConfig();\r\n      const autoPull = config.ai?.providers?.ollama?.autoPull || [];\r\n      \r\n      // Check which models are missing and pull them\r\n      for (const model of autoPull) {\r\n        const hasModel = await this.checkOllamaModel(model);\r\n        if (!hasModel) {\r\n          console.log(`📥 Pulling new Ollama model: ${model}`);\r\n          await this.pullOllamaModel(model);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Failed to handle Ollama config change:', error);\r\n    }\r\n  }\r\n\r\n  async checkOllamaModel(modelName) {\r\n    try {\r\n      const response = await fetch('http://localhost:11434/api/tags');\r\n      const data = await response.json();\r\n      const models = data.models?.map(m => m.name) || [];\r\n      return models.includes(modelName);\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async pullOllamaModel(modelName) {\r\n    try {\r\n      const response = await fetch('http://localhost:11434/api/pull', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ name: modelName })\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`Failed to pull model ${modelName}`);\r\n      }\r\n      \r\n      console.log(`✅ Successfully pulled Ollama model: ${modelName}`);\r\n    } catch (error) {\r\n      console.error(`❌ Failed to pull Ollama model ${modelName}:`, error);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 5. Hot Reload Coordinator\r\n\r\n**Purpose:** Coordinate hot reload across different systems\r\n\r\n**Implementation:**\r\n```javascript\r\n// tools/dev-server/hot_reload.js\r\nclass HotReloadCoordinator {\r\n  constructor(processManager) {\r\n    this.processManager = processManager;\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  setupEventHandlers() {\r\n    // Listen for type generation events\r\n    this.processManager.on('types-regenerated', this.handleTypesUpdate.bind(this));\r\n    \r\n    // Listen for model changes\r\n    this.processManager.on('models-updated', this.handleModelsUpdate.bind(this));\r\n    \r\n    // Listen for config changes\r\n    this.processManager.on('config-changed', this.handleConfigUpdate.bind(this));\r\n  }\r\n\r\n  async handleTypesUpdate(event) {\r\n    // Notify frontend that new types are available\r\n    await this.notifyViteHMR({\r\n      type: 'types-updated',\r\n      files: event.generatedFiles\r\n    });\r\n    \r\n    // Update IDE/TypeScript service\r\n    this.triggerTypeScriptReload();\r\n  }\r\n\r\n  async handleModelsUpdate(event) {\r\n    // Hot reload AI models without service restart\r\n    try {\r\n      await this.hotSwapAIModels(event.modelPath);\r\n      console.log('🔥 AI models hot-reloaded successfully');\r\n    } catch (error) {\r\n      console.warn('⚠️ Hot reload failed, restarting AI service...');\r\n      await this.processManager.restartService('ai');\r\n    }\r\n  }\r\n\r\n  async notifyViteHMR(update) {\r\n    // Send HMR update to Vite dev server\r\n    const viteProcess = this.processManager.getProcess('frontend');\r\n    if (viteProcess && viteProcess.status === 'healthy') {\r\n      // Vite automatically watches the types directory\r\n      // Just ensure the files are written and Vite will pick them up\r\n      console.log('📡 Frontend will auto-reload with new types');\r\n    }\r\n  }\r\n\r\n  triggerTypeScriptReload() {\r\n    // Trigger TypeScript service reload for better IDE experience\r\n    // This helps VS Code and other editors pick up new types immediately\r\n    console.log('🔄 TypeScript service reloading...');\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Development Server CLI Integration\r\n\r\n### Command Implementation\r\n\r\n```javascript\r\n// tools/dev-server/index.js\r\nimport { ProcessManager } from './process_manager.js';\r\nimport { ProxyManager } from './proxy_manager.js';\r\nimport { DevFileWatcher } from './file_watcher.js';\r\nimport { HotReloadCoordinator } from './hot_reload.js';\r\n\r\nexport class FarmDevServer {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      port: 4000,\r\n      frontendOnly: false,\r\n      backendOnly: false,\r\n      verbose: false,\r\n      ...options\r\n    };\r\n    \r\n    this.processManager = new ProcessManager();\r\n    this.proxyManager = new ProxyManager();\r\n    this.fileWatcher = new DevFileWatcher(this.processManager);\r\n    this.hotReload = new HotReloadCoordinator(this.processManager);\r\n  }\r\n\r\n  async start() {\r\n    console.log('🌾 Starting FARM development server...\\n');\r\n    \r\n    try {\r\n      // Load project configuration\r\n      const config = await this.loadFarmConfig();\r\n      \r\n      // Start services in order\r\n      await this.startServices(config);\r\n      \r\n      // Start file watching\r\n      this.fileWatcher.startWatching();\r\n      \r\n      // Start proxy server\r\n      this.proxyManager.start(this.options.port);\r\n      \r\n      // Setup graceful shutdown\r\n      this.setupShutdownHandlers();\r\n      \r\n      this.printStartupSummary();\r\n    } catch (error) {\r\n      console.error('❌ Failed to start development server:', error);\r\n      await this.shutdown();\r\n      process.exit(1);\r\n    }\r\n  }\r\n\r\n  async startServices(config) {\r\n    const servicesToStart = this.determineServicesToStart(config);\r\n    \r\n    for (const serviceConfig of servicesToStart) {\r\n      console.log(`🚀 Starting ${serviceConfig.name}...`);\r\n      await this.processManager.startService(\r\n        serviceConfig.key,\r\n        serviceConfig.command,\r\n        serviceConfig.options\r\n      );\r\n      console.log(`✅ ${serviceConfig.name} ready\\n`);\r\n    }\r\n  }\r\n\r\n  determineServicesToStart(config) {\r\n    let services = [];\r\n    \r\n    if (this.options.frontendOnly) {\r\n      services = ['frontend'];\r\n    } else if (this.options.backendOnly) {\r\n      services = ['database', 'backend'];\r\n      if (config.features?.includes('ai') && config.ai?.providers?.ollama?.enabled) {\r\n        services.splice(1, 0, 'ollama'); // Insert Ollama before backend\r\n      }\r\n    } else {\r\n      services = ['database', 'backend', 'frontend'];\r\n      if (config.features?.includes('ai') && config.ai?.providers?.ollama?.enabled) {\r\n        services.splice(1, 0, 'ollama'); // Insert Ollama after database, before backend\r\n      }\r\n    }\r\n    \r\n    return services.map(key => ({\r\n      key,\r\n      ...SERVICES[key]\r\n    })).sort((a, b) => a.order - b.order);\r\n  }\r\n\r\n  printStartupSummary() {\r\n    console.log('\\n🎉 FARM development server is ready!\\n');\r\n    console.log('📱 Frontend:  http://localhost:3000');\r\n    console.log('🔗 Proxy:     http://localhost:4000');\r\n    console.log('⚡ Backend:   http://localhost:8000');\r\n    console.log('📚 API Docs:  http://localhost:8000/docs');\r\n    \r\n    if (this.processManager.hasService('ollama')) {\r\n      console.log('🤖 Ollama AI: http://localhost:11434');\r\n    }\r\n    \r\n    console.log('\\n🔍 Watching for changes...\\n');\r\n  }\r\n\r\n  setupShutdownHandlers() {\r\n    const shutdown = async () => {\r\n      console.log('\\n🛑 Shutting down FARM development server...');\r\n      await this.shutdown();\r\n      process.exit(0);\r\n    };\r\n\r\n    process.on('SIGINT', shutdown);\r\n    process.on('SIGTERM', shutdown);\r\n  }\r\n\r\n  async shutdown() {\r\n    try {\r\n      await this.processManager.shutdown();\r\n      this.fileWatcher.stopAll();\r\n      console.log('✅ All services stopped');\r\n    } catch (error) {\r\n      console.error('❌ Error during shutdown:', error);\r\n    }\r\n  }\r\n}\r\n\r\n// CLI command handler\r\nexport async function devCommand(options) {\r\n  const server = new FarmDevServer(options);\r\n  await server.start();\r\n}\r\n```\r\n\r\n---\r\n\r\n## Error Handling & Recovery\r\n\r\n### Service Health Monitoring\r\n\r\n```javascript\r\nclass HealthMonitor {\r\n  constructor(processManager) {\r\n    this.processManager = processManager;\r\n    this.healthCheckInterval = 30000; // 30 seconds\r\n  }\r\n\r\n  startMonitoring() {\r\n    setInterval(async () => {\r\n      for (const [name, service] of this.processManager.processes) {\r\n        if (service.healthCheckUrl) {\r\n          const isHealthy = await this.checkServiceHealth(service.healthCheckUrl);\r\n          \r\n          if (!isHealthy && service.status === 'healthy') {\r\n            console.warn(`⚠️ Service ${name} appears unhealthy`);\r\n            service.status = 'unhealthy';\r\n            \r\n            // Attempt restart if configured\r\n            if (service.autoRestart && service.restartCount < 3) {\r\n              await this.processManager.restartService(name);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }, this.healthCheckInterval);\r\n  }\r\n\r\n  async checkServiceHealth(url) {\r\n    try {\r\n      const response = await fetch(url, { \r\n        timeout: 5000,\r\n        signal: AbortSignal.timeout(5000)\r\n      });\r\n      return response.ok;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Error Recovery Strategies\r\n\r\n```javascript\r\nclass ErrorRecovery {\r\n  constructor(processManager) {\r\n    this.processManager = processManager;\r\n    this.setupErrorHandlers();\r\n  }\r\n\r\n  setupErrorHandlers() {\r\n    this.processManager.on('process-exit', this.handleProcessExit.bind(this));\r\n    this.processManager.on('generation-error', this.handleGenerationError.bind(this));\r\n    this.processManager.on('startup-error', this.handleStartupError.bind(this));\r\n  }\r\n\r\n  async handleProcessExit(name, code) {\r\n    const service = this.processManager.getService(name);\r\n    \r\n    if (code !== 0 && service.required) {\r\n      console.error(`💥 Critical service ${name} crashed with code ${code}`);\r\n      \r\n      if (service.restartCount < 3) {\r\n        console.log(`🔄 Attempting to restart ${name}...`);\r\n        await this.processManager.restartService(name);\r\n      } else {\r\n        console.error(`❌ Service ${name} failed too many times, giving up`);\r\n        process.exit(1);\r\n      }\r\n    } else if (code !== 0 && name === 'ollama') {\r\n      console.warn(`⚠️ Ollama service crashed but continuing without local AI`);\r\n      console.log(`💡 You can still develop using OpenAI or other configured providers`);\r\n    }\r\n  }\r\n\r\n  handleGenerationError(error) {\r\n    console.error('⚠️ Code generation failed:', error.error.message);\r\n    console.log('📝 Fix the error in your Python code and save to retry');\r\n    \r\n    // Don't crash - just wait for next file change\r\n  }\r\n\r\n  handleStartupError(name, error) {\r\n    console.error(`❌ Failed to start ${name}:`, error.message);\r\n    \r\n    // Provide helpful error messages\r\n    if (error.message.includes('EADDRINUSE')) {\r\n      console.log(`💡 Port already in use. Try: farm dev --port <different-port>`);\r\n    } else if (error.message.includes('ENOENT')) {\r\n      console.log(`💡 Command not found. Make sure dependencies are installed.`);\r\n    } else if (name === 'ollama' && error.message.includes('docker')) {\r\n      console.log(`💡 Docker not running or Ollama image not available.`);\r\n      console.log(`   Try: docker pull ollama/ollama`);\r\n    } else if (name === 'ollama') {\r\n      console.log(`💡 Ollama failed to start. You can still develop without local AI.`);\r\n      console.log(`   The framework will fallback to OpenAI if configured.`);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Configuration Integration\r\n\r\n### Farm Config Loading\r\n\r\n```javascript\r\n// Load and validate farm.config.ts\r\nasync function loadFarmConfig() {\r\n  try {\r\n    const config = await import(path.resolve('farm.config.ts'));\r\n    return config.default || config;\r\n  } catch (error) {\r\n    console.warn('⚠️ No farm.config.ts found, using defaults');\r\n    return getDefaultConfig();\r\n  }\r\n}\r\n\r\nfunction getDefaultConfig() {\r\n  return {\r\n    database: { type: 'mongodb' },\r\n    features: [],\r\n    ai: { \r\n      providers: {\r\n        ollama: {\r\n          enabled: false,\r\n          url: 'http://localhost:11434',\r\n          models: ['llama3.1'],\r\n          defaultModel: 'llama3.1'\r\n        }\r\n      }\r\n    },\r\n    development: {\r\n      ports: {\r\n        frontend: 3000,\r\n        backend: 8000,\r\n        proxy: 4000,\r\n        ollama: 11434\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nasync function pullOllamaModel(modelName) {\r\n  try {\r\n    console.log(`📥 Pulling Ollama model: ${modelName}...`);\r\n    \r\n    const response = await fetch('http://localhost:11434/api/pull', {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ name: modelName })\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\r\n    }\r\n    \r\n    // Stream the pull progress\r\n    const reader = response.body?.getReader();\r\n    if (reader) {\r\n      while (true) {\r\n        const { done, value } = await reader.read();\r\n        if (done) break;\r\n        \r\n        const chunk = new TextDecoder().decode(value);\r\n        const lines = chunk.split('\\n').filter(line => line.trim());\r\n        \r\n        for (const line of lines) {\r\n          try {\r\n            const data = JSON.parse(line);\r\n            if (data.status) {\r\n              console.log(`📦 ${data.status}`);\r\n            }\r\n          } catch (e) {\r\n            // Ignore malformed JSON lines\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log(`✅ Successfully pulled Ollama model: ${modelName}`);\r\n  } catch (error) {\r\n    console.error(`❌ Failed to pull Ollama model ${modelName}:`, error.message);\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n*Status: ✅ Completed - Ready for implementation*\r\n",
      "excerpt": "The FARM development server () provides a unified development experience by orchestrating multiple services, file watchers, and hot reload systems.",
      "category": "architectural-sketches-detailed/phase1",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.777Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase1",
        "Dev_server_architecture"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Development Server Architecture",
          "id": "development-server-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "High-Level Architecture",
          "id": "high-level-architecture"
        },
        {
          "level": 2,
          "text": "Core Components",
          "id": "core-components"
        },
        {
          "level": 3,
          "text": "1. Process Manager",
          "id": "1-process-manager"
        },
        {
          "level": 3,
          "text": "2. Service Configurations",
          "id": "2-service-configurations"
        },
        {
          "level": 3,
          "text": "3. Proxy Manager",
          "id": "3-proxy-manager"
        },
        {
          "level": 3,
          "text": "4. File Watcher Integration",
          "id": "4-file-watcher-integration"
        },
        {
          "level": 3,
          "text": "5. Hot Reload Coordinator",
          "id": "5-hot-reload-coordinator"
        },
        {
          "level": 2,
          "text": "Development Server CLI Integration",
          "id": "development-server-cli-integration"
        },
        {
          "level": 3,
          "text": "Command Implementation",
          "id": "command-implementation"
        },
        {
          "level": 2,
          "text": "Error Handling & Recovery",
          "id": "error-handling-recovery"
        },
        {
          "level": 3,
          "text": "Service Health Monitoring",
          "id": "service-health-monitoring"
        },
        {
          "level": 3,
          "text": "Error Recovery Strategies",
          "id": "error-recovery-strategies"
        },
        {
          "level": 2,
          "text": "Configuration Integration",
          "id": "configuration-integration"
        },
        {
          "level": 3,
          "text": "Farm Config Loading",
          "id": "farm-config-loading"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase1-template_project_structures",
      "title": "Template_project_structures",
      "url": "/architectural-sketches-detailed/phase1/template_project_structures",
      "content": "# Template Project Structures\r\n\r\n## Base Project Structure\r\n\r\nAll templates share this foundational structure, with template-specific additions:\r\n\r\n```\r\nmy-farm-app/\r\n├── apps/\r\n│   ├── web/                      # React frontend (omitted in api-only)\r\n│   └── api/                      # FastAPI backend\r\n├── packages/                     # Shared packages (when applicable)\r\n├── tools/                        # Build tools and scripts\r\n├── docs/                         # Auto-generated documentation\r\n├── farm.config.ts                # Framework configuration\r\n├── docker-compose.yml            # Local development environment\r\n├── package.json                  # Workspace root\r\n├── .gitignore                    # Git ignore patterns\r\n└── README.md                     # Project documentation\r\n```\r\n\r\n---\r\n\r\n## Template Specifications\r\n\r\n### 1. Basic Template (`--template basic`)\r\n\r\n**Description:** Simple React + FastAPI + MongoDB setup for general web applications.\r\n\r\n**Project Structure:**\r\n```\r\nmy-farm-app/\r\n├── apps/\r\n│   ├── web/\r\n│   │   ├── src/\r\n│   │   │   ├── components/\r\n│   │   │   │   ├── ui/           # Basic UI components\r\n│   │   │   │   └── layout/       # Layout components\r\n│   │   │   ├── pages/\r\n│   │   │   │   ├── Home.tsx\r\n│   │   │   │   └── About.tsx\r\n│   │   │   ├── hooks/            # Custom React hooks\r\n│   │   │   ├── stores/           # Zustand stores\r\n│   │   │   ├── services/         # API client (auto-generated)\r\n│   │   │   ├── types/            # TypeScript types (auto-generated)\r\n│   │   │   ├── utils/            # Utility functions\r\n│   │   │   ├── App.tsx\r\n│   │   │   └── main.tsx\r\n│   │   ├── public/\r\n│   │   │   ├── favicon.ico\r\n│   │   │   └── index.html\r\n│   │   ├── package.json\r\n│   │   ├── vite.config.ts\r\n│   │   ├── tailwind.config.js\r\n│   │   └── tsconfig.json\r\n│   └── api/\r\n│       ├── src/\r\n│       │   ├── routes/\r\n│       │   │   ├── __init__.py\r\n│       │   │   ├── health.py     # Health check endpoints\r\n│       │   │   └── users.py      # Basic user endpoints\r\n│       │   ├── models/\r\n│       │   │   ├── __init__.py\r\n│       │   │   ├── base.py       # Base model classes\r\n│       │   │   └── user.py       # User model\r\n│       │   ├── database/\r\n│       │   │   ├── __init__.py\r\n│       │   │   └── connection.py # Database connection\r\n│       │   ├── core/\r\n│       │   │   ├── __init__.py\r\n│       │   │   ├── config.py     # Configuration\r\n│       │   │   └── security.py   # Security utilities\r\n│       │   └── main.py           # FastAPI app entry point\r\n│       ├── tests/\r\n│       │   ├── __init__.py\r\n│       │   └── test_health.py\r\n│       ├── requirements.txt\r\n│       └── pyproject.toml\r\n└── farm.config.ts\r\n```\r\n\r\n**Key Dependencies:**\r\n- **Frontend:** React, TypeScript, Vite, Tailwind CSS, Zustand, TanStack Query\r\n- **Backend:** FastAPI, Pydantic, Motor (MongoDB), Uvicorn, Pytest\r\n\r\n---\r\n\r\n### 2. AI Chat Template (`--template ai-chat`)\r\n\r\n**Description:** Chat application with streaming AI responses and conversation management.\r\n\r\n**Additional Structure:**\r\n```\r\n├── apps/\r\n│   ├── web/\r\n│   │   └── src/\r\n│   │       ├── components/\r\n│   │       │   ├── chat/\r\n│   │       │   │   ├── ChatWindow.tsx\r\n│   │       │   │   ├── MessageList.tsx\r\n│   │       │   │   ├── MessageInput.tsx\r\n│   │       │   │   └── TypingIndicator.tsx\r\n│   │       │   └── ai/\r\n│   │       │       ├── ModelSelector.tsx\r\n│   │       │       └── AISettings.tsx\r\n│   │       ├── hooks/\r\n│   │       │   ├── useStreamingChat.ts\r\n│   │       │   ├── useWebSocket.ts\r\n│   │       │   └── useAIModels.ts\r\n│   │       └── stores/\r\n│   │           ├── chatStore.ts\r\n│   │           └── aiStore.ts\r\n│   └── api/\r\n│       ├── src/\r\n│       │   ├── routes/\r\n│       │   │   ├── chat.py        # Chat endpoints\r\n│       │   │   ├── ai.py          # AI model endpoints\r\n│       │   │   └── websocket.py   # WebSocket handlers\r\n│       │   ├── models/\r\n│       │   │   ├── conversation.py\r\n│       │   │   ├── message.py\r\n│       │   │   └── ai_model.py\r\n│       │   ├── ai/\r\n│       │   │   ├── __init__.py\r\n│       │   │   ├── model_manager.py\r\n│       │   │   ├── inference.py\r\n│       │   │   ├── streaming.py\r\n│       │   │   └── ollama_client.py\r\n│       │   └── websocket/\r\n│       │       ├── __init__.py\r\n│       │       ├── manager.py\r\n│       │       └── handlers.py\r\n│       ├── models/               # AI model storage (Ollama models cached here)\r\n│       │   ├── .gitkeep\r\n│       │   └── ollama/           # Ollama model cache directory\r\n│       │       └── .gitkeep\r\n│       └── docker/               # Docker configurations\r\n│           ├── ollama.dockerfile\r\n│           └── docker-compose.ai.yml\r\n```\r\n\r\n**Additional Dependencies:**\r\n- **Frontend:** WebSocket client, markdown rendering\r\n- **Backend:** WebSocket support, Ollama client, AI libraries (transformers, torch), streaming utilities\r\n\r\n---\r\n\r\n### 3. AI Dashboard Template (`--template ai-dashboard`)\r\n\r\n**Description:** Data dashboard with ML insights, charts, and analytics.\r\n\r\n**Additional Structure:**\r\n```\r\n├── apps/\r\n│   ├── web/\r\n│   │   └── src/\r\n│   │       ├── components/\r\n│   │       │   ├── dashboard/\r\n│   │       │   │   ├── DashboardGrid.tsx\r\n│   │       │   │   ├── MetricCard.tsx\r\n│   │       │   │   └── InsightPanel.tsx\r\n│   │       │   ├── charts/\r\n│   │       │   │   ├── LineChart.tsx\r\n│   │       │   │   ├── BarChart.tsx\r\n│   │       │   │   ├── PieChart.tsx\r\n│   │       │   │   └── HeatMap.tsx\r\n│   │       │   └── ml/\r\n│   │       │       ├── ModelMetrics.tsx\r\n│   │       │       ├── PredictionViewer.tsx\r\n│   │       │       └── DataExplorer.tsx\r\n│   │       └── hooks/\r\n│   │           ├── useAnalytics.ts\r\n│   │           ├── useChartData.ts\r\n│   │           └── useMLModels.ts\r\n│   └── api/\r\n│       ├── src/\r\n│       │   ├── routes/\r\n│       │   │   ├── analytics.py\r\n│       │   │   ├── ml_models.py\r\n│       │   │   └── data.py\r\n│       │   ├── models/\r\n│       │   │   ├── dataset.py\r\n│       │   │   ├── metric.py\r\n│       │   │   └── prediction.py\r\n│       │   ├── ml/\r\n│       │   │   ├── analytics.py\r\n│       │   │   ├── preprocessing.py\r\n│       │   │   ├── visualization.py\r\n│       │   │   └── ollama_integration.py\r\n│       │   └── data/\r\n│       │       ├── __init__.py\r\n│       │       ├── loaders.py\r\n│       │       └── processors.py\r\n│       ├── datasets/             # Sample datasets\r\n│       │   └── .gitkeep\r\n│       └── models/               # AI model storage (Ollama models)\r\n│           ├── .gitkeep\r\n│           └── ollama/\r\n│               └── .gitkeep\r\n```\r\n\r\n**Additional Dependencies:**\r\n- **Frontend:** Recharts, D3.js, data visualization libraries\r\n- **Backend:** Pandas, NumPy, Scikit-learn, Plotly, Ollama client\r\n\r\n---\r\n\r\n### 4. E-commerce Template (`--template ecommerce`)\r\n\r\n**Description:** E-commerce platform with products, cart, and payment processing.\r\n\r\n**Additional Structure:**\r\n```\r\n├── apps/\r\n│   ├── web/\r\n│   │   └── src/\r\n│   │       ├── components/\r\n│   │       │   ├── products/\r\n│   │       │   │   ├── ProductGrid.tsx\r\n│   │       │   │   ├── ProductCard.tsx\r\n│   │       │   │   └── ProductDetail.tsx\r\n│   │       │   ├── cart/\r\n│   │       │   │   ├── CartSidebar.tsx\r\n│   │       │   │   ├── CartItem.tsx\r\n│   │       │   │   └── CartSummary.tsx\r\n│   │       │   ├── checkout/\r\n│   │       │   │   ├── CheckoutForm.tsx\r\n│   │       │   │   ├── PaymentForm.tsx\r\n│   │       │   │   └── OrderSummary.tsx\r\n│   │       │   └── admin/\r\n│   │       │       ├── ProductManager.tsx\r\n│   │       │       └── OrderManager.tsx\r\n│   │       └── stores/\r\n│   │           ├── productStore.ts\r\n│   │           ├── cartStore.ts\r\n│   │           └── orderStore.ts\r\n│   └── api/\r\n│       ├── src/\r\n│       │   ├── routes/\r\n│       │   │   ├── products.py\r\n│       │   │   ├── cart.py\r\n│       │   │   ├── orders.py\r\n│       │   │   ├── payments.py\r\n│       │   │   └── admin.py\r\n│       │   ├── models/\r\n│       │   │   ├── product.py\r\n│       │   │   ├── cart.py\r\n│       │   │   ├── order.py\r\n│       │   │   └── payment.py\r\n│       │   ├── payments/\r\n│       │   │   ├── __init__.py\r\n│       │   │   ├── stripe_client.py\r\n│       │   │   └── paypal_client.py\r\n│       │   └── inventory/\r\n│       │       ├── __init__.py\r\n│       │       └── management.py\r\n│       └── uploads/              # Product images\r\n│           └── .gitkeep\r\n```\r\n\r\n**Additional Dependencies:**\r\n- **Frontend:** Payment UI components, image galleries\r\n- **Backend:** Stripe SDK, PayPal SDK, image processing libraries\r\n\r\n---\r\n\r\n### 5. CMS Template (`--template cms`)\r\n\r\n**Description:** Content management system with rich text editing and media management.\r\n\r\n**Additional Structure:**\r\n```\r\n├── apps/\r\n│   ├── web/\r\n│   │   └── src/\r\n│   │       ├── components/\r\n│   │       │   ├── editor/\r\n│   │       │   │   ├── RichTextEditor.tsx\r\n│   │       │   │   ├── MediaUploader.tsx\r\n│   │       │   │   └── ContentPreview.tsx\r\n│   │       │   ├── content/\r\n│   │       │   │   ├── ContentList.tsx\r\n│   │       │   │   ├── ContentCard.tsx\r\n│   │       │   │   └── ContentForm.tsx\r\n│   │       │   └── admin/\r\n│   │       │       ├── AdminDashboard.tsx\r\n│   │       │       ├── UserManager.tsx\r\n│   │       │       └── RoleManager.tsx\r\n│   │       └── stores/\r\n│   │           ├── contentStore.ts\r\n│   │           ├── mediaStore.ts\r\n│   │           └── adminStore.ts\r\n│   └── api/\r\n│       ├── src/\r\n│       │   ├── routes/\r\n│       │   │   ├── content.py\r\n│       │   │   ├── media.py\r\n│       │   │   ├── admin.py\r\n│       │   │   └── pages.py\r\n│       │   ├── models/\r\n│       │   │   ├── content.py\r\n│       │   │   ├── page.py\r\n│       │   │   ├── media.py\r\n│       │   │   └── category.py\r\n│       │   ├── storage/\r\n│       │   │   ├── __init__.py\r\n│       │   │   ├── local.py\r\n│       │   │   └── cloud.py\r\n│       │   └── cms/\r\n│       │       ├── __init__.py\r\n│       │       ├── publishing.py\r\n│       │       └── workflow.py\r\n│       └── uploads/\r\n│           ├── images/\r\n│           ├── documents/\r\n│           └── .gitkeep\r\n```\r\n\r\n**Additional Dependencies:**\r\n- **Frontend:** Rich text editor (TipTap/Slate), file upload components\r\n- **Backend:** File handling libraries, image processing, cloud storage SDKs\r\n\r\n---\r\n\r\n### 6. API Only Template (`--template api-only`)\r\n\r\n**Description:** FastAPI backend only, no React frontend - ideal for microservices or mobile app backends.\r\n\r\n**Project Structure:**\r\n```\r\nmy-farm-api/\r\n├── src/\r\n│   ├── routes/\r\n│   │   ├── __init__.py\r\n│   │   ├── health.py\r\n│   │   ├── users.py\r\n│   │   └── api.py              # API router aggregation\r\n│   ├── models/\r\n│   │   ├── __init__.py\r\n│   │   ├── base.py\r\n│   │   └── user.py\r\n│   ├── database/\r\n│   │   ├── __init__.py\r\n│   │   └── connection.py\r\n│   ├── core/\r\n│   │   ├── __init__.py\r\n│   │   ├── config.py\r\n│   │   ├── security.py\r\n│   │   └── middleware.py\r\n│   ├── schemas/                # Pydantic response schemas\r\n│   │   ├── __init__.py\r\n│   │   └── user.py\r\n│   └── main.py\r\n├── tests/\r\n│   ├── __init__.py\r\n│   ├── conftest.py\r\n│   └── test_api.py\r\n├── docs/                       # OpenAPI documentation\r\n├── scripts/                    # Utility scripts\r\n├── requirements.txt\r\n├── pyproject.toml\r\n├── Dockerfile\r\n├── docker-compose.yml\r\n├── .env.example\r\n└── README.md\r\n```\r\n\r\n**Focus Areas:**\r\n- Enhanced API documentation and testing\r\n- Microservice-ready architecture\r\n- Advanced authentication and authorization\r\n- OpenAPI specification generation\r\n\r\n---\r\n\r\n## Feature Integration Modifications\r\n\r\n### Authentication Feature (`--features auth`)\r\n\r\n**Adds to any template:**\r\n```\r\n├── apps/\r\n│   ├── web/src/\r\n│   │   ├── components/auth/\r\n│   │   │   ├── LoginForm.tsx\r\n│   │   │   ├── RegisterForm.tsx\r\n│   │   │   ├── ProtectedRoute.tsx\r\n│   │   │   └── UserProfile.tsx\r\n│   │   ├── hooks/\r\n│   │   │   ├── useAuth.ts\r\n│   │   │   └── useUser.ts\r\n│   │   └── stores/\r\n│   │       └── authStore.ts\r\n│   └── api/src/\r\n│       ├── routes/\r\n│       │   ├── auth.py\r\n│       │   └── users.py\r\n│       ├── models/\r\n│       │   ├── user.py\r\n│       │   └── token.py\r\n│       └── auth/\r\n│           ├── __init__.py\r\n│           ├── jwt.py\r\n│           ├── oauth.py\r\n│           └── middleware.py\r\n```\r\n\r\n### AI Feature (`--features ai`)\r\n\r\n**Adds to any template:**\r\n```\r\n├── apps/\r\n│   ├── web/src/\r\n│   │   ├── components/ai/\r\n│   │   │   ├── AIResponse.tsx\r\n│   │   │   ├── ModelSelector.tsx\r\n│   │   │   └── InferenceStatus.tsx\r\n│   │   └── hooks/\r\n│   │       ├── useAIInference.ts\r\n│   │       └── useStreamingAI.ts\r\n│   └── api/src/\r\n│       ├── routes/\r\n│       │   └── ai.py\r\n│       ├── ai/\r\n│       │   ├── __init__.py\r\n│       │   ├── model_manager.py\r\n│       │   ├── inference.py\r\n│       │   ├── gpu_utils.py\r\n│       │   └── ollama_client.py\r\n│       └── models/\r\n│           ├── .gitkeep\r\n│           └── ollama/\r\n│               └── .gitkeep\r\n```\r\n\r\n### Real-time Feature (`--features realtime`)\r\n\r\n**Adds to any template:**\r\n```\r\n├── apps/\r\n│   ├── web/src/\r\n│   │   ├── hooks/\r\n│   │   │   ├── useWebSocket.ts\r\n│   │   │   └── useRealtime.ts\r\n│   │   └── components/realtime/\r\n│   │       ├── LiveUpdates.tsx\r\n│   │       └── ConnectionStatus.tsx\r\n│   └── api/src/\r\n│       ├── routes/\r\n│       │   └── websocket.py\r\n│       └── websocket/\r\n│           ├── __init__.py\r\n│           ├── manager.py\r\n│           └── handlers.py\r\n```\r\n\r\n---\r\n\r\n## Configuration Variations\r\n\r\n### Database Configuration\r\n\r\n**MongoDB (Default):**\r\n```typescript\r\n// farm.config.ts\r\nexport default defineConfig({\r\n  database: {\r\n    type: 'mongodb',\r\n    url: process.env.MONGODB_URL || 'mongodb://localhost:27017/farmapp'\r\n  }\r\n});\r\n```\r\n\r\n**PostgreSQL:**\r\n```typescript\r\nexport default defineConfig({\r\n  database: {\r\n    type: 'postgresql',\r\n    url: process.env.DATABASE_URL || 'postgresql://user:pass@localhost/farmapp'\r\n  }\r\n});\r\n```\r\n\r\n### Template-Specific Config\r\n\r\nEach template includes specific configuration in `farm.config.ts`:\r\n\r\n```typescript\r\n// AI Chat template example\r\nimport { defineConfig } from '@farm/core';\r\n\r\nexport default defineConfig({\r\n  template: 'ai-chat',\r\n  features: ['auth', 'ai', 'realtime'],\r\n  ai: {\r\n    providers: {\r\n      ollama: {\r\n        enabled: true,\r\n        url: 'http://localhost:11434',\r\n        models: ['llama3.1', 'codestral'],\r\n        defaultModel: 'llama3.1',\r\n        autoStart: true,\r\n        autoPull: ['llama3.1']\r\n      },\r\n      openai: {\r\n        enabled: true,\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n        models: ['gpt-4', 'gpt-3.5-turbo'],\r\n        defaultModel: 'gpt-3.5-turbo'\r\n      }\r\n    },\r\n    routing: {\r\n      development: 'ollama',\r\n      production: 'openai'\r\n    },\r\n    features: {\r\n      streaming: true,\r\n      caching: true\r\n    }\r\n  },\r\n  websocket: {\r\n    enabled: true,\r\n    cors: ['http://localhost:3000']\r\n  }\r\n});\r\n```\r\n\r\n---\r\n\r\n*Status: ✅ Completed - Ready for implementation*\r\n",
      "excerpt": "All templates share this foundational structure, with template-specific additions:\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\nDescription: Simple React + FastAPI + MongoDB setup for...",
      "category": "architectural-sketches-detailed/phase1",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.777Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase1",
        "Template_project_structures"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Template Project Structures",
          "id": "template-project-structures"
        },
        {
          "level": 2,
          "text": "Base Project Structure",
          "id": "base-project-structure"
        },
        {
          "level": 2,
          "text": "Template Specifications",
          "id": "template-specifications"
        },
        {
          "level": 3,
          "text": "1. Basic Template (`--template basic`)",
          "id": "1-basic-template---template-basic"
        },
        {
          "level": 3,
          "text": "2. AI Chat Template (`--template ai-chat`)",
          "id": "2-ai-chat-template---template-ai-chat"
        },
        {
          "level": 3,
          "text": "3. AI Dashboard Template (`--template ai-dashboard`)",
          "id": "3-ai-dashboard-template---template-ai-dashboard"
        },
        {
          "level": 3,
          "text": "4. E-commerce Template (`--template ecommerce`)",
          "id": "4-e-commerce-template---template-ecommerce"
        },
        {
          "level": 3,
          "text": "5. CMS Template (`--template cms`)",
          "id": "5-cms-template---template-cms"
        },
        {
          "level": 3,
          "text": "6. API Only Template (`--template api-only`)",
          "id": "6-api-only-template---template-api-only"
        },
        {
          "level": 2,
          "text": "Feature Integration Modifications",
          "id": "feature-integration-modifications"
        },
        {
          "level": 3,
          "text": "Authentication Feature (`--features auth`)",
          "id": "authentication-feature---features-auth"
        },
        {
          "level": 3,
          "text": "AI Feature (`--features ai`)",
          "id": "ai-feature---features-ai"
        },
        {
          "level": 3,
          "text": "Real-time Feature (`--features realtime`)",
          "id": "real-time-feature---features-realtime"
        },
        {
          "level": 2,
          "text": "Configuration Variations",
          "id": "configuration-variations"
        },
        {
          "level": 3,
          "text": "Database Configuration",
          "id": "database-configuration"
        },
        {
          "level": 3,
          "text": "Template-Specific Config",
          "id": "template-specific-config"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase2-auth_authorization_flow",
      "title": "Auth_authorization_flow",
      "url": "/architectural-sketches-detailed/phase2/auth_authorization_flow",
      "content": "# Authentication & Authorization Flow\r\n\r\n## Overview\r\n\r\nThe FARM authentication system provides a comprehensive, plugin-based auth solution with JWT tokens, OAuth providers, role-based access control (RBAC), and seamless integration with the AI provider system. It supports both built-in auth patterns and extensible custom authentication flows while maintaining type safety across the full stack.\r\n\r\n---\r\n\r\n## High-Level Authentication Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Authentication Layer                    │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │    JWT      │  │   OAuth     │  │    SAML     │  │ Custom  │ │\r\n│  │  Provider   │  │ Providers   │  │  Provider   │  │Provider │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │    User     │  │    Role     │  │ Permission  │  │ Session │ │\r\n│  │ Management  │  │ Management  │  │  Manager    │  │ Manager │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Auth        │  │   Route     │  │     API     │  │   AI    │ │\r\n│  │Middleware   │  │ Protection  │  │ Protection  │  │ Context │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Authentication Models\r\n\r\n### 1. User Model with Comprehensive Auth Data\r\n\r\n**Enhanced User Model with Auth Context:**\r\n\r\n```python\r\n# apps/api/src/auth/models/user.py\r\nfrom datetime import datetime, timezone\r\nfrom typing import List, Optional, Dict, Any\r\nfrom beanie import Document, Indexed\r\nfrom pydantic import BaseModel, Field, EmailStr\r\nfrom enum import Enum\r\n\r\nclass UserStatus(str, Enum):\r\n    ACTIVE = \"active\"\r\n    INACTIVE = \"inactive\"\r\n    SUSPENDED = \"suspended\"\r\n    PENDING_VERIFICATION = \"pending_verification\"\r\n\r\nclass AuthProvider(str, Enum):\r\n    LOCAL = \"local\"\r\n    GOOGLE = \"google\"\r\n    GITHUB = \"github\"\r\n    MICROSOFT = \"microsoft\"\r\n    APPLE = \"apple\"\r\n    SAML = \"saml\"\r\n\r\nclass TwoFactorMethod(str, Enum):\r\n    NONE = \"none\"\r\n    SMS = \"sms\"\r\n    EMAIL = \"email\"\r\n    AUTHENTICATOR = \"authenticator\"\r\n    WEBAUTHN = \"webauthn\"\r\n\r\nclass UserProfile(BaseModel):\r\n    \"\"\"User profile information\"\"\"\r\n    first_name: Optional[str] = None\r\n    last_name: Optional[str] = None\r\n    avatar_url: Optional[str] = None\r\n    bio: Optional[str] = None\r\n    timezone: str = \"UTC\"\r\n    locale: str = \"en\"\r\n    preferences: Dict[str, Any] = Field(default_factory=dict)\r\n\r\nclass AuthMetadata(BaseModel):\r\n    \"\"\"Authentication metadata\"\"\"\r\n    provider: AuthProvider = AuthProvider.LOCAL\r\n    provider_id: Optional[str] = None\r\n    provider_data: Dict[str, Any] = Field(default_factory=dict)\r\n    two_factor_method: TwoFactorMethod = TwoFactorMethod.NONE\r\n    two_factor_backup_codes: List[str] = Field(default_factory=list)\r\n    password_changed_at: Optional[datetime] = None\r\n    last_login_at: Optional[datetime] = None\r\n    login_count: int = 0\r\n    failed_login_attempts: int = 0\r\n    account_locked_until: Optional[datetime] = None\r\n\r\nclass User(Document):\r\n    \"\"\"Comprehensive user model with auth integration\"\"\"\r\n\r\n    # Core identity\r\n    email: Indexed(EmailStr, unique=True)\r\n    username: Optional[Indexed(str, unique=True)] = None\r\n    password_hash: Optional[str] = None\r\n\r\n    # Profile information\r\n    profile: UserProfile = Field(default_factory=UserProfile)\r\n\r\n    # Authentication metadata\r\n    auth: AuthMetadata = Field(default_factory=AuthMetadata)\r\n\r\n    # Status and verification\r\n    status: UserStatus = UserStatus.PENDING_VERIFICATION\r\n    email_verified: bool = False\r\n    email_verification_token: Optional[str] = None\r\n    password_reset_token: Optional[str] = None\r\n    password_reset_expires: Optional[datetime] = None\r\n\r\n    # Role-based access control\r\n    roles: List[str] = Field(default_factory=list)\r\n    permissions: List[str] = Field(default_factory=list)\r\n\r\n    # AI context (for personalized AI interactions)\r\n    ai_context: Dict[str, Any] = Field(default_factory=dict)\r\n    ai_preferences: Dict[str, Any] = Field(default_factory=dict)\r\n\r\n    # Timestamps\r\n    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\r\n    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\r\n    last_active_at: Optional[datetime] = None\r\n\r\n    class Settings:\r\n        collection = \"users\"\r\n        indexes = [\r\n            \"email\",\r\n            \"username\",\r\n            \"status\",\r\n            \"roles\",\r\n            \"auth.provider\",\r\n            \"created_at\",\r\n            \"last_active_at\"\r\n        ]\r\n\r\n    def has_role(self, role: str) -> bool:\r\n        \"\"\"Check if user has specific role\"\"\"\r\n        return role in self.roles\r\n\r\n    def has_permission(self, permission: str) -> bool:\r\n        \"\"\"Check if user has specific permission\"\"\"\r\n        return permission in self.permissions\r\n\r\n    def add_role(self, role: str) -> None:\r\n        \"\"\"Add role to user\"\"\"\r\n        if role not in self.roles:\r\n            self.roles.append(role)\r\n\r\n    def remove_role(self, role: str) -> None:\r\n        \"\"\"Remove role from user\"\"\"\r\n        if role in self.roles:\r\n            self.roles.remove(role)\r\n\r\n    def is_locked(self) -> bool:\r\n        \"\"\"Check if account is locked\"\"\"\r\n        if not self.auth.account_locked_until:\r\n            return False\r\n        return datetime.now(timezone.utc) < self.auth.account_locked_until\r\n\r\n    def can_login(self) -> bool:\r\n        \"\"\"Check if user can login\"\"\"\r\n        return (\r\n            self.status == UserStatus.ACTIVE and\r\n            not self.is_locked() and\r\n            self.email_verified\r\n        )\r\n\r\n    async def update_login_info(self) -> None:\r\n        \"\"\"Update login metadata\"\"\"\r\n        now = datetime.now(timezone.utc)\r\n        self.auth.last_login_at = now\r\n        self.auth.login_count += 1\r\n        self.auth.failed_login_attempts = 0\r\n        self.last_active_at = now\r\n        await self.save()\r\n\r\n    async def record_failed_login(self) -> None:\r\n        \"\"\"Record failed login attempt\"\"\"\r\n        self.auth.failed_login_attempts += 1\r\n\r\n        # Lock account after 5 failed attempts\r\n        if self.auth.failed_login_attempts >= 5:\r\n            self.auth.account_locked_until = (\r\n                datetime.now(timezone.utc) + timedelta(minutes=30)\r\n            )\r\n\r\n        await self.save()\r\n```\r\n\r\n### 2. Role and Permission Models\r\n\r\n**Flexible RBAC System:**\r\n\r\n```python\r\n# apps/api/src/auth/models/rbac.py\r\nfrom typing import List, Optional, Dict, Any\r\nfrom beanie import Document, Indexed\r\nfrom pydantic import BaseModel, Field\r\nfrom datetime import datetime, timezone\r\n\r\nclass Permission(Document):\r\n    \"\"\"System permissions\"\"\"\r\n\r\n    name: Indexed(str, unique=True)\r\n    description: str\r\n    category: str  # e.g., \"user\", \"ai\", \"admin\", \"api\"\r\n    resource: Optional[str] = None  # Specific resource this applies to\r\n    actions: List[str] = Field(default_factory=list)  # CRUD operations\r\n\r\n    # AI-specific permissions\r\n    ai_providers: List[str] = Field(default_factory=list)  # Which AI providers\r\n    ai_models: List[str] = Field(default_factory=list)     # Which models\r\n    ai_rate_limits: Dict[str, int] = Field(default_factory=dict)\r\n\r\n    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\r\n\r\n    class Settings:\r\n        collection = \"permissions\"\r\n        indexes = [\"name\", \"category\", \"resource\"]\r\n\r\nclass Role(Document):\r\n    \"\"\"User roles with permissions\"\"\"\r\n\r\n    name: Indexed(str, unique=True)\r\n    description: str\r\n    permissions: List[str] = Field(default_factory=list)  # Permission names\r\n\r\n    # Role hierarchy\r\n    parent_roles: List[str] = Field(default_factory=list)\r\n    child_roles: List[str] = Field(default_factory=list)\r\n\r\n    # AI-specific role configuration\r\n    ai_access_level: str = \"basic\"  # basic, advanced, admin\r\n    ai_daily_quota: Optional[int] = None  # Daily AI request quota\r\n    ai_monthly_quota: Optional[int] = None  # Monthly AI request quota\r\n\r\n    # Role metadata\r\n    is_system_role: bool = False  # Cannot be deleted\r\n    is_default: bool = False      # Assigned to new users\r\n\r\n    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\r\n    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\r\n\r\n    class Settings:\r\n        collection = \"roles\"\r\n        indexes = [\"name\", \"is_system_role\", \"is_default\"]\r\n\r\n    async def get_all_permissions(self) -> List[str]:\r\n        \"\"\"Get all permissions including inherited from parent roles\"\"\"\r\n        all_permissions = set(self.permissions)\r\n\r\n        # Add permissions from parent roles\r\n        for parent_role_name in self.parent_roles:\r\n            parent_role = await Role.find_one(Role.name == parent_role_name)\r\n            if parent_role:\r\n                parent_permissions = await parent_role.get_all_permissions()\r\n                all_permissions.update(parent_permissions)\r\n\r\n        return list(all_permissions)\r\n\r\n# Default system roles and permissions\r\nSYSTEM_PERMISSIONS = [\r\n    Permission(\r\n        name=\"user.read\",\r\n        description=\"Read user information\",\r\n        category=\"user\",\r\n        resource=\"user\",\r\n        actions=[\"read\"]\r\n    ),\r\n    Permission(\r\n        name=\"user.write\",\r\n        description=\"Create and update users\",\r\n        category=\"user\",\r\n        resource=\"user\",\r\n        actions=[\"create\", \"update\"]\r\n    ),\r\n    Permission(\r\n        name=\"ai.basic\",\r\n        description=\"Basic AI access\",\r\n        category=\"ai\",\r\n        ai_providers=[\"ollama\", \"openai\"],\r\n        ai_models=[\"llama3.1\", \"gpt-3.5-turbo\"],\r\n        ai_rate_limits={\"requests_per_hour\": 100}\r\n    ),\r\n    Permission(\r\n        name=\"ai.advanced\",\r\n        description=\"Advanced AI access\",\r\n        category=\"ai\",\r\n        ai_providers=[\"ollama\", \"openai\", \"huggingface\"],\r\n        ai_models=[\"llama3.1\", \"gpt-4\", \"claude-3\"],\r\n        ai_rate_limits={\"requests_per_hour\": 1000}\r\n    ),\r\n    Permission(\r\n        name=\"admin.full\",\r\n        description=\"Full administrative access\",\r\n        category=\"admin\",\r\n        actions=[\"create\", \"read\", \"update\", \"delete\"]\r\n    )\r\n]\r\n\r\nSYSTEM_ROLES = [\r\n    Role(\r\n        name=\"user\",\r\n        description=\"Default user role\",\r\n        permissions=[\"user.read\", \"ai.basic\"],\r\n        is_system_role=True,\r\n        is_default=True,\r\n        ai_access_level=\"basic\",\r\n        ai_daily_quota=100\r\n    ),\r\n    Role(\r\n        name=\"premium_user\",\r\n        description=\"Premium user with enhanced AI access\",\r\n        permissions=[\"user.read\", \"user.write\", \"ai.advanced\"],\r\n        is_system_role=True,\r\n        ai_access_level=\"advanced\",\r\n        ai_daily_quota=1000\r\n    ),\r\n    Role(\r\n        name=\"admin\",\r\n        description=\"System administrator\",\r\n        permissions=[\"user.read\", \"user.write\", \"ai.advanced\", \"admin.full\"],\r\n        is_system_role=True,\r\n        ai_access_level=\"admin\",\r\n        ai_daily_quota=None  # Unlimited\r\n    )\r\n]\r\n```\r\n\r\n---\r\n\r\n## Authentication Service Layer\r\n\r\n### 1. Core Authentication Service\r\n\r\n**Comprehensive Authentication Logic:**\r\n\r\n```python\r\n# apps/api/src/auth/services/auth_service.py\r\nfrom typing import Optional, Tuple, Dict, Any\r\nfrom datetime import datetime, timedelta, timezone\r\nfrom passlib.context import CryptContext\r\nfrom jose import JWTError, jwt\r\nfrom pydantic import BaseModel, EmailStr\r\nimport secrets\r\nimport hashlib\r\n\r\nfrom ..models.user import User, UserStatus, AuthProvider\r\nfrom ..models.rbac import Role, Permission\r\nfrom .email_service import EmailService\r\nfrom .oauth_service import OAuthService\r\nfrom ..exceptions import AuthenticationError, AuthorizationError\r\n\r\nclass LoginRequest(BaseModel):\r\n    email: EmailStr\r\n    password: str\r\n    remember_me: bool = False\r\n    two_factor_code: Optional[str] = None\r\n\r\nclass RegisterRequest(BaseModel):\r\n    email: EmailStr\r\n    password: str\r\n    username: Optional[str] = None\r\n    first_name: Optional[str] = None\r\n    last_name: Optional[str] = None\r\n\r\nclass TokenResponse(BaseModel):\r\n    access_token: str\r\n    refresh_token: str\r\n    token_type: str = \"bearer\"\r\n    expires_in: int\r\n    user: Dict[str, Any]\r\n\r\nclass AuthService:\r\n    def __init__(self, config: Dict[str, Any]):\r\n        self.config = config\r\n        self.pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\r\n        self.email_service = EmailService(config.get(\"email\", {}))\r\n        self.oauth_service = OAuthService(config.get(\"oauth\", {}))\r\n\r\n        # JWT configuration\r\n        self.jwt_secret = config[\"jwt\"][\"secret\"]\r\n        self.jwt_algorithm = config[\"jwt\"].get(\"algorithm\", \"HS256\")\r\n        self.access_token_expire = config[\"jwt\"].get(\"access_token_expire\", 15)  # minutes\r\n        self.refresh_token_expire = config[\"jwt\"].get(\"refresh_token_expire\", 7)  # days\r\n\r\n    async def register(self, request: RegisterRequest) -> User:\r\n        \"\"\"Register new user\"\"\"\r\n\r\n        # Check if user already exists\r\n        existing_user = await User.find_one(User.email == request.email)\r\n        if existing_user:\r\n            raise AuthenticationError(\"User with this email already exists\")\r\n\r\n        if request.username:\r\n            existing_username = await User.find_one(User.username == request.username)\r\n            if existing_username:\r\n                raise AuthenticationError(\"Username already taken\")\r\n\r\n        # Create user\r\n        user = User(\r\n            email=request.email,\r\n            username=request.username,\r\n            password_hash=self.hash_password(request.password),\r\n            status=UserStatus.PENDING_VERIFICATION,\r\n            email_verification_token=self.generate_verification_token()\r\n        )\r\n\r\n        # Set profile information\r\n        if request.first_name:\r\n            user.profile.first_name = request.first_name\r\n        if request.last_name:\r\n            user.profile.last_name = request.last_name\r\n\r\n        # Assign default role\r\n        default_role = await Role.find_one(Role.is_default == True)\r\n        if default_role:\r\n            user.roles.append(default_role.name)\r\n\r\n        await user.save()\r\n\r\n        # Send verification email\r\n        await self.send_verification_email(user)\r\n\r\n        return user\r\n\r\n    async def login(self, request: LoginRequest) -> TokenResponse:\r\n        \"\"\"Authenticate user and return tokens\"\"\"\r\n\r\n        # Find user\r\n        user = await User.find_one(User.email == request.email)\r\n        if not user:\r\n            raise AuthenticationError(\"Invalid email or password\")\r\n\r\n        # Check if account can login\r\n        if not user.can_login():\r\n            if user.is_locked():\r\n                raise AuthenticationError(\"Account is temporarily locked\")\r\n            elif user.status != UserStatus.ACTIVE:\r\n                raise AuthenticationError(\"Account is not active\")\r\n            elif not user.email_verified:\r\n                raise AuthenticationError(\"Email not verified\")\r\n\r\n        # Verify password\r\n        if not self.verify_password(request.password, user.password_hash):\r\n            await user.record_failed_login()\r\n            raise AuthenticationError(\"Invalid email or password\")\r\n\r\n        # Check two-factor authentication\r\n        if user.auth.two_factor_method != \"none\" and not request.two_factor_code:\r\n            raise AuthenticationError(\"Two-factor authentication required\")\r\n\r\n        if request.two_factor_code:\r\n            if not await self.verify_two_factor(user, request.two_factor_code):\r\n                raise AuthenticationError(\"Invalid two-factor code\")\r\n\r\n        # Update login info\r\n        await user.update_login_info()\r\n\r\n        # Generate tokens\r\n        access_token = self.create_access_token(user, request.remember_me)\r\n        refresh_token = self.create_refresh_token(user)\r\n\r\n        # Prepare user data for response\r\n        user_data = {\r\n            \"id\": str(user.id),\r\n            \"email\": user.email,\r\n            \"username\": user.username,\r\n            \"profile\": user.profile.dict(),\r\n            \"roles\": user.roles,\r\n            \"permissions\": await self.get_user_permissions(user),\r\n            \"ai_access_level\": await self.get_user_ai_access_level(user)\r\n        }\r\n\r\n        return TokenResponse(\r\n            access_token=access_token,\r\n            refresh_token=refresh_token,\r\n            expires_in=self.access_token_expire * 60,\r\n            user=user_data\r\n        )\r\n\r\n    async def oauth_login(self, provider: str, code: str, redirect_uri: str) -> TokenResponse:\r\n        \"\"\"OAuth authentication flow\"\"\"\r\n\r\n        # Exchange code for user info\r\n        oauth_user = await self.oauth_service.get_user_info(provider, code, redirect_uri)\r\n\r\n        # Find or create user\r\n        user = await User.find_one(\r\n            User.auth.provider == provider,\r\n            User.auth.provider_id == oauth_user.id\r\n        )\r\n\r\n        if not user:\r\n            # Create new user from OAuth data\r\n            user = User(\r\n                email=oauth_user.email,\r\n                username=oauth_user.username,\r\n                status=UserStatus.ACTIVE,\r\n                email_verified=True\r\n            )\r\n\r\n            # Set OAuth metadata\r\n            user.auth.provider = AuthProvider(provider)\r\n            user.auth.provider_id = oauth_user.id\r\n            user.auth.provider_data = oauth_user.raw_data\r\n\r\n            # Set profile from OAuth data\r\n            user.profile.first_name = oauth_user.first_name\r\n            user.profile.last_name = oauth_user.last_name\r\n            user.profile.avatar_url = oauth_user.avatar_url\r\n\r\n            # Assign default role\r\n            default_role = await Role.find_one(Role.is_default == True)\r\n            if default_role:\r\n                user.roles.append(default_role.name)\r\n\r\n            await user.save()\r\n\r\n        # Update login info\r\n        await user.update_login_info()\r\n\r\n        # Generate tokens\r\n        access_token = self.create_access_token(user)\r\n        refresh_token = self.create_refresh_token(user)\r\n\r\n        user_data = {\r\n            \"id\": str(user.id),\r\n            \"email\": user.email,\r\n            \"username\": user.username,\r\n            \"profile\": user.profile.dict(),\r\n            \"roles\": user.roles,\r\n            \"permissions\": await self.get_user_permissions(user),\r\n            \"ai_access_level\": await self.get_user_ai_access_level(user)\r\n        }\r\n\r\n        return TokenResponse(\r\n            access_token=access_token,\r\n            refresh_token=refresh_token,\r\n            expires_in=self.access_token_expire * 60,\r\n            user=user_data\r\n        )\r\n\r\n    def create_access_token(self, user: User, extended: bool = False) -> str:\r\n        \"\"\"Create JWT access token\"\"\"\r\n        expire_minutes = self.access_token_expire\r\n        if extended:\r\n            expire_minutes = 24 * 60  # 24 hours for \"remember me\"\r\n\r\n        expire = datetime.utcnow() + timedelta(minutes=expire_minutes)\r\n\r\n        payload = {\r\n            \"sub\": str(user.id),\r\n            \"email\": user.email,\r\n            \"roles\": user.roles,\r\n            \"permissions\": user.permissions,\r\n            \"ai_access_level\": user.get_ai_access_level(),\r\n            \"exp\": expire,\r\n            \"iat\": datetime.utcnow(),\r\n            \"type\": \"access\"\r\n        }\r\n\r\n        return jwt.encode(payload, self.jwt_secret, algorithm=self.jwt_algorithm)\r\n\r\n    def create_refresh_token(self, user: User) -> str:\r\n        \"\"\"Create JWT refresh token\"\"\"\r\n        expire = datetime.utcnow() + timedelta(days=self.refresh_token_expire)\r\n\r\n        payload = {\r\n            \"sub\": str(user.id),\r\n            \"exp\": expire,\r\n            \"iat\": datetime.utcnow(),\r\n            \"type\": \"refresh\"\r\n        }\r\n\r\n        return jwt.encode(payload, self.jwt_secret, algorithm=self.jwt_algorithm)\r\n\r\n    async def verify_token(self, token: str) -> Optional[User]:\r\n        \"\"\"Verify JWT token and return user\"\"\"\r\n        try:\r\n            payload = jwt.decode(token, self.jwt_secret, algorithms=[self.jwt_algorithm])\r\n            user_id = payload.get(\"sub\")\r\n            token_type = payload.get(\"type\", \"access\")\r\n\r\n            if not user_id or token_type != \"access\":\r\n                return None\r\n\r\n            user = await User.get(user_id)\r\n            if not user or not user.can_login():\r\n                return None\r\n\r\n            return user\r\n\r\n        except JWTError:\r\n            return None\r\n\r\n    async def refresh_token(self, refresh_token: str) -> TokenResponse:\r\n        \"\"\"Refresh access token using refresh token\"\"\"\r\n        try:\r\n            payload = jwt.decode(refresh_token, self.jwt_secret, algorithms=[self.jwt_algorithm])\r\n            user_id = payload.get(\"sub\")\r\n            token_type = payload.get(\"type\")\r\n\r\n            if not user_id or token_type != \"refresh\":\r\n                raise AuthenticationError(\"Invalid refresh token\")\r\n\r\n            user = await User.get(user_id)\r\n            if not user or not user.can_login():\r\n                raise AuthenticationError(\"User not found or inactive\")\r\n\r\n            # Generate new tokens\r\n            access_token = self.create_access_token(user)\r\n            new_refresh_token = self.create_refresh_token(user)\r\n\r\n            user_data = {\r\n                \"id\": str(user.id),\r\n                \"email\": user.email,\r\n                \"username\": user.username,\r\n                \"profile\": user.profile.dict(),\r\n                \"roles\": user.roles,\r\n                \"permissions\": await self.get_user_permissions(user),\r\n                \"ai_access_level\": await self.get_user_ai_access_level(user)\r\n            }\r\n\r\n            return TokenResponse(\r\n                access_token=access_token,\r\n                refresh_token=new_refresh_token,\r\n                expires_in=self.access_token_expire * 60,\r\n                user=user_data\r\n            )\r\n\r\n        except JWTError:\r\n            raise AuthenticationError(\"Invalid refresh token\")\r\n\r\n    async def get_user_permissions(self, user: User) -> List[str]:\r\n        \"\"\"Get all user permissions including role-based permissions\"\"\"\r\n        all_permissions = set(user.permissions)\r\n\r\n        # Add role-based permissions\r\n        for role_name in user.roles:\r\n            role = await Role.find_one(Role.name == role_name)\r\n            if role:\r\n                role_permissions = await role.get_all_permissions()\r\n                all_permissions.update(role_permissions)\r\n\r\n        return list(all_permissions)\r\n\r\n    async def get_user_ai_access_level(self, user: User) -> str:\r\n        \"\"\"Get user's AI access level based on roles\"\"\"\r\n        access_levels = [\"basic\", \"advanced\", \"admin\"]\r\n        highest_level = \"basic\"\r\n\r\n        for role_name in user.roles:\r\n            role = await Role.find_one(Role.name == role_name)\r\n            if role and role.ai_access_level in access_levels:\r\n                if access_levels.index(role.ai_access_level) > access_levels.index(highest_level):\r\n                    highest_level = role.ai_access_level\r\n\r\n        return highest_level\r\n\r\n    def hash_password(self, password: str) -> str:\r\n        \"\"\"Hash password using bcrypt\"\"\"\r\n        return self.pwd_context.hash(password)\r\n\r\n    def verify_password(self, plain_password: str, hashed_password: str) -> bool:\r\n        \"\"\"Verify password against hash\"\"\"\r\n        return self.pwd_context.verify(plain_password, hashed_password)\r\n\r\n    def generate_verification_token(self) -> str:\r\n        \"\"\"Generate secure verification token\"\"\"\r\n        return secrets.token_urlsafe(32)\r\n```\r\n\r\n---\r\n\r\n## FastAPI Integration & Middleware\r\n\r\n### 1. Authentication Middleware\r\n\r\n**JWT Token Validation Middleware:**\r\n\r\n```python\r\n# apps/api/src/auth/middleware.py\r\nfrom fastapi import Request, HTTPException, status\r\nfrom fastapi.responses import JSONResponse\r\nfrom starlette.middleware.base import BaseHTTPMiddleware\r\nfrom typing import Optional, List\r\nimport re\r\n\r\nfrom .services.auth_service import AuthService\r\nfrom .models.user import User\r\n\r\nclass AuthenticationMiddleware(BaseHTTPMiddleware):\r\n    def __init__(self, app, auth_service: AuthService):\r\n        super().__init__(app)\r\n        self.auth_service = auth_service\r\n\r\n        # Routes that don't require authentication\r\n        self.public_routes = [\r\n            r\"^/docs.*\",\r\n            r\"^/redoc.*\",\r\n            r\"^/openapi\\.json$\",\r\n            r\"^/health$\",\r\n            r\"^/api/auth/login$\",\r\n            r\"^/api/auth/register$\",\r\n            r\"^/api/auth/oauth/.*\",\r\n            r\"^/api/auth/verify-email.*\",\r\n            r\"^/api/auth/reset-password.*\",\r\n            r\"^/static/.*\"\r\n        ]\r\n\r\n    async def dispatch(self, request: Request, call_next):\r\n        # Check if route is public\r\n        if self.is_public_route(request.url.path):\r\n            return await call_next(request)\r\n\r\n        # Extract token from Authorization header\r\n        authorization = request.headers.get(\"Authorization\")\r\n        if not authorization or not authorization.startswith(\"Bearer \"):\r\n            return JSONResponse(\r\n                status_code=status.HTTP_401_UNAUTHORIZED,\r\n                content={\"detail\": \"Authentication required\"}\r\n            )\r\n\r\n        token = authorization.split(\" \")[1]\r\n\r\n        # Verify token and get user\r\n        user = await self.auth_service.verify_token(token)\r\n        if not user:\r\n            return JSONResponse(\r\n                status_code=status.HTTP_401_UNAUTHORIZED,\r\n                content={\"detail\": \"Invalid or expired token\"}\r\n            )\r\n\r\n        # Add user to request state\r\n        request.state.user = user\r\n        request.state.permissions = await self.auth_service.get_user_permissions(user)\r\n\r\n        return await call_next(request)\r\n\r\n    def is_public_route(self, path: str) -> bool:\r\n        \"\"\"Check if route is public (doesn't require auth)\"\"\"\r\n        for pattern in self.public_routes:\r\n            if re.match(pattern, path):\r\n                return True\r\n        return False\r\n\r\nclass AuthorizationMiddleware(BaseHTTPMiddleware):\r\n    \"\"\"Role and permission-based authorization\"\"\"\r\n\r\n    def __init__(self, app, auth_service: AuthService):\r\n        super().__init__(app)\r\n        self.auth_service = auth_service\r\n\r\n        # Route permission requirements\r\n        self.route_permissions = {\r\n            r\"^/api/admin/.*\": [\"admin.full\"],\r\n            r\"^/api/users/.*/delete$\": [\"user.delete\"],\r\n            r\"^/api/ai/models/.*\": [\"ai.basic\"],\r\n            r\"^/api/ai/chat.*\": [\"ai.basic\"],\r\n        }\r\n\r\n    async def dispatch(self, request: Request, call_next):\r\n        # Skip if no user (handled by AuthenticationMiddleware)\r\n        if not hasattr(request.state, \"user\"):\r\n            return await call_next(request)\r\n\r\n        # Check route permissions\r\n        required_permissions = self.get_required_permissions(request.url.path)\r\n        if required_permissions:\r\n            user_permissions = getattr(request.state, \"permissions\", [])\r\n\r\n            if not any(perm in user_permissions for perm in required_permissions):\r\n                return JSONResponse(\r\n                    status_code=status.HTTP_403_FORBIDDEN,\r\n                    content={\"detail\": \"Insufficient permissions\"}\r\n                )\r\n\r\n        return await call_next(request)\r\n\r\n    def get_required_permissions(self, path: str) -> List[str]:\r\n        \"\"\"Get required permissions for a route\"\"\"\r\n        for pattern, permissions in self.route_permissions.items():\r\n            if re.match(pattern, path):\r\n                return permissions\r\n        return []\r\n```\r\n\r\n### 2. Authentication Dependencies\r\n\r\n**FastAPI Dependency Injection for Auth:**\r\n\r\n```python\r\n# apps/api/src/auth/dependencies.py\r\nfrom fastapi import Depends, HTTPException, status, Request\r\nfrom typing import List, Optional\r\nfrom functools import wraps\r\n\r\nfrom .models.user import User\r\nfrom .services.auth_service import AuthService\r\n\r\nasync def get_current_user(request: Request) -> User:\r\n    \"\"\"Get current authenticated user\"\"\"\r\n    if not hasattr(request.state, \"user\"):\r\n        raise HTTPException(\r\n            status_code=status.HTTP_401_UNAUTHORIZED,\r\n            detail=\"Authentication required\"\r\n        )\r\n    return request.state.user\r\n\r\nasync def get_current_active_user(\r\n    current_user: User = Depends(get_current_user)\r\n) -> User:\r\n    \"\"\"Get current active user\"\"\"\r\n    if not current_user.can_login():\r\n        raise HTTPException(\r\n            status_code=status.HTTP_400_BAD_REQUEST,\r\n            detail=\"Inactive user\"\r\n        )\r\n    return current_user\r\n\r\ndef require_permissions(permissions: List[str]):\r\n    \"\"\"Decorator to require specific permissions\"\"\"\r\n    def decorator(func):\r\n        @wraps(func)\r\n        async def wrapper(*args, **kwargs):\r\n            request = kwargs.get(\"request\") or args[0]\r\n\r\n            if not hasattr(request.state, \"permissions\"):\r\n                raise HTTPException(\r\n                    status_code=status.HTTP_401_UNAUTHORIZED,\r\n                    detail=\"Authentication required\"\r\n                )\r\n\r\n            user_permissions = request.state.permissions\r\n            if not any(perm in user_permissions for perm in permissions):\r\n                raise HTTPException(\r\n                    status_code=status.HTTP_403_FORBIDDEN,\r\n                    detail=f\"Required permissions: {', '.join(permissions)}\"\r\n                )\r\n\r\n            return await func(*args, **kwargs)\r\n        return wrapper\r\n    return decorator\r\n\r\ndef require_roles(roles: List[str]):\r\n    \"\"\"Decorator to require specific roles\"\"\"\r\n    def decorator(func):\r\n        @wraps(func)\r\n        async def wrapper(*args, **kwargs):\r\n            request = kwargs.get(\"request\") or args[0]\r\n\r\n            if not hasattr(request.state, \"user\"):\r\n                raise HTTPException(\r\n                    status_code=status.HTTP_401_UNAUTHORIZED,\r\n                    detail=\"Authentication required\"\r\n                )\r\n\r\n            user = request.state.user\r\n            if not any(role in user.roles for role in roles):\r\n                raise HTTPException(\r\n                    status_code=status.HTTP_403_FORBIDDEN,\r\n                    detail=f\"Required roles: {', '.join(roles)}\"\r\n                )\r\n\r\n            return await func(*args, **kwargs)\r\n        return wrapper\r\n    return decorator\r\n\r\nasync def get_optional_user(request: Request) -> Optional[User]:\r\n    \"\"\"Get current user if authenticated, None otherwise\"\"\"\r\n    return getattr(request.state, \"user\", None)\r\n\r\nclass AIAccessLevel:\r\n    \"\"\"AI access level dependency\"\"\"\r\n\r\n    def __init__(self, min_level: str = \"basic\"):\r\n        self.min_level = min_level\r\n        self.levels = {\"basic\": 1, \"advanced\": 2, \"admin\": 3}\r\n\r\n    async def __call__(self, request: Request) -> User:\r\n        if not hasattr(request.state, \"user\"):\r\n            raise HTTPException(\r\n                status_code=status.HTTP_401_UNAUTHORIZED,\r\n                detail=\"Authentication required\"\r\n            )\r\n\r\n        user = request.state.user\r\n        user_level = user.get_ai_access_level()\r\n\r\n        if self.levels.get(user_level, 0) < self.levels.get(self.min_level, 0):\r\n            raise HTTPException(\r\n                status_code=status.HTTP_403_FORBIDDEN,\r\n                detail=f\"Requires {self.min_level} AI access level\"\r\n            )\r\n\r\n        return user\r\n\r\n# Pre-configured dependency instances\r\nrequire_basic_ai = AIAccessLevel(\"basic\")\r\nrequire_advanced_ai = AIAccessLevel(\"advanced\")\r\nrequire_admin_ai = AIAccessLevel(\"admin\")\r\n```\r\n\r\n---\r\n\r\n## Frontend Authentication Integration\r\n\r\n### 1. Authentication Context & Hooks\r\n\r\n**React Authentication Management:**\r\n\r\n```typescript\r\n// apps/web/src/auth/context.tsx\r\nimport React, { createContext, useContext, useReducer, useEffect } from \"react\";\r\nimport { authApi } from \"../services/api\";\r\nimport type {\r\n  User,\r\n  LoginRequest,\r\n  RegisterRequest,\r\n  TokenResponse,\r\n} from \"../types/auth\";\r\n\r\ninterface AuthState {\r\n  user: User | null;\r\n  isAuthenticated: boolean;\r\n  isLoading: boolean;\r\n  error: string | null;\r\n}\r\n\r\ntype AuthAction =\r\n  | { type: \"AUTH_START\" }\r\n  | { type: \"AUTH_SUCCESS\"; payload: User }\r\n  | { type: \"AUTH_FAILURE\"; payload: string }\r\n  | { type: \"AUTH_LOGOUT\" }\r\n  | { type: \"AUTH_CLEAR_ERROR\" };\r\n\r\nconst initialState: AuthState = {\r\n  user: null,\r\n  isAuthenticated: false,\r\n  isLoading: false,\r\n  error: null,\r\n};\r\n\r\nfunction authReducer(state: AuthState, action: AuthAction): AuthState {\r\n  switch (action.type) {\r\n    case \"AUTH_START\":\r\n      return { ...state, isLoading: true, error: null };\r\n    case \"AUTH_SUCCESS\":\r\n      return {\r\n        ...state,\r\n        user: action.payload,\r\n        isAuthenticated: true,\r\n        isLoading: false,\r\n        error: null,\r\n      };\r\n    case \"AUTH_FAILURE\":\r\n      return {\r\n        ...state,\r\n        user: null,\r\n        isAuthenticated: false,\r\n        isLoading: false,\r\n        error: action.payload,\r\n      };\r\n    case \"AUTH_LOGOUT\":\r\n      return {\r\n        ...state,\r\n        user: null,\r\n        isAuthenticated: false,\r\n        isLoading: false,\r\n        error: null,\r\n      };\r\n    case \"AUTH_CLEAR_ERROR\":\r\n      return { ...state, error: null };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\ninterface AuthContextType extends AuthState {\r\n  login: (credentials: LoginRequest) => Promise<void>;\r\n  register: (data: RegisterRequest) => Promise<void>;\r\n  logout: () => void;\r\n  refreshAuth: () => Promise<void>;\r\n  clearError: () => void;\r\n  hasPermission: (permission: string) => boolean;\r\n  hasRole: (role: string) => boolean;\r\n  hasAIAccess: (level: \"basic\" | \"advanced\" | \"admin\") => boolean;\r\n}\r\n\r\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\r\n\r\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\r\n  const [state, dispatch] = useReducer(authReducer, initialState);\r\n\r\n  // Check for existing token on mount\r\n  useEffect(() => {\r\n    const token = localStorage.getItem(\"access_token\");\r\n    if (token) {\r\n      refreshAuth();\r\n    }\r\n  }, []);\r\n\r\n  // Auto-refresh token before expiration\r\n  useEffect(() => {\r\n    if (state.isAuthenticated) {\r\n      const token = localStorage.getItem(\"access_token\");\r\n      if (token) {\r\n        const payload = JSON.parse(atob(token.split(\".\")[1]));\r\n        const exp = payload.exp * 1000;\r\n        const now = Date.now();\r\n        const timeUntilExpiry = exp - now;\r\n\r\n        // Refresh 5 minutes before expiration\r\n        const refreshTime = Math.max(timeUntilExpiry - 5 * 60 * 1000, 0);\r\n\r\n        const timeout = setTimeout(() => {\r\n          refreshAuth();\r\n        }, refreshTime);\r\n\r\n        return () => clearTimeout(timeout);\r\n      }\r\n    }\r\n  }, [state.isAuthenticated]);\r\n\r\n  const login = async (credentials: LoginRequest) => {\r\n    dispatch({ type: \"AUTH_START\" });\r\n\r\n    try {\r\n      const response = await authApi.login(credentials);\r\n\r\n      // Store tokens\r\n      localStorage.setItem(\"access_token\", response.access_token);\r\n      localStorage.setItem(\"refresh_token\", response.refresh_token);\r\n\r\n      dispatch({ type: \"AUTH_SUCCESS\", payload: response.user });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : \"Login failed\";\r\n      dispatch({ type: \"AUTH_FAILURE\", payload: message });\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const register = async (data: RegisterRequest) => {\r\n    dispatch({ type: \"AUTH_START\" });\r\n\r\n    try {\r\n      await authApi.register(data);\r\n      // Registration successful, but user needs to verify email\r\n      dispatch({ type: \"AUTH_CLEAR_ERROR\" });\r\n    } catch (error) {\r\n      const message =\r\n        error instanceof Error ? error.message : \"Registration failed\";\r\n      dispatch({ type: \"AUTH_FAILURE\", payload: message });\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const logout = () => {\r\n    localStorage.removeItem(\"access_token\");\r\n    localStorage.removeItem(\"refresh_token\");\r\n    dispatch({ type: \"AUTH_LOGOUT\" });\r\n  };\r\n\r\n  const refreshAuth = async () => {\r\n    const refreshToken = localStorage.getItem(\"refresh_token\");\r\n    if (!refreshToken) {\r\n      logout();\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const response = await authApi.refresh(refreshToken);\r\n\r\n      localStorage.setItem(\"access_token\", response.access_token);\r\n      localStorage.setItem(\"refresh_token\", response.refresh_token);\r\n\r\n      dispatch({ type: \"AUTH_SUCCESS\", payload: response.user });\r\n    } catch (error) {\r\n      logout();\r\n    }\r\n  };\r\n\r\n  const clearError = () => {\r\n    dispatch({ type: \"AUTH_CLEAR_ERROR\" });\r\n  };\r\n\r\n  const hasPermission = (permission: string): boolean => {\r\n    return state.user?.permissions.includes(permission) ?? false;\r\n  };\r\n\r\n  const hasRole = (role: string): boolean => {\r\n    return state.user?.roles.includes(role) ?? false;\r\n  };\r\n\r\n  const hasAIAccess = (level: \"basic\" | \"advanced\" | \"admin\"): boolean => {\r\n    if (!state.user?.ai_access_level) return false;\r\n\r\n    const levels = { basic: 1, advanced: 2, admin: 3 };\r\n    const userLevel =\r\n      levels[state.user.ai_access_level as keyof typeof levels] ?? 0;\r\n    const requiredLevel = levels[level];\r\n\r\n    return userLevel >= requiredLevel;\r\n  };\r\n\r\n  const value: AuthContextType = {\r\n    ...state,\r\n    login,\r\n    register,\r\n    logout,\r\n    refreshAuth,\r\n    clearError,\r\n    hasPermission,\r\n    hasRole,\r\n    hasAIAccess,\r\n  };\r\n\r\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\r\n}\r\n\r\nexport function useAuth() {\r\n  const context = useContext(AuthContext);\r\n  if (context === undefined) {\r\n    throw new Error(\"useAuth must be used within an AuthProvider\");\r\n  }\r\n  return context;\r\n}\r\n```\r\n\r\n### 2. Route Protection Components\r\n\r\n**Protected Route and Permission Guards:**\r\n\r\n```typescript\r\n// apps/web/src/auth/components/ProtectedRoute.tsx\r\nimport React from \"react\";\r\nimport { Navigate, useLocation } from \"react-router-dom\";\r\nimport { useAuth } from \"../context\";\r\n\r\ninterface ProtectedRouteProps {\r\n  children: React.ReactNode;\r\n  roles?: string[];\r\n  permissions?: string[];\r\n  aiAccessLevel?: \"basic\" | \"advanced\" | \"admin\";\r\n  fallback?: React.ReactNode;\r\n}\r\n\r\nexport function ProtectedRoute({\r\n  children,\r\n  roles = [],\r\n  permissions = [],\r\n  aiAccessLevel,\r\n  fallback,\r\n}: ProtectedRouteProps) {\r\n  const { isAuthenticated, user, hasRole, hasPermission, hasAIAccess } =\r\n    useAuth();\r\n  const location = useLocation();\r\n\r\n  // Not authenticated\r\n  if (!isAuthenticated) {\r\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\r\n  }\r\n\r\n  // Check role requirements\r\n  if (roles.length > 0) {\r\n    const hasRequiredRole = roles.some((role) => hasRole(role));\r\n    if (!hasRequiredRole) {\r\n      return fallback || <Navigate to=\"/unauthorized\" replace />;\r\n    }\r\n  }\r\n\r\n  // Check permission requirements\r\n  if (permissions.length > 0) {\r\n    const hasRequiredPermission = permissions.some((permission) =>\r\n      hasPermission(permission)\r\n    );\r\n    if (!hasRequiredPermission) {\r\n      return fallback || <Navigate to=\"/unauthorized\" replace />;\r\n    }\r\n  }\r\n\r\n  // Check AI access level\r\n  if (aiAccessLevel && !hasAIAccess(aiAccessLevel)) {\r\n    return fallback || <Navigate to=\"/upgrade-ai-access\" replace />;\r\n  }\r\n\r\n  return <>{children}</>;\r\n}\r\n\r\n// Permission-based component rendering\r\ninterface PermissionGuardProps {\r\n  children: React.ReactNode;\r\n  permissions?: string[];\r\n  roles?: string[];\r\n  aiAccessLevel?: \"basic\" | \"advanced\" | \"admin\";\r\n  fallback?: React.ReactNode;\r\n  any?: boolean; // If true, user needs ANY of the permissions/roles (OR logic)\r\n}\r\n\r\nexport function PermissionGuard({\r\n  children,\r\n  permissions = [],\r\n  roles = [],\r\n  aiAccessLevel,\r\n  fallback = null,\r\n  any = false,\r\n}: PermissionGuardProps) {\r\n  const { hasRole, hasPermission, hasAIAccess } = useAuth();\r\n\r\n  const checkPermissions = () => {\r\n    const permissionChecks = permissions.map((permission) =>\r\n      hasPermission(permission)\r\n    );\r\n    const roleChecks = roles.map((role) => hasRole(role));\r\n    const aiCheck = aiAccessLevel ? hasAIAccess(aiAccessLevel) : true;\r\n\r\n    const allChecks = [...permissionChecks, ...roleChecks];\r\n\r\n    if (!aiCheck) return false;\r\n    if (allChecks.length === 0) return true;\r\n\r\n    return any ? allChecks.some(Boolean) : allChecks.every(Boolean);\r\n  };\r\n\r\n  return checkPermissions() ? <>{children}</> : <>{fallback}</>;\r\n}\r\n\r\n// AI access level hook\r\nexport function useAIAccess(\r\n  requiredLevel: \"basic\" | \"advanced\" | \"admin\" = \"basic\"\r\n) {\r\n  const { hasAIAccess, user } = useAuth();\r\n\r\n  return {\r\n    hasAccess: hasAIAccess(requiredLevel),\r\n    currentLevel: user?.ai_access_level,\r\n    canUpgrade: user?.ai_access_level !== \"admin\",\r\n  };\r\n}\r\n```\r\n\r\n---\r\n\r\n## OAuth Integration\r\n\r\n### 1. OAuth Service Implementation\r\n\r\n**Multi-Provider OAuth Support:**\r\n\r\n```python\r\n# apps/api/src/auth/services/oauth_service.py\r\nfrom typing import Dict, Any, Optional\r\nimport httpx\r\nfrom pydantic import BaseModel\r\nfrom ..exceptions import AuthenticationError\r\n\r\nclass OAuthUser(BaseModel):\r\n    id: str\r\n    email: str\r\n    username: Optional[str] = None\r\n    first_name: Optional[str] = None\r\n    last_name: Optional[str] = None\r\n    avatar_url: Optional[str] = None\r\n    raw_data: Dict[str, Any]\r\n\r\nclass OAuthProvider:\r\n    def __init__(self, config: Dict[str, Any]):\r\n        self.config = config\r\n\r\n    async def get_access_token(self, code: str, redirect_uri: str) -> str:\r\n        raise NotImplementedError\r\n\r\n    async def get_user_info(self, access_token: str) -> OAuthUser:\r\n        raise NotImplementedError\r\n\r\nclass GoogleOAuthProvider(OAuthProvider):\r\n    def __init__(self, config: Dict[str, Any]):\r\n        super().__init__(config)\r\n        self.client_id = config[\"client_id\"]\r\n        self.client_secret = config[\"client_secret\"]\r\n\r\n    async def get_access_token(self, code: str, redirect_uri: str) -> str:\r\n        async with httpx.AsyncClient() as client:\r\n            response = await client.post(\r\n                \"https://oauth2.googleapis.com/token\",\r\n                data={\r\n                    \"code\": code,\r\n                    \"client_id\": self.client_id,\r\n                    \"client_secret\": self.client_secret,\r\n                    \"redirect_uri\": redirect_uri,\r\n                    \"grant_type\": \"authorization_code\"\r\n                }\r\n            )\r\n\r\n            if response.status_code != 200:\r\n                raise AuthenticationError(\"Failed to exchange code for token\")\r\n\r\n            return response.json()[\"access_token\"]\r\n\r\n    async def get_user_info(self, access_token: str) -> OAuthUser:\r\n        async with httpx.AsyncClient() as client:\r\n            response = await client.get(\r\n                \"https://www.googleapis.com/oauth2/v2/userinfo\",\r\n                headers={\"Authorization\": f\"Bearer {access_token}\"}\r\n            )\r\n\r\n            if response.status_code != 200:\r\n                raise AuthenticationError(\"Failed to get user info\")\r\n\r\n            data = response.json()\r\n\r\n            return OAuthUser(\r\n                id=data[\"id\"],\r\n                email=data[\"email\"],\r\n                username=data.get(\"email\"),  # Google doesn't provide username\r\n                first_name=data.get(\"given_name\"),\r\n                last_name=data.get(\"family_name\"),\r\n                avatar_url=data.get(\"picture\"),\r\n                raw_data=data\r\n            )\r\n\r\nclass GitHubOAuthProvider(OAuthProvider):\r\n    def __init__(self, config: Dict[str, Any]):\r\n        super().__init__(config)\r\n        self.client_id = config[\"client_id\"]\r\n        self.client_secret = config[\"client_secret\"]\r\n\r\n    async def get_access_token(self, code: str, redirect_uri: str) -> str:\r\n        async with httpx.AsyncClient() as client:\r\n            response = await client.post(\r\n                \"https://github.com/login/oauth/access_token\",\r\n                data={\r\n                    \"code\": code,\r\n                    \"client_id\": self.client_id,\r\n                    \"client_secret\": self.client_secret,\r\n                    \"redirect_uri\": redirect_uri\r\n                },\r\n                headers={\"Accept\": \"application/json\"}\r\n            )\r\n\r\n            if response.status_code != 200:\r\n                raise AuthenticationError(\"Failed to exchange code for token\")\r\n\r\n            return response.json()[\"access_token\"]\r\n\r\n    async def get_user_info(self, access_token: str) -> OAuthUser:\r\n        async with httpx.AsyncClient() as client:\r\n            # Get user info\r\n            user_response = await client.get(\r\n                \"https://api.github.com/user\",\r\n                headers={\"Authorization\": f\"Bearer {access_token}\"}\r\n            )\r\n\r\n            if user_response.status_code != 200:\r\n                raise AuthenticationError(\"Failed to get user info\")\r\n\r\n            user_data = user_response.json()\r\n\r\n            # Get primary email\r\n            email_response = await client.get(\r\n                \"https://api.github.com/user/emails\",\r\n                headers={\"Authorization\": f\"Bearer {access_token}\"}\r\n            )\r\n\r\n            email = user_data.get(\"email\")\r\n            if not email and email_response.status_code == 200:\r\n                emails = email_response.json()\r\n                primary_email = next((e for e in emails if e[\"primary\"]), None)\r\n                if primary_email:\r\n                    email = primary_email[\"email\"]\r\n\r\n            return OAuthUser(\r\n                id=str(user_data[\"id\"]),\r\n                email=email,\r\n                username=user_data.get(\"login\"),\r\n                first_name=user_data.get(\"name\", \"\").split(\" \")[0] if user_data.get(\"name\") else None,\r\n                last_name=\" \".join(user_data.get(\"name\", \"\").split(\" \")[1:]) if user_data.get(\"name\") and len(user_data[\"name\"].split(\" \")) > 1 else None,\r\n                avatar_url=user_data.get(\"avatar_url\"),\r\n                raw_data=user_data\r\n            )\r\n\r\nclass OAuthService:\r\n    def __init__(self, config: Dict[str, Any]):\r\n        self.providers = {}\r\n\r\n        if \"google\" in config:\r\n            self.providers[\"google\"] = GoogleOAuthProvider(config[\"google\"])\r\n\r\n        if \"github\" in config:\r\n            self.providers[\"github\"] = GitHubOAuthProvider(config[\"github\"])\r\n\r\n    async def get_user_info(self, provider: str, code: str, redirect_uri: str) -> OAuthUser:\r\n        if provider not in self.providers:\r\n            raise AuthenticationError(f\"OAuth provider {provider} not configured\")\r\n\r\n        oauth_provider = self.providers[provider]\r\n        access_token = await oauth_provider.get_access_token(code, redirect_uri)\r\n        return await oauth_provider.get_user_info(access_token)\r\n```\r\n\r\n### 2. OAuth Routes\r\n\r\n**FastAPI OAuth Endpoints:**\r\n\r\n```python\r\n# apps/api/src/auth/routes/oauth.py\r\nfrom fastapi import APIRouter, HTTPException, status, Query\r\nfrom pydantic import BaseModel\r\nfrom typing import Optional\r\n\r\nfrom ..services.auth_service import AuthService, TokenResponse\r\nfrom ..services.oauth_service import OAuthService\r\nfrom ..exceptions import AuthenticationError\r\n\r\nrouter = APIRouter(prefix=\"/oauth\", tags=[\"oauth\"])\r\n\r\nclass OAuthCallbackRequest(BaseModel):\r\n    code: str\r\n    redirect_uri: str\r\n    state: Optional[str] = None\r\n\r\n@router.get(\"/{provider}/authorize\")\r\nasync def oauth_authorize(\r\n    provider: str,\r\n    redirect_uri: str = Query(...),\r\n    state: Optional[str] = Query(None)\r\n):\r\n    \"\"\"Get OAuth authorization URL\"\"\"\r\n\r\n    authorization_urls = {\r\n        \"google\": \"https://accounts.google.com/oauth2/v2/auth\",\r\n        \"github\": \"https://github.com/login/oauth/authorize\",\r\n    }\r\n\r\n    if provider not in authorization_urls:\r\n        raise HTTPException(\r\n            status_code=status.HTTP_400_BAD_REQUEST,\r\n            detail=f\"Unsupported OAuth provider: {provider}\"\r\n        )\r\n\r\n    # Get client ID from config\r\n    oauth_config = app.state.config.get(\"oauth\", {}).get(provider, {})\r\n    client_id = oauth_config.get(\"client_id\")\r\n\r\n    if not client_id:\r\n        raise HTTPException(\r\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\r\n            detail=f\"OAuth provider {provider} not properly configured\"\r\n        )\r\n\r\n    # Build authorization URL\r\n    base_url = authorization_urls[provider]\r\n    scopes = {\r\n        \"google\": \"openid email profile\",\r\n        \"github\": \"user:email\"\r\n    }\r\n\r\n    params = {\r\n        \"client_id\": client_id,\r\n        \"redirect_uri\": redirect_uri,\r\n        \"scope\": scopes.get(provider, \"\"),\r\n        \"response_type\": \"code\"\r\n    }\r\n\r\n    if state:\r\n        params[\"state\"] = state\r\n\r\n    query_string = \"&\".join([f\"{k}={v}\" for k, v in params.items()])\r\n    authorization_url = f\"{base_url}?{query_string}\"\r\n\r\n    return {\"authorization_url\": authorization_url}\r\n\r\n@router.post(\"/{provider}/callback\")\r\nasync def oauth_callback(\r\n    provider: str,\r\n    request: OAuthCallbackRequest,\r\n    auth_service: AuthService = Depends(get_auth_service)\r\n) -> TokenResponse:\r\n    \"\"\"Handle OAuth callback and authenticate user\"\"\"\r\n\r\n    try:\r\n        return await auth_service.oauth_login(\r\n            provider=provider,\r\n            code=request.code,\r\n            redirect_uri=request.redirect_uri\r\n        )\r\n    except AuthenticationError as e:\r\n        raise HTTPException(\r\n            status_code=status.HTTP_400_BAD_REQUEST,\r\n            detail=str(e)\r\n        )\r\n\r\n@router.post(\"/{provider}/link\")\r\nasync def link_oauth_account(\r\n    provider: str,\r\n    request: OAuthCallbackRequest,\r\n    current_user: User = Depends(get_current_active_user),\r\n    auth_service: AuthService = Depends(get_auth_service)\r\n):\r\n    \"\"\"Link OAuth account to existing user\"\"\"\r\n\r\n    try:\r\n        oauth_service = OAuthService(app.state.config.get(\"oauth\", {}))\r\n        oauth_user = await oauth_service.get_user_info(\r\n            provider, request.code, request.redirect_uri\r\n        )\r\n\r\n        # Check if OAuth account is already linked to another user\r\n        existing_user = await User.find_one(\r\n            User.auth.provider == provider,\r\n            User.auth.provider_id == oauth_user.id\r\n        )\r\n\r\n        if existing_user and existing_user.id != current_user.id:\r\n            raise HTTPException(\r\n                status_code=status.HTTP_400_BAD_REQUEST,\r\n                detail=\"This account is already linked to another user\"\r\n            )\r\n\r\n        # Link account\r\n        current_user.auth.provider_data[provider] = {\r\n            \"provider_id\": oauth_user.id,\r\n            \"email\": oauth_user.email,\r\n            \"username\": oauth_user.username,\r\n            \"linked_at\": datetime.now(timezone.utc).isoformat()\r\n        }\r\n\r\n        await current_user.save()\r\n\r\n        return {\"message\": f\"{provider.title()} account linked successfully\"}\r\n\r\n    except AuthenticationError as e:\r\n        raise HTTPException(\r\n            status_code=status.HTTP_400_BAD_REQUEST,\r\n            detail=str(e)\r\n        )\r\n\r\n@router.delete(\"/{provider}/unlink\")\r\nasync def unlink_oauth_account(\r\n    provider: str,\r\n    current_user: User = Depends(get_current_active_user)\r\n):\r\n    \"\"\"Unlink OAuth account from user\"\"\"\r\n\r\n    if provider in current_user.auth.provider_data:\r\n        del current_user.auth.provider_data[provider]\r\n        await current_user.save()\r\n\r\n        return {\"message\": f\"{provider.title()} account unlinked successfully\"}\r\n    else:\r\n        raise HTTPException(\r\n            status_code=status.HTTP_400_BAD_REQUEST,\r\n            detail=f\"No {provider} account linked\"\r\n        )\r\n```\r\n\r\n---\r\n\r\n## AI-Aware Authentication\r\n\r\n### 1. AI Context Integration\r\n\r\n**User AI Context and Personalization:**\r\n\r\n```python\r\n# apps/api/src/auth/ai_integration.py\r\nfrom typing import Dict, Any, Optional, List\r\nfrom datetime import datetime, timezone\r\n\r\nclass AIUserContext:\r\n    \"\"\"Manage user-specific AI context and preferences\"\"\"\r\n\r\n    def __init__(self, user: User):\r\n        self.user = user\r\n\r\n    def get_ai_context(self) -> Dict[str, Any]:\r\n        \"\"\"Get user's AI interaction context\"\"\"\r\n        return {\r\n            \"user_id\": str(self.user.id),\r\n            \"preferences\": self.user.ai_preferences,\r\n            \"access_level\": self.get_access_level(),\r\n            \"usage_stats\": self.get_usage_stats(),\r\n            \"personalization\": self.get_personalization_data()\r\n        }\r\n\r\n    def get_access_level(self) -> str:\r\n        \"\"\"Get user's AI access level based on roles\"\"\"\r\n        access_levels = [\"basic\", \"advanced\", \"admin\"]\r\n        highest_level = \"basic\"\r\n\r\n        for role_name in self.user.roles:\r\n            # This would be implemented with role lookup\r\n            # For now, simplified logic\r\n            if \"admin\" in role_name:\r\n                highest_level = \"admin\"\r\n            elif \"premium\" in role_name and highest_level != \"admin\":\r\n                highest_level = \"advanced\"\r\n\r\n        return highest_level\r\n\r\n    def get_usage_stats(self) -> Dict[str, Any]:\r\n        \"\"\"Get user's AI usage statistics\"\"\"\r\n        # This would integrate with usage tracking system\r\n        return self.user.ai_context.get(\"usage_stats\", {\r\n            \"daily_requests\": 0,\r\n            \"monthly_requests\": 0,\r\n            \"total_requests\": 0,\r\n            \"last_request_at\": None\r\n        })\r\n\r\n    def get_personalization_data(self) -> Dict[str, Any]:\r\n        \"\"\"Get user's AI personalization preferences\"\"\"\r\n        return self.user.ai_preferences.get(\"personalization\", {\r\n            \"preferred_model\": \"llama3.1\",\r\n            \"preferred_provider\": \"ollama\",\r\n            \"temperature\": 0.7,\r\n            \"max_tokens\": 1000,\r\n            \"system_prompt_additions\": [],\r\n            \"conversation_style\": \"helpful\",\r\n            \"language\": \"en\"\r\n        })\r\n\r\n    async def update_ai_preferences(self, preferences: Dict[str, Any]) -> None:\r\n        \"\"\"Update user's AI preferences\"\"\"\r\n        self.user.ai_preferences.update(preferences)\r\n        self.user.updated_at = datetime.now(timezone.utc)\r\n        await self.user.save()\r\n\r\n    async def record_ai_usage(self, provider: str, model: str, tokens_used: int) -> None:\r\n        \"\"\"Record AI usage for quota tracking\"\"\"\r\n        usage_stats = self.user.ai_context.get(\"usage_stats\", {})\r\n\r\n        # Update usage statistics\r\n        usage_stats[\"total_requests\"] = usage_stats.get(\"total_requests\", 0) + 1\r\n        usage_stats[\"daily_requests\"] = usage_stats.get(\"daily_requests\", 0) + 1\r\n        usage_stats[\"monthly_requests\"] = usage_stats.get(\"monthly_requests\", 0) + 1\r\n        usage_stats[\"last_request_at\"] = datetime.now(timezone.utc).isoformat()\r\n        usage_stats[\"tokens_used\"] = usage_stats.get(\"tokens_used\", 0) + tokens_used\r\n\r\n        # Track per-provider usage\r\n        provider_stats = usage_stats.get(\"by_provider\", {})\r\n        provider_stats[provider] = provider_stats.get(provider, 0) + 1\r\n        usage_stats[\"by_provider\"] = provider_stats\r\n\r\n        self.user.ai_context[\"usage_stats\"] = usage_stats\r\n        await self.user.save()\r\n\r\n    def check_ai_quota(self) -> Dict[str, Any]:\r\n        \"\"\"Check if user has exceeded AI usage quotas\"\"\"\r\n        usage_stats = self.get_usage_stats()\r\n        access_level = self.get_access_level()\r\n\r\n        # Get quota limits based on access level\r\n        quotas = {\r\n            \"basic\": {\"daily\": 100, \"monthly\": 1000},\r\n            \"advanced\": {\"daily\": 1000, \"monthly\": 10000},\r\n            \"admin\": {\"daily\": None, \"monthly\": None}  # Unlimited\r\n        }\r\n\r\n        level_quotas = quotas.get(access_level, quotas[\"basic\"])\r\n\r\n        return {\r\n            \"access_level\": access_level,\r\n            \"daily_used\": usage_stats.get(\"daily_requests\", 0),\r\n            \"daily_limit\": level_quotas[\"daily\"],\r\n            \"daily_remaining\": (\r\n                level_quotas[\"daily\"] - usage_stats.get(\"daily_requests\", 0)\r\n                if level_quotas[\"daily\"] else None\r\n            ),\r\n            \"monthly_used\": usage_stats.get(\"monthly_requests\", 0),\r\n            \"monthly_limit\": level_quotas[\"monthly\"],\r\n            \"monthly_remaining\": (\r\n                level_quotas[\"monthly\"] - usage_stats.get(\"monthly_requests\", 0)\r\n                if level_quotas[\"monthly\"] else None\r\n            ),\r\n            \"can_make_request\": (\r\n                (level_quotas[\"daily\"] is None or usage_stats.get(\"daily_requests\", 0) < level_quotas[\"daily\"]) and\r\n                (level_quotas[\"monthly\"] is None or usage_stats.get(\"monthly_requests\", 0) < level_quotas[\"monthly\"])\r\n            )\r\n        }\r\n```\r\n\r\n---\r\n\r\n## Configuration Integration\r\n\r\n### 1. Farm Config Auth Settings\r\n\r\n**TypeScript Configuration for Authentication:**\r\n\r\n```typescript\r\n// farm.config.ts - Authentication configuration\r\nimport { defineConfig } from \"@farm/core\";\r\n\r\nexport default defineConfig({\r\n  auth: {\r\n    // JWT configuration\r\n    jwt: {\r\n      secret: process.env.JWT_SECRET || \"your-super-secret-jwt-key\",\r\n      algorithm: \"HS256\",\r\n      accessTokenExpire: 15, // minutes\r\n      refreshTokenExpire: 7, // days\r\n    },\r\n\r\n    // OAuth providers\r\n    oauth: {\r\n      google: {\r\n        enabled: true,\r\n        clientId: process.env.GOOGLE_CLIENT_ID,\r\n        clientSecret: process.env.GOOGLE_CLIENT_SECRET,\r\n        scope: \"openid email profile\",\r\n      },\r\n      github: {\r\n        enabled: true,\r\n        clientId: process.env.GITHUB_CLIENT_ID,\r\n        clientSecret: process.env.GITHUB_CLIENT_SECRET,\r\n        scope: \"user:email\",\r\n      },\r\n    },\r\n\r\n    // Authentication options\r\n    features: {\r\n      emailVerification: true,\r\n      twoFactorAuth: false,\r\n      passwordReset: true,\r\n      accountLocking: true,\r\n      sessionManagement: true,\r\n    },\r\n\r\n    // Password policy\r\n    password: {\r\n      minLength: 8,\r\n      requireUppercase: true,\r\n      requireLowercase: true,\r\n      requireNumbers: true,\r\n      requireSpecialChars: false,\r\n      maxAge: 90, // days\r\n    },\r\n\r\n    // Account security\r\n    security: {\r\n      maxFailedLogins: 5,\r\n      lockoutDuration: 30, // minutes\r\n      sessionTimeout: 24, // hours\r\n      enforceUniquePasswords: 5, // last N passwords\r\n    },\r\n\r\n    // AI integration\r\n    ai: {\r\n      quotas: {\r\n        basic: {\r\n          daily: 100,\r\n          monthly: 1000,\r\n        },\r\n        advanced: {\r\n          daily: 1000,\r\n          monthly: 10000,\r\n        },\r\n        admin: {\r\n          daily: null, // unlimited\r\n          monthly: null,\r\n        },\r\n      },\r\n      defaultModel: \"llama3.1\",\r\n      defaultProvider: \"ollama\",\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n---\r\n\r\n_Status: ✅ Completed - Ready for implementation_\r\n\r\nThis authentication system provides:\r\n\r\n- **Comprehensive user management** with roles, permissions, and AI context\r\n- **Multiple authentication methods** (JWT, OAuth, SAML-ready)\r\n- **Type-safe full-stack integration** with React context and hooks\r\n- **AI-aware authentication** with usage quotas and personalization\r\n- **Flexible RBAC system** with hierarchical roles and permissions\r\n- **Production-ready security** with proper token handling and middleware\r\n- **OAuth integration** with major providers (Google, GitHub, extensible)\r\n- **Route protection** with granular permission controls\r\n",
      "excerpt": "The FARM authentication system provides a comprehensive, plugin-based auth solution with JWT tokens, OAuth providers, role-based access control (RBAC), and seam...",
      "category": "architectural-sketches-detailed/phase2",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "farm",
        "typescript",
        "python"
      ],
      "lastModified": "2025-06-12T21:57:32.778Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase2",
        "Auth_authorization_flow"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Authentication & Authorization Flow",
          "id": "authentication-authorization-flow"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "High-Level Authentication Architecture",
          "id": "high-level-authentication-architecture"
        },
        {
          "level": 2,
          "text": "Core Authentication Models",
          "id": "core-authentication-models"
        },
        {
          "level": 3,
          "text": "1. User Model with Comprehensive Auth Data",
          "id": "1-user-model-with-comprehensive-auth-data"
        },
        {
          "level": 1,
          "text": "apps/api/src/auth/models/user.py",
          "id": "appsapisrcauthmodelsuserpy"
        },
        {
          "level": 3,
          "text": "2. Role and Permission Models",
          "id": "2-role-and-permission-models"
        },
        {
          "level": 1,
          "text": "apps/api/src/auth/models/rbac.py",
          "id": "appsapisrcauthmodelsrbacpy"
        },
        {
          "level": 1,
          "text": "Default system roles and permissions",
          "id": "default-system-roles-and-permissions"
        },
        {
          "level": 2,
          "text": "Authentication Service Layer",
          "id": "authentication-service-layer"
        },
        {
          "level": 3,
          "text": "1. Core Authentication Service",
          "id": "1-core-authentication-service"
        },
        {
          "level": 1,
          "text": "apps/api/src/auth/services/auth_service.py",
          "id": "appsapisrcauthservicesauth_servicepy"
        },
        {
          "level": 2,
          "text": "FastAPI Integration & Middleware",
          "id": "fastapi-integration-middleware"
        },
        {
          "level": 3,
          "text": "1. Authentication Middleware",
          "id": "1-authentication-middleware"
        },
        {
          "level": 1,
          "text": "apps/api/src/auth/middleware.py",
          "id": "appsapisrcauthmiddlewarepy"
        },
        {
          "level": 3,
          "text": "2. Authentication Dependencies",
          "id": "2-authentication-dependencies"
        },
        {
          "level": 1,
          "text": "apps/api/src/auth/dependencies.py",
          "id": "appsapisrcauthdependenciespy"
        },
        {
          "level": 1,
          "text": "Pre-configured dependency instances",
          "id": "pre-configured-dependency-instances"
        },
        {
          "level": 2,
          "text": "Frontend Authentication Integration",
          "id": "frontend-authentication-integration"
        },
        {
          "level": 3,
          "text": "1. Authentication Context & Hooks",
          "id": "1-authentication-context-hooks"
        },
        {
          "level": 3,
          "text": "2. Route Protection Components",
          "id": "2-route-protection-components"
        },
        {
          "level": 2,
          "text": "OAuth Integration",
          "id": "oauth-integration"
        },
        {
          "level": 3,
          "text": "1. OAuth Service Implementation",
          "id": "1-oauth-service-implementation"
        },
        {
          "level": 1,
          "text": "apps/api/src/auth/services/oauth_service.py",
          "id": "appsapisrcauthservicesoauth_servicepy"
        },
        {
          "level": 3,
          "text": "2. OAuth Routes",
          "id": "2-oauth-routes"
        },
        {
          "level": 1,
          "text": "apps/api/src/auth/routes/oauth.py",
          "id": "appsapisrcauthroutesoauthpy"
        },
        {
          "level": 2,
          "text": "AI-Aware Authentication",
          "id": "ai-aware-authentication"
        },
        {
          "level": 3,
          "text": "1. AI Context Integration",
          "id": "1-ai-context-integration"
        },
        {
          "level": 1,
          "text": "apps/api/src/auth/ai_integration.py",
          "id": "appsapisrcauthai_integrationpy"
        },
        {
          "level": 2,
          "text": "Configuration Integration",
          "id": "configuration-integration"
        },
        {
          "level": 3,
          "text": "1. Farm Config Auth Settings",
          "id": "1-farm-config-auth-settings"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase2-build_system_architecture",
      "title": "Build_system_architecture",
      "url": "/architectural-sketches-detailed/phase2/build_system_architecture",
      "content": "# Build System Architecture\r\n\r\n## Overview\r\n\r\nThe FARM build system provides a comprehensive, multi-stage build pipeline that optimizes React frontends, FastAPI backends, and AI models for production deployment. It features intelligent caching, asset optimization, Docker containerization, and seamless integration with the code generation pipeline and plugin system.\r\n\r\n---\r\n\r\n## High-Level Build Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Build Pipeline                         │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │  Frontend   │  │  Backend    │  │  AI Models  │  │ Plugins │ │\r\n│  │   Build     │  │   Build     │  │   Optimize  │  │ Process │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │    Vite     │  │   Docker    │  │    Asset    │  │  Code   │ │\r\n│  │ Bundling    │  │ Containers  │  │Optimization │  │   Gen   │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │   Build     │  │ Environment │  │ Performance │  │Artifact │ │\r\n│  │   Cache     │  │ Variables   │  │ Monitoring  │  │ Upload  │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Build Pipeline\r\n\r\n### 1. Build Orchestrator\r\n\r\n**Central Build Management:**\r\n\r\n```typescript\r\n// packages/core/src/build/orchestrator.ts\r\nimport { BuildConfig, BuildTarget, BuildArtifact } from \"./types\";\r\nimport { FrontendBuilder } from \"./builders/frontend\";\r\nimport { BackendBuilder } from \"./builders/backend\";\r\nimport { AIModelOptimizer } from \"./builders/ai-optimizer\";\r\nimport { DockerBuilder } from \"./builders/docker\";\r\nimport { PluginBuilder } from \"./builders/plugin\";\r\n\r\nexport class BuildOrchestrator {\r\n  private config: BuildConfig;\r\n  private builders: Map<string, Builder> = new Map();\r\n  private buildCache: BuildCache;\r\n  private artifacts: BuildArtifact[] = [];\r\n\r\n  constructor(config: BuildConfig) {\r\n    this.config = config;\r\n    this.buildCache = new BuildCache(config.cacheDir);\r\n    this.initializeBuilders();\r\n  }\r\n\r\n  private initializeBuilders(): void {\r\n    this.builders.set(\"frontend\", new FrontendBuilder(this.config));\r\n    this.builders.set(\"backend\", new BackendBuilder(this.config));\r\n    this.builders.set(\"ai-models\", new AIModelOptimizer(this.config));\r\n    this.builders.set(\"docker\", new DockerBuilder(this.config));\r\n    this.builders.set(\"plugins\", new PluginBuilder(this.config));\r\n  }\r\n\r\n  async build(targets: BuildTarget[] = [\"all\"]): Promise<BuildResult> {\r\n    const startTime = Date.now();\r\n    const buildId = this.generateBuildId();\r\n\r\n    console.log(`🏗️  Starting FARM build (${buildId})`);\r\n    console.log(`🎯 Targets: ${targets.join(\", \")}`);\r\n\r\n    try {\r\n      // Pre-build phase\r\n      await this.preBuild();\r\n\r\n      // Determine build order and dependencies\r\n      const buildPlan = this.createBuildPlan(targets);\r\n\r\n      // Execute build stages\r\n      for (const stage of buildPlan.stages) {\r\n        await this.executeBuildStage(stage, buildId);\r\n      }\r\n\r\n      // Post-build phase\r\n      const result = await this.postBuild(buildId);\r\n\r\n      const duration = Date.now() - startTime;\r\n      console.log(`✅ Build completed in ${duration}ms`);\r\n\r\n      return {\r\n        success: true,\r\n        buildId,\r\n        duration,\r\n        artifacts: this.artifacts,\r\n        metrics: result.metrics,\r\n      };\r\n    } catch (error) {\r\n      const duration = Date.now() - startTime;\r\n      console.error(`❌ Build failed after ${duration}ms:`, error.message);\r\n\r\n      return {\r\n        success: false,\r\n        buildId,\r\n        duration,\r\n        error: error.message,\r\n        artifacts: [],\r\n      };\r\n    }\r\n  }\r\n\r\n  private async preBuild(): Promise<void> {\r\n    console.log(\"🔧 Pre-build phase\");\r\n\r\n    // Generate types from backend models\r\n    await this.generateTypes();\r\n\r\n    // Process plugins\r\n    await this.processPlugins();\r\n\r\n    // Validate configuration\r\n    await this.validateBuildConfig();\r\n\r\n    // Clean previous build artifacts\r\n    await this.cleanBuildDir();\r\n  }\r\n\r\n  private async generateTypes(): Promise<void> {\r\n    console.log(\"📝 Generating TypeScript types...\");\r\n\r\n    const typeGenerator = new TypeGenerator(this.config);\r\n    await typeGenerator.generateFromBackend();\r\n\r\n    console.log(\"✅ Types generated successfully\");\r\n  }\r\n\r\n  private async processPlugins(): Promise<void> {\r\n    console.log(\"🔌 Processing build plugins...\");\r\n\r\n    const pluginBuilder = this.builders.get(\"plugins\") as PluginBuilder;\r\n    await pluginBuilder.processBuildPlugins();\r\n\r\n    console.log(\"✅ Plugins processed\");\r\n  }\r\n\r\n  private createBuildPlan(targets: BuildTarget[]): BuildPlan {\r\n    const stages: BuildStage[] = [];\r\n\r\n    // Determine which components to build\r\n    const shouldBuildFrontend =\r\n      targets.includes(\"all\") || targets.includes(\"frontend\");\r\n    const shouldBuildBackend =\r\n      targets.includes(\"all\") || targets.includes(\"backend\");\r\n    const shouldBuildAI = targets.includes(\"all\") || targets.includes(\"ai\");\r\n    const shouldBuildDocker =\r\n      targets.includes(\"all\") || targets.includes(\"docker\");\r\n\r\n    // Stage 1: Parallel builds\r\n    const parallelBuilds: BuildTask[] = [];\r\n\r\n    if (shouldBuildBackend) {\r\n      parallelBuilds.push({\r\n        name: \"backend\",\r\n        builder: \"backend\",\r\n        dependencies: [],\r\n        parallel: true,\r\n      });\r\n    }\r\n\r\n    if (shouldBuildAI) {\r\n      parallelBuilds.push({\r\n        name: \"ai-models\",\r\n        builder: \"ai-models\",\r\n        dependencies: [],\r\n        parallel: true,\r\n      });\r\n    }\r\n\r\n    if (parallelBuilds.length > 0) {\r\n      stages.push({\r\n        name: \"parallel-builds\",\r\n        tasks: parallelBuilds,\r\n        parallel: true,\r\n      });\r\n    }\r\n\r\n    // Stage 2: Frontend build (depends on backend types)\r\n    if (shouldBuildFrontend) {\r\n      stages.push({\r\n        name: \"frontend-build\",\r\n        tasks: [\r\n          {\r\n            name: \"frontend\",\r\n            builder: \"frontend\",\r\n            dependencies: shouldBuildBackend ? [\"backend\"] : [],\r\n            parallel: false,\r\n          },\r\n        ],\r\n        parallel: false,\r\n      });\r\n    }\r\n\r\n    // Stage 3: Docker containerization\r\n    if (shouldBuildDocker) {\r\n      stages.push({\r\n        name: \"containerization\",\r\n        tasks: [\r\n          {\r\n            name: \"docker\",\r\n            builder: \"docker\",\r\n            dependencies: [\"frontend\", \"backend\"].filter(\r\n              (dep) =>\r\n                (dep === \"frontend\" && shouldBuildFrontend) ||\r\n                (dep === \"backend\" && shouldBuildBackend)\r\n            ),\r\n            parallel: false,\r\n          },\r\n        ],\r\n        parallel: false,\r\n      });\r\n    }\r\n\r\n    return { stages };\r\n  }\r\n\r\n  private async executeBuildStage(\r\n    stage: BuildStage,\r\n    buildId: string\r\n  ): Promise<void> {\r\n    console.log(`\\n📋 Stage: ${stage.name}`);\r\n\r\n    if (stage.parallel) {\r\n      // Execute tasks in parallel\r\n      const promises = stage.tasks.map((task) =>\r\n        this.executeBuildTask(task, buildId)\r\n      );\r\n      await Promise.all(promises);\r\n    } else {\r\n      // Execute tasks sequentially\r\n      for (const task of stage.tasks) {\r\n        await this.executeBuildTask(task, buildId);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async executeBuildTask(\r\n    task: BuildTask,\r\n    buildId: string\r\n  ): Promise<void> {\r\n    const startTime = Date.now();\r\n    console.log(`🔨 Building ${task.name}...`);\r\n\r\n    try {\r\n      const builder = this.builders.get(task.builder);\r\n      if (!builder) {\r\n        throw new Error(`Builder ${task.builder} not found`);\r\n      }\r\n\r\n      // Check cache\r\n      const cacheKey = await this.buildCache.getCacheKey(task);\r\n      const cached = await this.buildCache.get(cacheKey);\r\n\r\n      if (cached && !this.config.forceRebuild) {\r\n        console.log(`💾 Using cached build for ${task.name}`);\r\n        this.artifacts.push(...cached.artifacts);\r\n        return;\r\n      }\r\n\r\n      // Execute build\r\n      const result = await builder.build(task, buildId);\r\n\r\n      // Cache result\r\n      await this.buildCache.set(cacheKey, result);\r\n\r\n      // Store artifacts\r\n      this.artifacts.push(...result.artifacts);\r\n\r\n      const duration = Date.now() - startTime;\r\n      console.log(`✅ ${task.name} built in ${duration}ms`);\r\n    } catch (error) {\r\n      console.error(`❌ Failed to build ${task.name}:`, error.message);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async postBuild(buildId: string): Promise<PostBuildResult> {\r\n    console.log(\"\\n🎁 Post-build phase\");\r\n\r\n    // Optimize artifacts\r\n    await this.optimizeArtifacts();\r\n\r\n    // Generate build manifest\r\n    const manifest = await this.generateBuildManifest(buildId);\r\n\r\n    // Upload artifacts (if configured)\r\n    await this.uploadArtifacts();\r\n\r\n    // Generate deployment scripts\r\n    await this.generateDeploymentScripts();\r\n\r\n    return {\r\n      manifest,\r\n      metrics: await this.collectBuildMetrics(),\r\n    };\r\n  }\r\n\r\n  private generateBuildId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\r\n    const hash = Math.random().toString(36).substring(2, 8);\r\n    return `build-${timestamp}-${hash}`;\r\n  }\r\n}\r\n```\r\n\r\n### 2. Frontend Builder\r\n\r\n**Vite-Powered Frontend Build:**\r\n\r\n```typescript\r\n// packages/core/src/build/builders/frontend.ts\r\nimport { build as viteBuild, mergeConfig } from \"vite\";\r\nimport react from \"@vitejs/plugin-react\";\r\nimport { visualizer } from \"rollup-plugin-visualizer\";\r\nimport { BuildConfig, BuildTask, BuildResult } from \"../types\";\r\n\r\nexport class FrontendBuilder implements Builder {\r\n  private config: BuildConfig;\r\n\r\n  constructor(config: BuildConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  async build(task: BuildTask, buildId: string): Promise<BuildResult> {\r\n    const startTime = Date.now();\r\n\r\n    // Create Vite configuration\r\n    const viteConfig = await this.createViteConfig();\r\n\r\n    // Execute Vite build\r\n    const buildResult = await viteBuild(viteConfig);\r\n\r\n    // Analyze bundle\r\n    const bundleAnalysis = await this.analyzeBundleSize();\r\n\r\n    // Generate build artifacts\r\n    const artifacts = await this.generateArtifacts(buildResult, bundleAnalysis);\r\n\r\n    return {\r\n      success: true,\r\n      duration: Date.now() - startTime,\r\n      artifacts,\r\n      metadata: {\r\n        bundleSize: bundleAnalysis.totalSize,\r\n        chunkCount: bundleAnalysis.chunks.length,\r\n        assetCount: bundleAnalysis.assets.length,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async createViteConfig(): Promise<any> {\r\n    const baseConfig = {\r\n      build: {\r\n        outDir: this.config.outputDir + \"/frontend\",\r\n        sourcemap: this.config.environment !== \"production\",\r\n        minify: this.config.environment === \"production\",\r\n        target: \"es2020\",\r\n        rollupOptions: {\r\n          output: {\r\n            manualChunks: this.getChunkingStrategy(),\r\n          },\r\n        },\r\n      },\r\n      plugins: [\r\n        react(),\r\n        this.createPluginConfigGenerator(),\r\n        this.createAssetOptimizer(),\r\n        ...(this.config.analyzer\r\n          ? [\r\n              visualizer({\r\n                filename: `${this.config.outputDir}/bundle-analysis.html`,\r\n                open: false,\r\n                gzipSize: true,\r\n              }),\r\n            ]\r\n          : []),\r\n      ],\r\n      define: {\r\n        __BUILD_VERSION__: JSON.stringify(this.config.version),\r\n        __BUILD_TIMESTAMP__: JSON.stringify(new Date().toISOString()),\r\n        __ENVIRONMENT__: JSON.stringify(this.config.environment),\r\n      },\r\n    };\r\n\r\n    // Merge with user-provided Vite config\r\n    const userConfig = await this.loadUserViteConfig();\r\n    return mergeConfig(baseConfig, userConfig || {});\r\n  }\r\n\r\n  private getChunkingStrategy(): Record<string, string[]> {\r\n    return {\r\n      // React and core libraries\r\n      \"react-vendor\": [\"react\", \"react-dom\", \"react-router-dom\"],\r\n\r\n      // UI libraries\r\n      \"ui-vendor\": [\"@headlessui/react\", \"tailwindcss\"],\r\n\r\n      // Data fetching and state management\r\n      \"data-vendor\": [\"@tanstack/react-query\", \"zustand\"],\r\n\r\n      // AI and ML libraries\r\n      \"ai-vendor\": [\"openai\", \"ai\"],\r\n\r\n      // Utilities\r\n      \"utils-vendor\": [\"lodash\", \"date-fns\", \"zod\"],\r\n\r\n      // Plugin components\r\n      plugins: (id) => {\r\n        return id.includes(\"src/plugins/\") || id.includes(\"@farm/plugin-\");\r\n      },\r\n    };\r\n  }\r\n\r\n  private createPluginConfigGenerator(): any {\r\n    return {\r\n      name: \"farm-plugin-config\",\r\n      generateBundle() {\r\n        // Generate plugin configuration for runtime\r\n        const pluginConfig = this.generatePluginRuntimeConfig();\r\n\r\n        this.emitFile({\r\n          type: \"asset\",\r\n          fileName: \"plugin-config.json\",\r\n          source: JSON.stringify(pluginConfig, null, 2),\r\n        });\r\n      },\r\n    };\r\n  }\r\n\r\n  private createAssetOptimizer(): any {\r\n    return {\r\n      name: \"farm-asset-optimizer\",\r\n      generateBundle(options, bundle) {\r\n        // Optimize images and other assets\r\n        Object.keys(bundle).forEach((fileName) => {\r\n          const file = bundle[fileName];\r\n\r\n          if (file.type === \"asset\" && this.isImageAsset(fileName)) {\r\n            // Apply image optimization\r\n            bundle[fileName] = this.optimizeImage(file);\r\n          }\r\n        });\r\n      },\r\n    };\r\n  }\r\n\r\n  private async analyzeBundleSize(): Promise<BundleAnalysis> {\r\n    const distPath = `${this.config.outputDir}/frontend`;\r\n    const analysis: BundleAnalysis = {\r\n      totalSize: 0,\r\n      chunks: [],\r\n      assets: [],\r\n    };\r\n\r\n    // Analyze built files\r\n    const files = await this.getDistFiles(distPath);\r\n\r\n    for (const file of files) {\r\n      const stats = await fs.stat(file.path);\r\n\r\n      if (file.name.endsWith(\".js\")) {\r\n        analysis.chunks.push({\r\n          name: file.name,\r\n          size: stats.size,\r\n          gzipSize: await this.getGzipSize(file.path),\r\n        });\r\n      } else {\r\n        analysis.assets.push({\r\n          name: file.name,\r\n          size: stats.size,\r\n          type: this.getAssetType(file.name),\r\n        });\r\n      }\r\n\r\n      analysis.totalSize += stats.size;\r\n    }\r\n\r\n    return analysis;\r\n  }\r\n\r\n  private async generateArtifacts(\r\n    buildResult: any,\r\n    bundleAnalysis: BundleAnalysis\r\n  ): Promise<BuildArtifact[]> {\r\n    const artifacts: BuildArtifact[] = [];\r\n\r\n    // Frontend bundle artifact\r\n    artifacts.push({\r\n      type: \"frontend-bundle\",\r\n      path: `${this.config.outputDir}/frontend`,\r\n      size: bundleAnalysis.totalSize,\r\n      metadata: {\r\n        entryPoints: [\"index.html\"],\r\n        chunks: bundleAnalysis.chunks.length,\r\n        assets: bundleAnalysis.assets.length,\r\n      },\r\n    });\r\n\r\n    // Bundle analysis artifact\r\n    artifacts.push({\r\n      type: \"bundle-analysis\",\r\n      path: `${this.config.outputDir}/bundle-analysis.html`,\r\n      size: 0,\r\n      metadata: bundleAnalysis,\r\n    });\r\n\r\n    return artifacts;\r\n  }\r\n}\r\n```\r\n\r\n### 3. Backend Builder\r\n\r\n**Python Backend Optimization:**\r\n\r\n```typescript\r\n// packages/core/src/build/builders/backend.ts\r\nimport { spawn } from \"child_process\";\r\nimport path from \"path\";\r\nimport fs from \"fs-extra\";\r\n\r\nexport class BackendBuilder implements Builder {\r\n  private config: BuildConfig;\r\n\r\n  constructor(config: BuildConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  async build(task: BuildTask, buildId: string): Promise<BuildResult> {\r\n    const startTime = Date.now();\r\n\r\n    console.log(\"🐍 Building Python backend...\");\r\n\r\n    // Compile Python bytecode\r\n    await this.compilePythonBytecode();\r\n\r\n    // Install production dependencies\r\n    await this.installProductionDependencies();\r\n\r\n    // Run database migrations\r\n    if (this.config.runMigrations) {\r\n      await this.runDatabaseMigrations();\r\n    }\r\n\r\n    // Optimize Python imports\r\n    await this.optimizePythonImports();\r\n\r\n    // Generate OpenAPI schema\r\n    const openApiSchema = await this.generateOpenApiSchema();\r\n\r\n    // Create backend artifacts\r\n    const artifacts = await this.generateBackendArtifacts(openApiSchema);\r\n\r\n    return {\r\n      success: true,\r\n      duration: Date.now() - startTime,\r\n      artifacts,\r\n      metadata: {\r\n        pythonVersion: await this.getPythonVersion(),\r\n        dependencyCount: await this.getDependencyCount(),\r\n        openApiVersion: openApiSchema.openapi,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async compilePythonBytecode(): Promise<void> {\r\n    console.log(\"⚡ Compiling Python bytecode...\");\r\n\r\n    await this.runCommand(\"python\", [\r\n      \"-m\",\r\n      \"compileall\",\r\n      \"-b\", // Generate bytecode files\r\n      \"-f\", // Force recompilation\r\n      \"apps/api/src\",\r\n    ]);\r\n\r\n    console.log(\"✅ Python bytecode compiled\");\r\n  }\r\n\r\n  private async installProductionDependencies(): Promise<void> {\r\n    console.log(\"📦 Installing production dependencies...\");\r\n\r\n    // Create virtual environment for production\r\n    const venvPath = path.join(this.config.outputDir, \"backend\", \"venv\");\r\n    await fs.ensureDir(venvPath);\r\n\r\n    // Create virtual environment\r\n    await this.runCommand(\"python\", [\"-m\", \"venv\", venvPath]);\r\n\r\n    // Install dependencies\r\n    const pipPath = path.join(venvPath, \"bin\", \"pip\");\r\n    await this.runCommand(pipPath, [\r\n      \"install\",\r\n      \"--no-cache-dir\",\r\n      \"--requirement\",\r\n      \"apps/api/requirements.txt\",\r\n    ]);\r\n\r\n    // Remove development dependencies\r\n    await this.removeDevelopmentDependencies(venvPath);\r\n\r\n    console.log(\"✅ Production dependencies installed\");\r\n  }\r\n\r\n  private async runDatabaseMigrations(): Promise<void> {\r\n    console.log(\"🗄️ Running database migrations...\");\r\n\r\n    try {\r\n      // This would run the database migration system\r\n      // Integration with the migration manager we designed\r\n      await this.runCommand(\"python\", [\r\n        \"-m\",\r\n        \"apps.api.database.migrate\",\r\n        \"--environment\",\r\n        this.config.environment,\r\n      ]);\r\n\r\n      console.log(\"✅ Database migrations completed\");\r\n    } catch (error) {\r\n      console.warn(\"⚠️ Database migrations failed:\", error.message);\r\n\r\n      if (this.config.failOnMigrationError) {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  private async optimizePythonImports(): Promise<void> {\r\n    console.log(\"🎯 Optimizing Python imports...\");\r\n\r\n    // Use tools like autoflake, isort to optimize imports\r\n    await this.runCommand(\"python\", [\r\n      \"-m\",\r\n      \"autoflake\",\r\n      \"--remove-unused-variables\",\r\n      \"--remove-all-unused-imports\",\r\n      \"--recursive\",\r\n      \"--in-place\",\r\n      \"apps/api/src\",\r\n    ]);\r\n\r\n    await this.runCommand(\"python\", [\"-m\", \"isort\", \"apps/api/src\"]);\r\n\r\n    console.log(\"✅ Python imports optimized\");\r\n  }\r\n\r\n  private async generateOpenApiSchema(): Promise<any> {\r\n    console.log(\"📋 Generating OpenAPI schema...\");\r\n\r\n    // Run the FastAPI app to extract OpenAPI schema\r\n    const schemaOutput = await this.runCommand(\r\n      \"python\",\r\n      [\r\n        \"-c\",\r\n        `\r\nimport sys\r\nsys.path.append('apps/api')\r\nfrom src.main import app\r\nimport json\r\nprint(json.dumps(app.openapi(), indent=2))\r\n      `,\r\n      ],\r\n      { capture: true }\r\n    );\r\n\r\n    const schema = JSON.parse(schemaOutput);\r\n\r\n    // Save schema to file\r\n    const schemaPath = path.join(\r\n      this.config.outputDir,\r\n      \"backend\",\r\n      \"openapi.json\"\r\n    );\r\n    await fs.writeJSON(schemaPath, schema, { spaces: 2 });\r\n\r\n    console.log(\"✅ OpenAPI schema generated\");\r\n    return schema;\r\n  }\r\n\r\n  private async generateBackendArtifacts(\r\n    openApiSchema: any\r\n  ): Promise<BuildArtifact[]> {\r\n    const artifacts: BuildArtifact[] = [];\r\n\r\n    // Backend source artifact\r\n    const backendPath = path.join(this.config.outputDir, \"backend\");\r\n    await fs.copy(\"apps/api\", backendPath, {\r\n      filter: (src) => {\r\n        // Filter out unnecessary files\r\n        return (\r\n          !src.includes(\"__pycache__\") &&\r\n          !src.includes(\".pytest_cache\") &&\r\n          !src.includes(\"test_\")\r\n        );\r\n      },\r\n    });\r\n\r\n    artifacts.push({\r\n      type: \"backend-source\",\r\n      path: backendPath,\r\n      size: await this.getDirectorySize(backendPath),\r\n      metadata: {\r\n        pythonVersion: await this.getPythonVersion(),\r\n        framework: \"FastAPI\",\r\n        entryPoint: \"src/main.py\",\r\n      },\r\n    });\r\n\r\n    // OpenAPI schema artifact\r\n    artifacts.push({\r\n      type: \"openapi-schema\",\r\n      path: path.join(backendPath, \"openapi.json\"),\r\n      size: JSON.stringify(openApiSchema).length,\r\n      metadata: {\r\n        version: openApiSchema.openapi,\r\n        endpoints: Object.keys(openApiSchema.paths || {}).length,\r\n        models: Object.keys(openApiSchema.components?.schemas || {}).length,\r\n      },\r\n    });\r\n\r\n    return artifacts;\r\n  }\r\n\r\n  private async runCommand(\r\n    command: string,\r\n    args: string[],\r\n    options: { capture?: boolean; cwd?: string } = {}\r\n  ): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const child = spawn(command, args, {\r\n        cwd: options.cwd || process.cwd(),\r\n        stdio: options.capture ? \"pipe\" : \"inherit\",\r\n      });\r\n\r\n      let output = \"\";\r\n\r\n      if (options.capture) {\r\n        child.stdout.on(\"data\", (data) => {\r\n          output += data.toString();\r\n        });\r\n      }\r\n\r\n      child.on(\"close\", (code) => {\r\n        if (code === 0) {\r\n          resolve(output);\r\n        } else {\r\n          reject(new Error(`Command failed with code ${code}`));\r\n        }\r\n      });\r\n\r\n      child.on(\"error\", reject);\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n### 4. AI Model Optimizer\r\n\r\n**AI Model Optimization and Bundling:**\r\n\r\n```typescript\r\n// packages/core/src/build/builders/ai-optimizer.ts\r\nexport class AIModelOptimizer implements Builder {\r\n  private config: BuildConfig;\r\n\r\n  constructor(config: BuildConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  async build(task: BuildTask, buildId: string): Promise<BuildResult> {\r\n    const startTime = Date.now();\r\n\r\n    console.log(\"🤖 Optimizing AI models...\");\r\n\r\n    // Analyze configured AI providers and models\r\n    const aiConfig = this.config.ai || {};\r\n    const artifacts: BuildArtifact[] = [];\r\n\r\n    // Process Ollama models\r\n    if (aiConfig.providers?.ollama?.enabled) {\r\n      const ollamaArtifacts = await this.processOllamaModels(\r\n        aiConfig.providers.ollama\r\n      );\r\n      artifacts.push(...ollamaArtifacts);\r\n    }\r\n\r\n    // Process custom models\r\n    if (aiConfig.customModels) {\r\n      const customArtifacts = await this.processCustomModels(\r\n        aiConfig.customModels\r\n      );\r\n      artifacts.push(...customArtifacts);\r\n    }\r\n\r\n    // Generate AI configuration for deployment\r\n    const aiDeploymentConfig = await this.generateAIDeploymentConfig(aiConfig);\r\n    artifacts.push(aiDeploymentConfig);\r\n\r\n    return {\r\n      success: true,\r\n      duration: Date.now() - startTime,\r\n      artifacts,\r\n      metadata: {\r\n        modelsProcessed: artifacts.length - 1, // Excluding config\r\n        totalModelSize: artifacts.reduce((sum, a) => sum + a.size, 0),\r\n      },\r\n    };\r\n  }\r\n\r\n  private async processOllamaModels(\r\n    ollamaConfig: any\r\n  ): Promise<BuildArtifact[]> {\r\n    const artifacts: BuildArtifact[] = [];\r\n\r\n    console.log(\"🦙 Processing Ollama models...\");\r\n\r\n    for (const modelName of ollamaConfig.models || []) {\r\n      console.log(`📥 Processing model: ${modelName}`);\r\n\r\n      try {\r\n        // Check if model exists locally\r\n        const modelInfo = await this.getOllamaModelInfo(modelName);\r\n\r\n        if (modelInfo) {\r\n          // Model exists, create deployment configuration\r\n          artifacts.push({\r\n            type: \"ollama-model-config\",\r\n            path: `ai-models/${modelName}.json`,\r\n            size: JSON.stringify(modelInfo).length,\r\n            metadata: {\r\n              modelName,\r\n              size: modelInfo.size,\r\n              architecture: modelInfo.architecture,\r\n              quantization: modelInfo.quantization,\r\n            },\r\n          });\r\n\r\n          // For production builds, optionally export model\r\n          if (\r\n            this.config.environment === \"production\" &&\r\n            this.config.exportModels\r\n          ) {\r\n            const exportedModel = await this.exportOllamaModel(modelName);\r\n            artifacts.push(exportedModel);\r\n          }\r\n        } else {\r\n          console.warn(`⚠️ Model ${modelName} not found locally`);\r\n\r\n          // Create pull instruction for deployment\r\n          artifacts.push({\r\n            type: \"ollama-model-pull\",\r\n            path: `ai-models/${modelName}-pull.sh`,\r\n            size: 100,\r\n            metadata: {\r\n              modelName,\r\n              pullCommand: `ollama pull ${modelName}`,\r\n            },\r\n          });\r\n        }\r\n      } catch (error) {\r\n        console.error(\r\n          `❌ Failed to process model ${modelName}:`,\r\n          error.message\r\n        );\r\n      }\r\n    }\r\n\r\n    console.log(`✅ Processed ${artifacts.length} Ollama models`);\r\n    return artifacts;\r\n  }\r\n\r\n  private async getOllamaModelInfo(modelName: string): Promise<any> {\r\n    try {\r\n      // Query Ollama API for model information\r\n      const response = await fetch(\"http://localhost:11434/api/tags\");\r\n      const data = await response.json();\r\n\r\n      const model = data.models?.find((m: any) => m.name === modelName);\r\n      return model\r\n        ? {\r\n            name: model.name,\r\n            size: model.size,\r\n            architecture: model.details?.architecture,\r\n            quantization: model.details?.quantization_level,\r\n            modified_at: model.modified_at,\r\n          }\r\n        : null;\r\n    } catch (error) {\r\n      console.warn(`Could not get info for model ${modelName}:`, error.message);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private async exportOllamaModel(modelName: string): Promise<BuildArtifact> {\r\n    console.log(`📤 Exporting model: ${modelName}`);\r\n\r\n    // This would implement model export logic\r\n    // For now, create a placeholder\r\n    const exportPath = `ai-models/exported/${modelName}.gguf`;\r\n\r\n    return {\r\n      type: \"ollama-model-export\",\r\n      path: exportPath,\r\n      size: 0, // Would be actual file size\r\n      metadata: {\r\n        modelName,\r\n        format: \"gguf\",\r\n        exported: true,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async processCustomModels(\r\n    customModels: any[]\r\n  ): Promise<BuildArtifact[]> {\r\n    const artifacts: BuildArtifact[] = [];\r\n\r\n    console.log(\"🔧 Processing custom models...\");\r\n\r\n    for (const model of customModels) {\r\n      console.log(`🔄 Processing custom model: ${model.name}`);\r\n\r\n      try {\r\n        // Optimize model based on type\r\n        let optimizedModel: BuildArtifact;\r\n\r\n        switch (model.type) {\r\n          case \"huggingface\":\r\n            optimizedModel = await this.optimizeHuggingFaceModel(model);\r\n            break;\r\n          case \"pytorch\":\r\n            optimizedModel = await this.optimizePyTorchModel(model);\r\n            break;\r\n          case \"tensorflow\":\r\n            optimizedModel = await this.optimizeTensorFlowModel(model);\r\n            break;\r\n          default:\r\n            throw new Error(`Unsupported model type: ${model.type}`);\r\n        }\r\n\r\n        artifacts.push(optimizedModel);\r\n      } catch (error) {\r\n        console.error(\r\n          `❌ Failed to optimize model ${model.name}:`,\r\n          error.message\r\n        );\r\n      }\r\n    }\r\n\r\n    console.log(`✅ Processed ${artifacts.length} custom models`);\r\n    return artifacts;\r\n  }\r\n\r\n  private async optimizeHuggingFaceModel(model: any): Promise<BuildArtifact> {\r\n    // Implement HuggingFace model optimization\r\n    // - Model quantization\r\n    // - ONNX conversion\r\n    // - TensorRT optimization\r\n\r\n    return {\r\n      type: \"huggingface-model\",\r\n      path: `ai-models/huggingface/${model.name}`,\r\n      size: 0, // Actual size after optimization\r\n      metadata: {\r\n        originalSize: model.size,\r\n        optimized: true,\r\n        quantization: \"int8\",\r\n        format: \"onnx\",\r\n      },\r\n    };\r\n  }\r\n\r\n  private async optimizePyTorchModel(model: any): Promise<BuildArtifact> {\r\n    // Implement PyTorch model optimization\r\n    // - TorchScript compilation\r\n    // - Model pruning\r\n    // - Quantization\r\n\r\n    return {\r\n      type: \"pytorch-model\",\r\n      path: `ai-models/pytorch/${model.name}`,\r\n      size: 0,\r\n      metadata: {\r\n        optimized: true,\r\n        compiled: true,\r\n        format: \"torchscript\",\r\n      },\r\n    };\r\n  }\r\n\r\n  private async optimizeTensorFlowModel(model: any): Promise<BuildArtifact> {\r\n    // Implement TensorFlow model optimization\r\n    // - TensorFlow Lite conversion\r\n    // - Graph optimization\r\n    // - Quantization\r\n\r\n    return {\r\n      type: \"tensorflow-model\",\r\n      path: `ai-models/tensorflow/${model.name}`,\r\n      size: 0,\r\n      metadata: {\r\n        optimized: true,\r\n        format: \"tflite\",\r\n      },\r\n    };\r\n  }\r\n\r\n  private async generateAIDeploymentConfig(\r\n    aiConfig: any\r\n  ): Promise<BuildArtifact> {\r\n    const deploymentConfig = {\r\n      providers: {},\r\n      models: {},\r\n      routing: aiConfig.routing || {},\r\n      features: aiConfig.features || {},\r\n      deployment: {\r\n        environment: this.config.environment,\r\n        generatedAt: new Date().toISOString(),\r\n        buildVersion: this.config.version,\r\n      },\r\n    };\r\n\r\n    // Process provider configurations for deployment\r\n    for (const [providerName, config] of Object.entries(\r\n      aiConfig.providers || {}\r\n    )) {\r\n      if (config.enabled) {\r\n        deploymentConfig.providers[providerName] = {\r\n          enabled: true,\r\n          models: config.models || [],\r\n          defaultModel: config.defaultModel,\r\n          // Remove sensitive data like API keys\r\n          ...this.sanitizeProviderConfig(config),\r\n        };\r\n      }\r\n    }\r\n\r\n    const configContent = JSON.stringify(deploymentConfig, null, 2);\r\n\r\n    return {\r\n      type: \"ai-deployment-config\",\r\n      path: \"ai-config.json\",\r\n      size: configContent.length,\r\n      metadata: {\r\n        providers: Object.keys(deploymentConfig.providers).length,\r\n        environment: this.config.environment,\r\n      },\r\n    };\r\n  }\r\n\r\n  private sanitizeProviderConfig(config: any): any {\r\n    const sanitized = { ...config };\r\n\r\n    // Remove sensitive fields\r\n    delete sanitized.apiKey;\r\n    delete sanitized.clientSecret;\r\n    delete sanitized.privateKey;\r\n\r\n    return sanitized;\r\n  }\r\n}\r\n```\r\n\r\n### 5. Docker Builder\r\n\r\n**Containerization and Multi-Stage Builds:**\r\n\r\n```typescript\r\n// packages/core/src/build/builders/docker.ts\r\nexport class DockerBuilder implements Builder {\r\n  private config: BuildConfig;\r\n\r\n  constructor(config: BuildConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  async build(task: BuildTask, buildId: string): Promise<BuildResult> {\r\n    const startTime = Date.now();\r\n\r\n    console.log(\"🐳 Building Docker containers...\");\r\n\r\n    // Generate Dockerfiles\r\n    await this.generateDockerfiles();\r\n\r\n    // Build Docker images\r\n    const images = await this.buildDockerImages(buildId);\r\n\r\n    // Generate Docker Compose configuration\r\n    await this.generateDockerCompose();\r\n\r\n    // Generate Kubernetes manifests (if enabled)\r\n    if (this.config.generateK8s) {\r\n      await this.generateKubernetesManifests();\r\n    }\r\n\r\n    const artifacts = await this.generateDockerArtifacts(images);\r\n\r\n    return {\r\n      success: true,\r\n      duration: Date.now() - startTime,\r\n      artifacts,\r\n      metadata: {\r\n        images: images.length,\r\n        totalImageSize: images.reduce((sum, img) => sum + img.size, 0),\r\n      },\r\n    };\r\n  }\r\n\r\n  private async generateDockerfiles(): Promise<void> {\r\n    console.log(\"📝 Generating Dockerfiles...\");\r\n\r\n    // Generate production Dockerfile\r\n    const prodDockerfile = this.createProductionDockerfile();\r\n    await fs.writeFile(\r\n      path.join(this.config.outputDir, \"Dockerfile\"),\r\n      prodDockerfile\r\n    );\r\n\r\n    // Generate development Dockerfile\r\n    const devDockerfile = this.createDevelopmentDockerfile();\r\n    await fs.writeFile(\r\n      path.join(this.config.outputDir, \"Dockerfile.dev\"),\r\n      devDockerfile\r\n    );\r\n\r\n    // Generate Ollama Dockerfile (if AI enabled)\r\n    if (this.config.ai?.providers?.ollama?.enabled) {\r\n      const ollamaDockerfile = this.createOllamaDockerfile();\r\n      await fs.writeFile(\r\n        path.join(this.config.outputDir, \"Dockerfile.ollama\"),\r\n        ollamaDockerfile\r\n      );\r\n    }\r\n\r\n    console.log(\"✅ Dockerfiles generated\");\r\n  }\r\n\r\n  private createProductionDockerfile(): string {\r\n    return `\r\n# Multi-stage production Dockerfile for FARM application\r\nFROM node:18-alpine AS frontend-builder\r\nWORKDIR /app\r\nCOPY apps/web/package*.json ./\r\nRUN npm ci --only=production\r\nCOPY apps/web ./\r\nRUN npm run build\r\n\r\nFROM python:3.11-slim AS backend-builder\r\nWORKDIR /app\r\nCOPY apps/api/requirements.txt ./\r\nRUN pip install --no-cache-dir -r requirements.txt\r\nCOPY apps/api ./\r\n\r\nFROM python:3.11-slim AS production\r\nWORKDIR /app\r\n\r\n# Install system dependencies\r\nRUN apt-get update && apt-get install -y \\\\\r\n    curl \\\\\r\n    && rm -rf /var/lib/apt/lists/*\r\n\r\n# Copy Python dependencies and application\r\nCOPY --from=backend-builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages\r\nCOPY --from=backend-builder /app ./api\r\n\r\n# Copy frontend build\r\nCOPY --from=frontend-builder /app/dist ./static\r\n\r\n# Create non-root user\r\nRUN useradd --create-home --shell /bin/bash app\r\nUSER app\r\n\r\n# Health check\r\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\\\r\n  CMD curl -f http://localhost:8000/health || exit 1\r\n\r\nEXPOSE 8000\r\nCMD [\"uvicorn\", \"api.src.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\r\n`;\r\n  }\r\n\r\n  private createDevelopmentDockerfile(): string {\r\n    return `\r\n# Development Dockerfile with hot reload\r\nFROM node:18-alpine AS development\r\nWORKDIR /app\r\n\r\n# Install Python\r\nRUN apk add --no-cache python3 py3-pip\r\n\r\n# Install Node.js dependencies\r\nCOPY package*.json ./\r\nCOPY apps/web/package*.json ./apps/web/\r\nRUN npm install\r\n\r\n# Install Python dependencies\r\nCOPY apps/api/requirements.txt ./apps/api/\r\nRUN pip install -r apps/api/requirements.txt\r\n\r\n# Copy source code\r\nCOPY . .\r\n\r\n# Expose ports for frontend and backend\r\nEXPOSE 3000 8000\r\n\r\n# Start development servers\r\nCMD [\"npm\", \"run\", \"dev\"]\r\n`;\r\n  }\r\n\r\n  private createOllamaDockerfile(): string {\r\n    const ollamaConfig = this.config.ai?.providers?.ollama;\r\n    const models = ollamaConfig?.models || [];\r\n\r\n    return `\r\n# Ollama AI service with pre-loaded models\r\nFROM ollama/ollama:latest\r\n\r\n# Install curl for health checks\r\nRUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*\r\n\r\n# Start Ollama service and pull models\r\nRUN ollama serve & \\\\\r\n    sleep 5 && \\\\\r\n    ${models.map((model) => `ollama pull ${model} &&`).join(\" \")} \\\\\r\n    echo \"Models loaded\"\r\n\r\n# Health check\r\nHEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \\\\\r\n  CMD curl -f http://localhost:11434/api/tags || exit 1\r\n\r\nEXPOSE 11434\r\nCMD [\"ollama\", \"serve\"]\r\n`;\r\n  }\r\n\r\n  private async buildDockerImages(buildId: string): Promise<DockerImage[]> {\r\n    const images: DockerImage[] = [];\r\n\r\n    console.log(\"🔨 Building Docker images...\");\r\n\r\n    // Build main application image\r\n    const appImage = await this.buildDockerImage({\r\n      name: `${this.config.appName}:${buildId}`,\r\n      dockerfile: \"Dockerfile\",\r\n      context: this.config.outputDir,\r\n      target: \"production\",\r\n    });\r\n    images.push(appImage);\r\n\r\n    // Build Ollama image (if enabled)\r\n    if (this.config.ai?.providers?.ollama?.enabled) {\r\n      const ollamaImage = await this.buildDockerImage({\r\n        name: `${this.config.appName}-ollama:${buildId}`,\r\n        dockerfile: \"Dockerfile.ollama\",\r\n        context: this.config.outputDir,\r\n      });\r\n      images.push(ollamaImage);\r\n    }\r\n\r\n    console.log(`✅ Built ${images.length} Docker images`);\r\n    return images;\r\n  }\r\n\r\n  private async buildDockerImage(options: {\r\n    name: string;\r\n    dockerfile: string;\r\n    context: string;\r\n    target?: string;\r\n  }): Promise<DockerImage> {\r\n    console.log(`🏗️ Building image: ${options.name}`);\r\n\r\n    const args = [\r\n      \"build\",\r\n      \"-t\",\r\n      options.name,\r\n      \"-f\",\r\n      options.dockerfile,\r\n      ...(options.target ? [\"--target\", options.target] : []),\r\n      options.context,\r\n    ];\r\n\r\n    await this.runDockerCommand(args);\r\n\r\n    // Get image size\r\n    const inspectResult = await this.runDockerCommand(\r\n      [\"inspect\", options.name, \"--format={{.Size}}\"],\r\n      { capture: true }\r\n    );\r\n\r\n    const size = parseInt(inspectResult.trim());\r\n\r\n    return {\r\n      name: options.name,\r\n      size,\r\n      dockerfile: options.dockerfile,\r\n      context: options.context,\r\n    };\r\n  }\r\n\r\n  private async generateDockerCompose(): Promise<void> {\r\n    console.log(\"📋 Generating Docker Compose configuration...\");\r\n\r\n    const services: any = {\r\n      app: {\r\n        build: {\r\n          context: \".\",\r\n          dockerfile: \"Dockerfile\",\r\n        },\r\n        ports: [\"8000:8000\"],\r\n        environment: {\r\n          NODE_ENV: this.config.environment,\r\n          DATABASE_URL: \"${DATABASE_URL:-mongodb://mongodb:27017/farmapp}\",\r\n        },\r\n        depends_on: [\"mongodb\"],\r\n        healthcheck: {\r\n          test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"],\r\n          interval: \"30s\",\r\n          timeout: \"10s\",\r\n          retries: 3,\r\n        },\r\n      },\r\n\r\n      mongodb: {\r\n        image: \"mongo:7\",\r\n        ports: [\"27017:27017\"],\r\n        environment: {\r\n          MONGO_INITDB_ROOT_USERNAME: \"${MONGO_USERNAME:-admin}\",\r\n          MONGO_INITDB_ROOT_PASSWORD: \"${MONGO_PASSWORD:-password}\",\r\n          MONGO_INITDB_DATABASE: \"${MONGO_DATABASE:-farmapp}\",\r\n        },\r\n        volumes: [\"mongodb_data:/data/db\"],\r\n        healthcheck: {\r\n          test: [\"CMD\", \"mongosh\", \"--eval\", 'db.adminCommand(\"ping\")'],\r\n          interval: \"30s\",\r\n          timeout: \"10s\",\r\n          retries: 3,\r\n        },\r\n      },\r\n    };\r\n\r\n    // Add Ollama service if enabled\r\n    if (this.config.ai?.providers?.ollama?.enabled) {\r\n      services.ollama = {\r\n        build: {\r\n          context: \".\",\r\n          dockerfile: \"Dockerfile.ollama\",\r\n        },\r\n        ports: [\"11434:11434\"],\r\n        volumes: [\"ollama_data:/root/.ollama\"],\r\n        healthcheck: {\r\n          test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:11434/api/tags\"],\r\n          interval: \"30s\",\r\n          timeout: \"10s\",\r\n          retries: 3,\r\n          start_period: \"60s\",\r\n        },\r\n      };\r\n\r\n      // Update app service to depend on Ollama\r\n      services.app.depends_on.push(\"ollama\");\r\n      services.app.environment.OLLAMA_URL = \"http://ollama:11434\";\r\n    }\r\n\r\n    const dockerCompose = {\r\n      version: \"3.8\",\r\n      services,\r\n      volumes: {\r\n        mongodb_data: {},\r\n        ...(this.config.ai?.providers?.ollama?.enabled && { ollama_data: {} }),\r\n      },\r\n      networks: {\r\n        default: {\r\n          name: `${this.config.appName}_network`,\r\n        },\r\n      },\r\n    };\r\n\r\n    await fs.writeFile(\r\n      path.join(this.config.outputDir, \"docker-compose.yml\"),\r\n      yaml.dump(dockerCompose, { indent: 2 })\r\n    );\r\n\r\n    console.log(\"✅ Docker Compose configuration generated\");\r\n  }\r\n\r\n  private async generateKubernetesManifests(): Promise<void> {\r\n    console.log(\"☸️ Generating Kubernetes manifests...\");\r\n\r\n    const manifests = [\r\n      this.createAppDeployment(),\r\n      this.createAppService(),\r\n      this.createMongoDBDeployment(),\r\n      this.createMongoDBService(),\r\n      ...(this.config.ai?.providers?.ollama?.enabled\r\n        ? [this.createOllamaDeployment(), this.createOllamaService()]\r\n        : []),\r\n    ];\r\n\r\n    const k8sManifest = manifests.join(\"\\n---\\n\");\r\n\r\n    await fs.writeFile(\r\n      path.join(this.config.outputDir, \"k8s-manifests.yaml\"),\r\n      k8sManifest\r\n    );\r\n\r\n    console.log(\"✅ Kubernetes manifests generated\");\r\n  }\r\n\r\n  private async runDockerCommand(\r\n    args: string[],\r\n    options: { capture?: boolean } = {}\r\n  ): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const child = spawn(\"docker\", args, {\r\n        stdio: options.capture ? \"pipe\" : \"inherit\",\r\n      });\r\n\r\n      let output = \"\";\r\n\r\n      if (options.capture) {\r\n        child.stdout.on(\"data\", (data) => {\r\n          output += data.toString();\r\n        });\r\n      }\r\n\r\n      child.on(\"close\", (code) => {\r\n        if (code === 0) {\r\n          resolve(output);\r\n        } else {\r\n          reject(new Error(`Docker command failed with code ${code}`));\r\n        }\r\n      });\r\n\r\n      child.on(\"error\", reject);\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Build Cache System\r\n\r\n### 1. Intelligent Build Caching\r\n\r\n**Advanced Caching for Faster Builds:**\r\n\r\n```typescript\r\n// packages/core/src/build/cache.ts\r\nimport crypto from \"crypto\";\r\nimport fs from \"fs-extra\";\r\nimport path from \"path\";\r\n\r\nexport class BuildCache {\r\n  private cacheDir: string;\r\n  private maxCacheSize: number;\r\n  private cacheIndex: Map<string, CacheEntry> = new Map();\r\n\r\n  constructor(cacheDir: string, maxSize: number = 5 * 1024 * 1024 * 1024) {\r\n    // 5GB default\r\n    this.cacheDir = cacheDir;\r\n    this.maxCacheSize = maxSize;\r\n    this.initializeCache();\r\n  }\r\n\r\n  async getCacheKey(task: BuildTask): Promise<string> {\r\n    const inputs = await this.getTaskInputs(task);\r\n    const hash = crypto.createHash(\"sha256\");\r\n\r\n    // Hash task configuration\r\n    hash.update(\r\n      JSON.stringify({\r\n        name: task.name,\r\n        builder: task.builder,\r\n        dependencies: task.dependencies,\r\n        config: this.sanitizeConfig(task.config || {}),\r\n      })\r\n    );\r\n\r\n    // Hash input files\r\n    for (const input of inputs) {\r\n      if (input.type === \"file\") {\r\n        const content = await fs.readFile(input.path);\r\n        hash.update(content);\r\n      } else if (input.type === \"directory\") {\r\n        const dirHash = await this.hashDirectory(input.path);\r\n        hash.update(dirHash);\r\n      }\r\n    }\r\n\r\n    return hash.digest(\"hex\");\r\n  }\r\n\r\n  async get(cacheKey: string): Promise<CachedBuildResult | null> {\r\n    const cacheEntry = this.cacheIndex.get(cacheKey);\r\n    if (!cacheEntry) {\r\n      return null;\r\n    }\r\n\r\n    // Check if cache entry is still valid\r\n    if (Date.now() - cacheEntry.timestamp > this.getCacheTTL()) {\r\n      await this.invalidate(cacheKey);\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const cachePath = path.join(this.cacheDir, cacheKey);\r\n      const cacheData = await fs.readJSON(path.join(cachePath, \"result.json\"));\r\n\r\n      // Verify cached artifacts still exist\r\n      for (const artifact of cacheData.artifacts) {\r\n        const artifactPath = path.join(cachePath, \"artifacts\", artifact.path);\r\n        if (!(await fs.pathExists(artifactPath))) {\r\n          await this.invalidate(cacheKey);\r\n          return null;\r\n        }\r\n      }\r\n\r\n      // Update access time\r\n      cacheEntry.lastAccessed = Date.now();\r\n\r\n      return cacheData;\r\n    } catch (error) {\r\n      // Cache corruption, invalidate\r\n      await this.invalidate(cacheKey);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async set(cacheKey: string, result: BuildResult): Promise<void> {\r\n    const cachePath = path.join(this.cacheDir, cacheKey);\r\n    await fs.ensureDir(cachePath);\r\n\r\n    // Store build result\r\n    await fs.writeJSON(path.join(cachePath, \"result.json\"), result, {\r\n      spaces: 2,\r\n    });\r\n\r\n    // Store artifacts\r\n    const artifactsDir = path.join(cachePath, \"artifacts\");\r\n    await fs.ensureDir(artifactsDir);\r\n\r\n    for (const artifact of result.artifacts) {\r\n      const sourcePath = artifact.path;\r\n      const targetPath = path.join(artifactsDir, artifact.path);\r\n\r\n      await fs.ensureDir(path.dirname(targetPath));\r\n\r\n      if (await fs.pathExists(sourcePath)) {\r\n        await fs.copy(sourcePath, targetPath);\r\n      }\r\n    }\r\n\r\n    // Update cache index\r\n    const cacheEntry: CacheEntry = {\r\n      key: cacheKey,\r\n      timestamp: Date.now(),\r\n      lastAccessed: Date.now(),\r\n      size: await this.getDirectorySize(cachePath),\r\n    };\r\n\r\n    this.cacheIndex.set(cacheKey, cacheEntry);\r\n\r\n    // Cleanup old cache entries if needed\r\n    await this.cleanupCache();\r\n  }\r\n\r\n  private async getTaskInputs(task: BuildTask): Promise<TaskInput[]> {\r\n    const inputs: TaskInput[] = [];\r\n\r\n    // Add task-specific inputs based on builder type\r\n    switch (task.builder) {\r\n      case \"frontend\":\r\n        inputs.push(\r\n          { type: \"directory\", path: \"apps/web/src\" },\r\n          { type: \"file\", path: \"apps/web/package.json\" },\r\n          { type: \"file\", path: \"apps/web/vite.config.ts\" },\r\n          { type: \"file\", path: \"apps/web/tailwind.config.js\" }\r\n        );\r\n        break;\r\n\r\n      case \"backend\":\r\n        inputs.push(\r\n          { type: \"directory\", path: \"apps/api/src\" },\r\n          { type: \"file\", path: \"apps/api/requirements.txt\" },\r\n          { type: \"file\", path: \"apps/api/pyproject.toml\" }\r\n        );\r\n        break;\r\n\r\n      case \"ai-models\":\r\n        inputs.push({ type: \"file\", path: \"farm.config.ts\" });\r\n        break;\r\n    }\r\n\r\n    return inputs;\r\n  }\r\n\r\n  private async hashDirectory(dirPath: string): Promise<string> {\r\n    const hash = crypto.createHash(\"sha256\");\r\n\r\n    const files = await this.getFilesRecursively(dirPath);\r\n\r\n    for (const file of files.sort()) {\r\n      const relativePath = path.relative(dirPath, file);\r\n      hash.update(relativePath);\r\n\r\n      const stats = await fs.stat(file);\r\n      hash.update(stats.mtime.toISOString());\r\n      hash.update(stats.size.toString());\r\n    }\r\n\r\n    return hash.digest(\"hex\");\r\n  }\r\n\r\n  private async cleanupCache(): Promise<void> {\r\n    const totalSize = Array.from(this.cacheIndex.values()).reduce(\r\n      (sum, entry) => sum + entry.size,\r\n      0\r\n    );\r\n\r\n    if (totalSize <= this.maxCacheSize) {\r\n      return;\r\n    }\r\n\r\n    // Sort by last accessed time (oldest first)\r\n    const sortedEntries = Array.from(this.cacheIndex.entries()).sort(\r\n      ([, a], [, b]) => a.lastAccessed - b.lastAccessed\r\n    );\r\n\r\n    let cleanedSize = 0;\r\n    for (const [key, entry] of sortedEntries) {\r\n      await this.invalidate(key);\r\n      cleanedSize += entry.size;\r\n\r\n      if (totalSize - cleanedSize <= this.maxCacheSize * 0.8) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private async invalidate(cacheKey: string): Promise<void> {\r\n    const cachePath = path.join(this.cacheDir, cacheKey);\r\n    await fs.remove(cachePath);\r\n    this.cacheIndex.delete(cacheKey);\r\n  }\r\n\r\n  private getCacheTTL(): number {\r\n    return 7 * 24 * 60 * 60 * 1000; // 7 days\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Build CLI Integration\r\n\r\n### 1. Build Commands\r\n\r\n**CLI Integration for Build Operations:**\r\n\r\n```bash\r\n# Build commands\r\nfarm build                           # Build all targets for production\r\nfarm build --target frontend        # Build only frontend\r\nfarm build --target backend         # Build only backend\r\nfarm build --target docker          # Build Docker containers\r\nfarm build --env staging            # Build for staging environment\r\n\r\n# Development builds\r\nfarm build --dev                    # Development build with source maps\r\nfarm build --watch                  # Watch mode for continuous building\r\nfarm build --analyze                # Build with bundle analysis\r\n\r\n# Cache management\r\nfarm build --no-cache              # Disable build cache\r\nfarm build --clear-cache            # Clear build cache\r\nfarm cache status                   # Show cache statistics\r\nfarm cache clean                    # Clean old cache entries\r\n\r\n# Build analysis and optimization\r\nfarm build --profile               # Profile build performance\r\nfarm build --size-limit 5MB        # Fail if bundle exceeds size limit\r\nfarm analyze bundle                # Analyze bundle composition\r\nfarm optimize images               # Optimize image assets\r\n```\r\n\r\n### 2. CLI Implementation\r\n\r\n**Build CLI Commands:**\r\n\r\n```typescript\r\n// packages/cli/src/commands/build/index.ts\r\nexport function createBuildCommands(): Command {\r\n  const build = new Command(\"build\");\r\n  build.description(\"Build FARM application for production\");\r\n\r\n  build\r\n    .option(\r\n      \"-t, --target <targets...>\",\r\n      \"Build targets (frontend, backend, ai, docker)\",\r\n      [\"all\"]\r\n    )\r\n    .option(\"-e, --env <environment>\", \"Target environment\", \"production\")\r\n    .option(\"--dev\", \"Development build\")\r\n    .option(\"--watch\", \"Watch mode\")\r\n    .option(\"--analyze\", \"Generate bundle analysis\")\r\n    .option(\"--no-cache\", \"Disable build cache\")\r\n    .option(\"--clear-cache\", \"Clear build cache before building\")\r\n    .option(\"--profile\", \"Profile build performance\")\r\n    .option(\"--size-limit <limit>\", \"Bundle size limit\")\r\n    .action(async (options) => {\r\n      try {\r\n        const config = await loadBuildConfig(options);\r\n        const orchestrator = new BuildOrchestrator(config);\r\n\r\n        if (options.clearCache) {\r\n          await orchestrator.clearCache();\r\n        }\r\n\r\n        const result = await orchestrator.build(options.target);\r\n\r\n        if (result.success) {\r\n          console.log(\"\\n🎉 Build completed successfully!\");\r\n          console.log(`📦 Artifacts: ${result.artifacts.length}`);\r\n          console.log(`⏱️  Duration: ${result.duration}ms`);\r\n\r\n          if (options.analyze) {\r\n            await openBundleAnalysis(result.artifacts);\r\n          }\r\n\r\n          if (options.sizeLimit) {\r\n            await checkSizeLimit(result.artifacts, options.sizeLimit);\r\n          }\r\n        } else {\r\n          console.error(\"❌ Build failed:\", result.error);\r\n          process.exit(1);\r\n        }\r\n      } catch (error) {\r\n        console.error(\"❌ Build error:\", error.message);\r\n        process.exit(1);\r\n      }\r\n    });\r\n\r\n  return build;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Performance Monitoring & Analytics\r\n\r\n### 1. Build Performance Tracking\r\n\r\n**Build Metrics and Optimization:**\r\n\r\n```typescript\r\n// packages/core/src/build/metrics.ts\r\nexport class BuildMetrics {\r\n  private metrics: BuildMetric[] = [];\r\n\r\n  startTiming(phase: string): () => void {\r\n    const startTime = Date.now();\r\n\r\n    return () => {\r\n      const duration = Date.now() - startTime;\r\n      this.metrics.push({\r\n        phase,\r\n        duration,\r\n        timestamp: new Date(),\r\n        memory: process.memoryUsage(),\r\n      });\r\n    };\r\n  }\r\n\r\n  recordBundleSize(target: string, size: number): void {\r\n    this.metrics.push({\r\n      phase: `${target}-bundle-size`,\r\n      duration: 0,\r\n      timestamp: new Date(),\r\n      metadata: { size },\r\n    });\r\n  }\r\n\r\n  generateReport(): BuildReport {\r\n    const totalDuration = this.metrics.reduce(\r\n      (sum, metric) => sum + metric.duration,\r\n      0\r\n    );\r\n\r\n    const phaseBreakdown = this.metrics.reduce((acc, metric) => {\r\n      acc[metric.phase] = (acc[metric.phase] || 0) + metric.duration;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n\r\n    const peakMemory = Math.max(\r\n      ...this.metrics.map((m) => m.memory?.heapUsed || 0)\r\n    );\r\n\r\n    return {\r\n      totalDuration,\r\n      phaseBreakdown,\r\n      peakMemory,\r\n      metrics: this.metrics,\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n_Status: ✅ Completed - Ready for implementation_\r\n\r\nThis build system architecture provides:\r\n\r\n- **Comprehensive build pipeline** for frontend, backend, and AI components\r\n- **Intelligent caching** for faster incremental builds\r\n- **Docker containerization** with multi-stage builds\r\n- **AI model optimization** and deployment preparation\r\n- **Performance monitoring** and build analytics\r\n- **CLI integration** for build management\r\n- **Environment-specific builds** with proper configuration\r\n- **Plugin integration** during build process\r\n",
      "excerpt": "The FARM build system provides a comprehensive, multi-stage build pipeline that optimizes React frontends, FastAPI backends, and AI models for production deploy...",
      "category": "architectural-sketches-detailed/phase2",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.778Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase2",
        "Build_system_architecture"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Build System Architecture",
          "id": "build-system-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "High-Level Build Architecture",
          "id": "high-level-build-architecture"
        },
        {
          "level": 2,
          "text": "Core Build Pipeline",
          "id": "core-build-pipeline"
        },
        {
          "level": 3,
          "text": "1. Build Orchestrator",
          "id": "1-build-orchestrator"
        },
        {
          "level": 3,
          "text": "2. Frontend Builder",
          "id": "2-frontend-builder"
        },
        {
          "level": 3,
          "text": "3. Backend Builder",
          "id": "3-backend-builder"
        },
        {
          "level": 3,
          "text": "4. AI Model Optimizer",
          "id": "4-ai-model-optimizer"
        },
        {
          "level": 3,
          "text": "5. Docker Builder",
          "id": "5-docker-builder"
        },
        {
          "level": 1,
          "text": "Multi-stage production Dockerfile for FARM application",
          "id": "multi-stage-production-dockerfile-for-farm-application"
        },
        {
          "level": 1,
          "text": "Install system dependencies",
          "id": "install-system-dependencies"
        },
        {
          "level": 1,
          "text": "Copy Python dependencies and application",
          "id": "copy-python-dependencies-and-application"
        },
        {
          "level": 1,
          "text": "Copy frontend build",
          "id": "copy-frontend-build"
        },
        {
          "level": 1,
          "text": "Create non-root user",
          "id": "create-non-root-user"
        },
        {
          "level": 1,
          "text": "Health check",
          "id": "health-check"
        },
        {
          "level": 1,
          "text": "Development Dockerfile with hot reload",
          "id": "development-dockerfile-with-hot-reload"
        },
        {
          "level": 1,
          "text": "Install Python",
          "id": "install-python"
        },
        {
          "level": 1,
          "text": "Install Node.js dependencies",
          "id": "install-nodejs-dependencies"
        },
        {
          "level": 1,
          "text": "Install Python dependencies",
          "id": "install-python-dependencies"
        },
        {
          "level": 1,
          "text": "Copy source code",
          "id": "copy-source-code"
        },
        {
          "level": 1,
          "text": "Expose ports for frontend and backend",
          "id": "expose-ports-for-frontend-and-backend"
        },
        {
          "level": 1,
          "text": "Start development servers",
          "id": "start-development-servers"
        },
        {
          "level": 1,
          "text": "Ollama AI service with pre-loaded models",
          "id": "ollama-ai-service-with-pre-loaded-models"
        },
        {
          "level": 1,
          "text": "Install curl for health checks",
          "id": "install-curl-for-health-checks"
        },
        {
          "level": 1,
          "text": "Start Ollama service and pull models",
          "id": "start-ollama-service-and-pull-models"
        },
        {
          "level": 1,
          "text": "Health check",
          "id": "health-check"
        },
        {
          "level": 2,
          "text": "Build Cache System",
          "id": "build-cache-system"
        },
        {
          "level": 3,
          "text": "1. Intelligent Build Caching",
          "id": "1-intelligent-build-caching"
        },
        {
          "level": 2,
          "text": "Build CLI Integration",
          "id": "build-cli-integration"
        },
        {
          "level": 3,
          "text": "1. Build Commands",
          "id": "1-build-commands"
        },
        {
          "level": 1,
          "text": "Build commands",
          "id": "build-commands"
        },
        {
          "level": 1,
          "text": "Development builds",
          "id": "development-builds"
        },
        {
          "level": 1,
          "text": "Cache management",
          "id": "cache-management"
        },
        {
          "level": 1,
          "text": "Build analysis and optimization",
          "id": "build-analysis-and-optimization"
        },
        {
          "level": 3,
          "text": "2. CLI Implementation",
          "id": "2-cli-implementation"
        },
        {
          "level": 2,
          "text": "Performance Monitoring & Analytics",
          "id": "performance-monitoring-analytics"
        },
        {
          "level": 3,
          "text": "1. Build Performance Tracking",
          "id": "1-build-performance-tracking"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase2-database_integration_architecture",
      "title": "Database_integration_architecture",
      "url": "/architectural-sketches-detailed/phase2/database_integration_architecture",
      "content": "# Database Integration Architecture\r\n\r\n## Overview\r\n\r\nThe FARM database integration provides a MongoDB-first approach with flexible multi-database support through an abstraction layer. It features type-safe schema definitions, automatic migrations, connection pooling, and seamless integration with the authentication system and code generation pipeline. The architecture supports both document and relational databases while maintaining a consistent developer experience.\r\n\r\n---\r\n\r\n## High-Level Database Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Database Integration                    │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │  MongoDB    │  │ PostgreSQL  │  │   MySQL     │  │ SQLite  │ │\r\n│  │  (Primary)  │  │ (Optional)  │  │ (Optional)  │  │  (Dev)  │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │   Beanie    │  │ SQLAlchemy  │  │  Database   │  │Migration│ │\r\n│  │    ODM      │  │    ORM      │  │ Abstraction │  │ System  │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Connection  │  │ Query       │  │ Schema      │  │ Type    │ │\r\n│  │   Pool      │  │ Builder     │  │Validation   │  │Generator│ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Database Models\r\n\r\n### 1. Enhanced Document Model Base\r\n\r\n**Type-Safe Document Foundation:**\r\n\r\n```python\r\n# apps/api/src/database/models/base.py\r\nfrom datetime import datetime, timezone\r\nfrom typing import Optional, Dict, Any, List, Type, TypeVar\r\nfrom beanie import Document, Indexed\r\nfrom pydantic import BaseModel, Field\r\nfrom bson import ObjectId\r\nimport inspect\r\n\r\n# Type variable for generic document operations\r\nDocumentType = TypeVar('DocumentType', bound='BaseDocument')\r\n\r\nclass TimestampMixin(BaseModel):\r\n    \"\"\"Mixin for automatic timestamp management\"\"\"\r\n    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\r\n    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        if 'created_at' not in data:\r\n            self.created_at = datetime.now(timezone.utc)\r\n        if 'updated_at' not in data:\r\n            self.updated_at = datetime.now(timezone.utc)\r\n\r\nclass SoftDeleteMixin(BaseModel):\r\n    \"\"\"Mixin for soft delete functionality\"\"\"\r\n    deleted_at: Optional[datetime] = None\r\n    is_deleted: bool = False\r\n\r\n    def soft_delete(self):\r\n        \"\"\"Mark document as deleted\"\"\"\r\n        self.deleted_at = datetime.now(timezone.utc)\r\n        self.is_deleted = True\r\n\r\n    def restore(self):\r\n        \"\"\"Restore soft-deleted document\"\"\"\r\n        self.deleted_at = None\r\n        self.is_deleted = False\r\n\r\nclass AuditMixin(BaseModel):\r\n    \"\"\"Mixin for audit trail\"\"\"\r\n    created_by: Optional[str] = None  # User ID\r\n    updated_by: Optional[str] = None  # User ID\r\n    version: int = 1\r\n\r\n    def increment_version(self, user_id: Optional[str] = None):\r\n        \"\"\"Increment version and set updated_by\"\"\"\r\n        self.version += 1\r\n        self.updated_by = user_id\r\n\r\nclass MetadataMixin(BaseModel):\r\n    \"\"\"Mixin for flexible metadata\"\"\"\r\n    metadata: Dict[str, Any] = Field(default_factory=dict)\r\n    tags: List[str] = Field(default_factory=list)\r\n\r\n    def add_tag(self, tag: str):\r\n        \"\"\"Add tag if not already present\"\"\"\r\n        if tag not in self.tags:\r\n            self.tags.append(tag)\r\n\r\n    def remove_tag(self, tag: str):\r\n        \"\"\"Remove tag if present\"\"\"\r\n        if tag in self.tags:\r\n            self.tags.remove(tag)\r\n\r\n    def set_metadata(self, key: str, value: Any):\r\n        \"\"\"Set metadata value\"\"\"\r\n        self.metadata[key] = value\r\n\r\n    def get_metadata(self, key: str, default: Any = None) -> Any:\r\n        \"\"\"Get metadata value\"\"\"\r\n        return self.metadata.get(key, default)\r\n\r\nclass BaseDocument(Document, TimestampMixin, SoftDeleteMixin, AuditMixin, MetadataMixin):\r\n    \"\"\"Enhanced base document with common functionality\"\"\"\r\n\r\n    class Settings:\r\n        # Enable automatic index creation\r\n        use_enum_values = True\r\n        validate_on_save = True\r\n\r\n        # Common indexes for all documents\r\n        indexes = [\r\n            \"created_at\",\r\n            \"updated_at\",\r\n            \"is_deleted\",\r\n            \"tags\"\r\n        ]\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n\r\n        # Auto-set audit fields if not provided\r\n        if hasattr(self, '_current_user_id'):\r\n            if not self.created_by:\r\n                self.created_by = self._current_user_id\r\n            if not self.updated_by:\r\n                self.updated_by = self._current_user_id\r\n\r\n    async def save(self, **kwargs) -> 'BaseDocument':\r\n        \"\"\"Enhanced save with automatic timestamp and version management\"\"\"\r\n        self.updated_at = datetime.now(timezone.utc)\r\n\r\n        # Increment version for existing documents\r\n        if self.id:\r\n            self.increment_version()\r\n\r\n        return await super().save(**kwargs)\r\n\r\n    @classmethod\r\n    async def find_active(cls: Type[DocumentType], *args, **kwargs) -> List[DocumentType]:\r\n        \"\"\"Find non-deleted documents\"\"\"\r\n        return await cls.find(cls.is_deleted == False, *args, **kwargs).to_list()\r\n\r\n    @classmethod\r\n    async def find_by_id_active(cls: Type[DocumentType], doc_id: str) -> Optional[DocumentType]:\r\n        \"\"\"Find active document by ID\"\"\"\r\n        try:\r\n            return await cls.find_one(\r\n                cls.id == ObjectId(doc_id),\r\n                cls.is_deleted == False\r\n            )\r\n        except:\r\n            return None\r\n\r\n    @classmethod\r\n    async def count_active(cls: Type[DocumentType]) -> int:\r\n        \"\"\"Count non-deleted documents\"\"\"\r\n        return await cls.find(cls.is_deleted == False).count()\r\n\r\n    def to_dict(self, exclude_none: bool = True, exclude_unset: bool = False) -> Dict[str, Any]:\r\n        \"\"\"Convert document to dictionary with string ObjectId\"\"\"\r\n        data = self.dict(exclude_none=exclude_none, exclude_unset=exclude_unset)\r\n        if 'id' in data and isinstance(data['id'], ObjectId):\r\n            data['id'] = str(data['id'])\r\n        return data\r\n\r\n    @classmethod\r\n    def get_collection_name(cls) -> str:\r\n        \"\"\"Get MongoDB collection name\"\"\"\r\n        if hasattr(cls.Settings, 'collection'):\r\n            return cls.Settings.collection\r\n        return cls.__name__.lower()\r\n\r\n    @classmethod\r\n    def get_indexes(cls) -> List[str]:\r\n        \"\"\"Get all indexes for the collection\"\"\"\r\n        base_indexes = getattr(cls.Settings, 'indexes', [])\r\n        parent_indexes = []\r\n\r\n        # Collect indexes from parent classes\r\n        for base in cls.__mro__:\r\n            if hasattr(base, 'Settings') and hasattr(base.Settings, 'indexes'):\r\n                parent_indexes.extend(base.Settings.indexes)\r\n\r\n        # Combine and deduplicate\r\n        all_indexes = list(set(base_indexes + parent_indexes))\r\n        return all_indexes\r\n\r\nclass SearchableMixin(BaseModel):\r\n    \"\"\"Mixin for full-text search capabilities\"\"\"\r\n    search_vector: Optional[str] = None  # Computed search text\r\n\r\n    def update_search_vector(self, fields: List[str]):\r\n        \"\"\"Update search vector from specified fields\"\"\"\r\n        search_text = []\r\n        for field in fields:\r\n            value = getattr(self, field, None)\r\n            if value:\r\n                if isinstance(value, str):\r\n                    search_text.append(value)\r\n                elif isinstance(value, list):\r\n                    search_text.extend([str(v) for v in value])\r\n                else:\r\n                    search_text.append(str(value))\r\n\r\n        self.search_vector = ' '.join(search_text).lower()\r\n\r\n    @classmethod\r\n    async def search(cls: Type[DocumentType], query: str, limit: int = 20) -> List[DocumentType]:\r\n        \"\"\"Simple text search using regex\"\"\"\r\n        if not query.strip():\r\n            return []\r\n\r\n        # Create case-insensitive regex pattern\r\n        pattern = f\".*{query.strip()}.*\"\r\n\r\n        return await cls.find(\r\n            {\"search_vector\": {\"$regex\": pattern, \"$options\": \"i\"}},\r\n            cls.is_deleted == False\r\n        ).limit(limit).to_list()\r\n```\r\n\r\n### 2. Enhanced User Model Integration\r\n\r\n**User Model with Database Integration:**\r\n\r\n```python\r\n# apps/api/src/database/models/user.py\r\nfrom typing import List, Optional, Dict, Any\r\nfrom beanie import Indexed\r\nfrom pydantic import BaseModel, Field, EmailStr\r\nfrom enum import Enum\r\n\r\nfrom .base import BaseDocument, SearchableMixin\r\nfrom ..indexes import create_user_indexes\r\n\r\nclass UserStatus(str, Enum):\r\n    ACTIVE = \"active\"\r\n    INACTIVE = \"inactive\"\r\n    SUSPENDED = \"suspended\"\r\n    PENDING_VERIFICATION = \"pending_verification\"\r\n\r\nclass AuthProvider(str, Enum):\r\n    LOCAL = \"local\"\r\n    GOOGLE = \"google\"\r\n    GITHUB = \"github\"\r\n    MICROSOFT = \"microsoft\"\r\n    APPLE = \"apple\"\r\n    SAML = \"saml\"\r\n\r\nclass UserProfile(BaseModel):\r\n    \"\"\"User profile information\"\"\"\r\n    first_name: Optional[str] = None\r\n    last_name: Optional[str] = None\r\n    display_name: Optional[str] = None\r\n    avatar_url: Optional[str] = None\r\n    bio: Optional[str] = None\r\n    website: Optional[str] = None\r\n    timezone: str = \"UTC\"\r\n    locale: str = \"en\"\r\n    preferences: Dict[str, Any] = Field(default_factory=dict)\r\n\r\n    def get_full_name(self) -> str:\r\n        \"\"\"Get user's full name\"\"\"\r\n        if self.first_name and self.last_name:\r\n            return f\"{self.first_name} {self.last_name}\"\r\n        elif self.display_name:\r\n            return self.display_name\r\n        elif self.first_name:\r\n            return self.first_name\r\n        return \"\"\r\n\r\nclass AuthMetadata(BaseModel):\r\n    \"\"\"Authentication metadata\"\"\"\r\n    provider: AuthProvider = AuthProvider.LOCAL\r\n    provider_id: Optional[str] = None\r\n    provider_data: Dict[str, Any] = Field(default_factory=dict)\r\n    password_changed_at: Optional[datetime] = None\r\n    last_login_at: Optional[datetime] = None\r\n    login_count: int = 0\r\n    failed_login_attempts: int = 0\r\n    account_locked_until: Optional[datetime] = None\r\n    two_factor_enabled: bool = False\r\n    two_factor_secret: Optional[str] = None\r\n    backup_codes: List[str] = Field(default_factory=list)\r\n\r\nclass AIPreferences(BaseModel):\r\n    \"\"\"AI-specific user preferences\"\"\"\r\n    preferred_model: str = \"llama3.1\"\r\n    preferred_provider: str = \"ollama\"\r\n    temperature: float = 0.7\r\n    max_tokens: int = 1000\r\n    system_prompt: Optional[str] = None\r\n    conversation_style: str = \"helpful\"\r\n    language: str = \"en\"\r\n    enable_memory: bool = True\r\n    enable_web_search: bool = False\r\n\r\nclass User(BaseDocument, SearchableMixin):\r\n    \"\"\"Enhanced user model with comprehensive features\"\"\"\r\n\r\n    # Core identity fields\r\n    email: Indexed(EmailStr, unique=True)\r\n    username: Optional[Indexed(str, unique=True)] = None\r\n    password_hash: Optional[str] = None\r\n\r\n    # Profile information\r\n    profile: UserProfile = Field(default_factory=UserProfile)\r\n\r\n    # Authentication metadata\r\n    auth: AuthMetadata = Field(default_factory=AuthMetadata)\r\n\r\n    # Status and verification\r\n    status: UserStatus = UserStatus.PENDING_VERIFICATION\r\n    email_verified: bool = False\r\n    email_verification_token: Optional[str] = None\r\n    password_reset_token: Optional[str] = None\r\n    password_reset_expires: Optional[datetime] = None\r\n\r\n    # Role-based access control\r\n    roles: List[str] = Field(default_factory=list)\r\n    permissions: List[str] = Field(default_factory=list)\r\n\r\n    # AI integration\r\n    ai_preferences: AIPreferences = Field(default_factory=AIPreferences)\r\n    ai_usage_stats: Dict[str, Any] = Field(default_factory=dict)\r\n\r\n    # Activity tracking\r\n    last_active_at: Optional[datetime] = None\r\n    login_sessions: List[Dict[str, Any]] = Field(default_factory=list)\r\n\r\n    class Settings:\r\n        collection = \"users\"\r\n        indexes = [\r\n            \"email\",\r\n            \"username\",\r\n            \"status\",\r\n            \"roles\",\r\n            \"auth.provider\",\r\n            \"email_verified\",\r\n            \"last_active_at\",\r\n            # Compound indexes for efficient queries\r\n            [(\"status\", 1), (\"email_verified\", 1)],\r\n            [(\"auth.provider\", 1), (\"auth.provider_id\", 1)],\r\n            [(\"roles\", 1), (\"status\", 1)],\r\n            # Search index\r\n            \"search_vector\"\r\n        ]\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self.update_search_vector(['email', 'username', 'profile.first_name', 'profile.last_name'])\r\n\r\n    async def save(self, **kwargs) -> 'User':\r\n        \"\"\"Enhanced save with search vector update\"\"\"\r\n        self.update_search_vector(['email', 'username', 'profile.first_name', 'profile.last_name'])\r\n        return await super().save(**kwargs)\r\n\r\n    # Role and permission methods\r\n    def has_role(self, role: str) -> bool:\r\n        \"\"\"Check if user has specific role\"\"\"\r\n        return role in self.roles\r\n\r\n    def has_any_role(self, roles: List[str]) -> bool:\r\n        \"\"\"Check if user has any of the specified roles\"\"\"\r\n        return any(role in self.roles for role in roles)\r\n\r\n    def has_permission(self, permission: str) -> bool:\r\n        \"\"\"Check if user has specific permission\"\"\"\r\n        return permission in self.permissions\r\n\r\n    def has_any_permission(self, permissions: List[str]) -> bool:\r\n        \"\"\"Check if user has any of the specified permissions\"\"\"\r\n        return any(perm in self.permissions for perm in permissions)\r\n\r\n    def add_role(self, role: str) -> None:\r\n        \"\"\"Add role to user\"\"\"\r\n        if role not in self.roles:\r\n            self.roles.append(role)\r\n\r\n    def remove_role(self, role: str) -> None:\r\n        \"\"\"Remove role from user\"\"\"\r\n        if role in self.roles:\r\n            self.roles.remove(role)\r\n\r\n    def add_permission(self, permission: str) -> None:\r\n        \"\"\"Add permission to user\"\"\"\r\n        if permission not in self.permissions:\r\n            self.permissions.append(permission)\r\n\r\n    def remove_permission(self, permission: str) -> None:\r\n        \"\"\"Remove permission from user\"\"\"\r\n        if permission in self.permissions:\r\n            self.permissions.remove(permission)\r\n\r\n    # Authentication methods\r\n    def is_locked(self) -> bool:\r\n        \"\"\"Check if account is locked\"\"\"\r\n        if not self.auth.account_locked_until:\r\n            return False\r\n        return datetime.now(timezone.utc) < self.auth.account_locked_until\r\n\r\n    def can_login(self) -> bool:\r\n        \"\"\"Check if user can login\"\"\"\r\n        return (\r\n            self.status == UserStatus.ACTIVE and\r\n            not self.is_locked() and\r\n            self.email_verified and\r\n            not self.is_deleted\r\n        )\r\n\r\n    async def update_login_info(self, session_info: Optional[Dict[str, Any]] = None) -> None:\r\n        \"\"\"Update login metadata\"\"\"\r\n        now = datetime.now(timezone.utc)\r\n        self.auth.last_login_at = now\r\n        self.auth.login_count += 1\r\n        self.auth.failed_login_attempts = 0\r\n        self.last_active_at = now\r\n\r\n        # Track login session\r\n        if session_info:\r\n            self.login_sessions.append({\r\n                \"login_at\": now,\r\n                \"ip_address\": session_info.get(\"ip_address\"),\r\n                \"user_agent\": session_info.get(\"user_agent\"),\r\n                \"device\": session_info.get(\"device\")\r\n            })\r\n\r\n            # Keep only last 10 sessions\r\n            if len(self.login_sessions) > 10:\r\n                self.login_sessions = self.login_sessions[-10:]\r\n\r\n        await self.save()\r\n\r\n    async def record_failed_login(self) -> None:\r\n        \"\"\"Record failed login attempt\"\"\"\r\n        self.auth.failed_login_attempts += 1\r\n\r\n        # Lock account after 5 failed attempts\r\n        if self.auth.failed_login_attempts >= 5:\r\n            self.auth.account_locked_until = (\r\n                datetime.now(timezone.utc) + timedelta(minutes=30)\r\n            )\r\n\r\n        await self.save()\r\n\r\n    # AI integration methods\r\n    def get_ai_access_level(self) -> str:\r\n        \"\"\"Get user's AI access level based on roles\"\"\"\r\n        if self.has_role(\"admin\"):\r\n            return \"admin\"\r\n        elif self.has_any_role([\"premium\", \"pro\", \"advanced\"]):\r\n            return \"advanced\"\r\n        else:\r\n            return \"basic\"\r\n\r\n    async def record_ai_usage(self, provider: str, model: str, tokens_used: int, cost: float = 0.0) -> None:\r\n        \"\"\"Record AI usage for analytics and billing\"\"\"\r\n        today = datetime.now(timezone.utc).date().isoformat()\r\n\r\n        # Initialize usage stats if not present\r\n        if \"daily_usage\" not in self.ai_usage_stats:\r\n            self.ai_usage_stats[\"daily_usage\"] = {}\r\n\r\n        if today not in self.ai_usage_stats[\"daily_usage\"]:\r\n            self.ai_usage_stats[\"daily_usage\"][today] = {\r\n                \"requests\": 0,\r\n                \"tokens\": 0,\r\n                \"cost\": 0.0,\r\n                \"by_provider\": {}\r\n            }\r\n\r\n        # Update daily stats\r\n        daily_stats = self.ai_usage_stats[\"daily_usage\"][today]\r\n        daily_stats[\"requests\"] += 1\r\n        daily_stats[\"tokens\"] += tokens_used\r\n        daily_stats[\"cost\"] += cost\r\n\r\n        # Update provider stats\r\n        if provider not in daily_stats[\"by_provider\"]:\r\n            daily_stats[\"by_provider\"][provider] = {\r\n                \"requests\": 0,\r\n                \"tokens\": 0,\r\n                \"cost\": 0.0\r\n            }\r\n\r\n        provider_stats = daily_stats[\"by_provider\"][provider]\r\n        provider_stats[\"requests\"] += 1\r\n        provider_stats[\"tokens\"] += tokens_used\r\n        provider_stats[\"cost\"] += cost\r\n\r\n        # Update total stats\r\n        if \"total_usage\" not in self.ai_usage_stats:\r\n            self.ai_usage_stats[\"total_usage\"] = {\r\n                \"requests\": 0,\r\n                \"tokens\": 0,\r\n                \"cost\": 0.0\r\n            }\r\n\r\n        total_stats = self.ai_usage_stats[\"total_usage\"]\r\n        total_stats[\"requests\"] += 1\r\n        total_stats[\"tokens\"] += tokens_used\r\n        total_stats[\"cost\"] += cost\r\n\r\n        await self.save()\r\n\r\n    def get_ai_usage_today(self) -> Dict[str, Any]:\r\n        \"\"\"Get today's AI usage statistics\"\"\"\r\n        today = datetime.now(timezone.utc).date().isoformat()\r\n        return self.ai_usage_stats.get(\"daily_usage\", {}).get(today, {\r\n            \"requests\": 0,\r\n            \"tokens\": 0,\r\n            \"cost\": 0.0,\r\n            \"by_provider\": {}\r\n        })\r\n\r\n    # Utility methods\r\n    @property\r\n    def display_name(self) -> str:\r\n        \"\"\"Get user's display name\"\"\"\r\n        if self.profile.display_name:\r\n            return self.profile.display_name\r\n        full_name = self.profile.get_full_name()\r\n        if full_name:\r\n            return full_name\r\n        elif self.username:\r\n            return self.username\r\n        else:\r\n            return self.email\r\n\r\n    @classmethod\r\n    async def find_by_email(cls, email: str) -> Optional['User']:\r\n        \"\"\"Find user by email\"\"\"\r\n        return await cls.find_one(cls.email == email.lower())\r\n\r\n    @classmethod\r\n    async def find_by_username(cls, username: str) -> Optional['User']:\r\n        \"\"\"Find user by username\"\"\"\r\n        return await cls.find_one(cls.username == username.lower())\r\n\r\n    @classmethod\r\n    async def find_by_oauth(cls, provider: str, provider_id: str) -> Optional['User']:\r\n        \"\"\"Find user by OAuth provider\"\"\"\r\n        return await cls.find_one(\r\n            cls.auth.provider == provider,\r\n            cls.auth.provider_id == provider_id\r\n        )\r\n\r\n    @classmethod\r\n    async def get_active_users_count(cls) -> int:\r\n        \"\"\"Get count of active users\"\"\"\r\n        return await cls.find(\r\n            cls.status == UserStatus.ACTIVE,\r\n            cls.is_deleted == False\r\n        ).count()\r\n\r\n    @classmethod\r\n    async def get_recent_users(cls, days: int = 7, limit: int = 50) -> List['User']:\r\n        \"\"\"Get recently registered users\"\"\"\r\n        since = datetime.now(timezone.utc) - timedelta(days=days)\r\n        return await cls.find(\r\n            cls.created_at >= since,\r\n            cls.is_deleted == False\r\n        ).sort(\"-created_at\").limit(limit).to_list()\r\n```\r\n\r\n---\r\n\r\n## Database Abstraction Layer\r\n\r\n### 1. Database Provider Interface\r\n\r\n**Multi-Database Support Architecture:**\r\n\r\n```python\r\n# apps/api/src/database/providers/base.py\r\nfrom abc import ABC, abstractmethod\r\nfrom typing import Any, Dict, List, Optional, Type, TypeVar, Generic\r\nfrom pydantic import BaseModel\r\n\r\nDatabaseModel = TypeVar('DatabaseModel')\r\n\r\nclass DatabaseProvider(ABC, Generic[DatabaseModel]):\r\n    \"\"\"Abstract base class for database providers\"\"\"\r\n\r\n    def __init__(self, config: Dict[str, Any]):\r\n        self.config = config\r\n        self.connection = None\r\n        self.is_connected = False\r\n\r\n    @abstractmethod\r\n    async def connect(self) -> None:\r\n        \"\"\"Establish database connection\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def disconnect(self) -> None:\r\n        \"\"\"Close database connection\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def create_indexes(self, model_class: Type[DatabaseModel]) -> None:\r\n        \"\"\"Create database indexes for model\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def migrate_schema(self, migrations: List[Dict[str, Any]]) -> None:\r\n        \"\"\"Apply schema migrations\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def health_check(self) -> Dict[str, Any]:\r\n        \"\"\"Check database health and return status\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def get_stats(self) -> Dict[str, Any]:\r\n        \"\"\"Get database performance statistics\"\"\"\r\n        pass\r\n\r\nclass QueryBuilder(ABC):\r\n    \"\"\"Abstract query builder for cross-database queries\"\"\"\r\n\r\n    @abstractmethod\r\n    def find(self, conditions: Dict[str, Any]) -> 'QueryBuilder':\r\n        \"\"\"Add find conditions\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def sort(self, field: str, direction: int = 1) -> 'QueryBuilder':\r\n        \"\"\"Add sorting\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def limit(self, count: int) -> 'QueryBuilder':\r\n        \"\"\"Add limit\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def skip(self, count: int) -> 'QueryBuilder':\r\n        \"\"\"Add skip/offset\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def to_list(self) -> List[DatabaseModel]:\r\n        \"\"\"Execute query and return results\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def count(self) -> int:\r\n        \"\"\"Count matching documents\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def first(self) -> Optional[DatabaseModel]:\r\n        \"\"\"Get first matching document\"\"\"\r\n        pass\r\n\r\nclass DatabaseTransaction(ABC):\r\n    \"\"\"Abstract transaction context manager\"\"\"\r\n\r\n    @abstractmethod\r\n    async def __aenter__(self):\r\n        \"\"\"Start transaction\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\r\n        \"\"\"Commit or rollback transaction\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def commit(self) -> None:\r\n        \"\"\"Commit transaction\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    async def rollback(self) -> None:\r\n        \"\"\"Rollback transaction\"\"\"\r\n        pass\r\n```\r\n\r\n### 2. MongoDB Provider Implementation\r\n\r\n**Primary MongoDB Provider:**\r\n\r\n```python\r\n# apps/api/src/database/providers/mongodb.py\r\nimport motor.motor_asyncio\r\nfrom beanie import init_beanie\r\nfrom typing import Dict, Any, List, Type, Optional\r\nfrom pymongo import IndexModel\r\nimport logging\r\n\r\nfrom .base import DatabaseProvider, QueryBuilder, DatabaseTransaction\r\nfrom ..models.base import BaseDocument\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass MongoDBProvider(DatabaseProvider[BaseDocument]):\r\n    \"\"\"MongoDB provider using Beanie ODM\"\"\"\r\n\r\n    def __init__(self, config: Dict[str, Any]):\r\n        super().__init__(config)\r\n        self.client = None\r\n        self.database = None\r\n        self.document_models = []\r\n\r\n    async def connect(self) -> None:\r\n        \"\"\"Establish MongoDB connection\"\"\"\r\n        try:\r\n            # Create MongoDB client\r\n            self.client = motor.motor_asyncio.AsyncIOMotorClient(\r\n                self.config[\"url\"],\r\n                maxPoolSize=self.config.get(\"max_pool_size\", 100),\r\n                minPoolSize=self.config.get(\"min_pool_size\", 10),\r\n                serverSelectionTimeoutMS=self.config.get(\"server_selection_timeout\", 5000),\r\n                connectTimeoutMS=self.config.get(\"connect_timeout\", 10000),\r\n                socketTimeoutMS=self.config.get(\"socket_timeout\", 20000),\r\n            )\r\n\r\n            # Get database\r\n            db_name = self.config.get(\"database\") or self.config[\"url\"].split(\"/\")[-1]\r\n            self.database = self.client[db_name]\r\n\r\n            # Test connection\r\n            await self.client.admin.command('ping')\r\n\r\n            # Initialize Beanie with document models\r\n            if self.document_models:\r\n                await init_beanie(\r\n                    database=self.database,\r\n                    document_models=self.document_models\r\n                )\r\n\r\n            self.is_connected = True\r\n            logger.info(f\"✅ Connected to MongoDB: {db_name}\")\r\n\r\n        except Exception as e:\r\n            logger.error(f\"❌ Failed to connect to MongoDB: {e}\")\r\n            raise\r\n\r\n    async def disconnect(self) -> None:\r\n        \"\"\"Close MongoDB connection\"\"\"\r\n        if self.client:\r\n            self.client.close()\r\n            self.is_connected = False\r\n            logger.info(\"📴 Disconnected from MongoDB\")\r\n\r\n    def register_model(self, model_class: Type[BaseDocument]) -> None:\r\n        \"\"\"Register document model for initialization\"\"\"\r\n        if model_class not in self.document_models:\r\n            self.document_models.append(model_class)\r\n\r\n    async def create_indexes(self, model_class: Type[BaseDocument]) -> None:\r\n        \"\"\"Create indexes for MongoDB collection\"\"\"\r\n        try:\r\n            collection = self.database[model_class.get_collection_name()]\r\n            indexes = model_class.get_indexes()\r\n\r\n            index_models = []\r\n            for index in indexes:\r\n                if isinstance(index, str):\r\n                    # Simple field index\r\n                    index_models.append(IndexModel([(index, 1)]))\r\n                elif isinstance(index, list):\r\n                    # Compound index\r\n                    index_spec = []\r\n                    for field_spec in index:\r\n                        if isinstance(field_spec, str):\r\n                            index_spec.append((field_spec, 1))\r\n                        elif isinstance(field_spec, tuple):\r\n                            index_spec.append(field_spec)\r\n                    index_models.append(IndexModel(index_spec))\r\n\r\n            if index_models:\r\n                await collection.create_indexes(index_models)\r\n                logger.info(f\"✅ Created indexes for {model_class.__name__}\")\r\n\r\n        except Exception as e:\r\n            logger.error(f\"❌ Failed to create indexes for {model_class.__name__}: {e}\")\r\n            raise\r\n\r\n    async def migrate_schema(self, migrations: List[Dict[str, Any]]) -> None:\r\n        \"\"\"Apply MongoDB schema migrations\"\"\"\r\n        migrations_collection = self.database[\"schema_migrations\"]\r\n\r\n        for migration in migrations:\r\n            # Check if migration already applied\r\n            existing = await migrations_collection.find_one({\"id\": migration[\"id\"]})\r\n            if existing:\r\n                logger.info(f\"⏭️ Skipping migration {migration['id']} (already applied)\")\r\n                continue\r\n\r\n            try:\r\n                logger.info(f\"🔄 Applying migration {migration['id']}: {migration['description']}\")\r\n\r\n                # Execute migration operations\r\n                for operation in migration[\"operations\"]:\r\n                    await self._execute_migration_operation(operation)\r\n\r\n                # Record successful migration\r\n                await migrations_collection.insert_one({\r\n                    \"id\": migration[\"id\"],\r\n                    \"description\": migration[\"description\"],\r\n                    \"applied_at\": datetime.now(timezone.utc)\r\n                })\r\n\r\n                logger.info(f\"✅ Migration {migration['id']} applied successfully\")\r\n\r\n            except Exception as e:\r\n                logger.error(f\"❌ Migration {migration['id']} failed: {e}\")\r\n                raise\r\n\r\n    async def _execute_migration_operation(self, operation: Dict[str, Any]) -> None:\r\n        \"\"\"Execute individual migration operation\"\"\"\r\n        op_type = operation[\"type\"]\r\n        collection_name = operation[\"collection\"]\r\n        collection = self.database[collection_name]\r\n\r\n        if op_type == \"create_index\":\r\n            await collection.create_index(operation[\"index\"])\r\n        elif op_type == \"drop_index\":\r\n            await collection.drop_index(operation[\"index\"])\r\n        elif op_type == \"rename_field\":\r\n            await collection.update_many(\r\n                {},\r\n                {\"$rename\": {operation[\"old_name\"]: operation[\"new_name\"]}}\r\n            )\r\n        elif op_type == \"add_field\":\r\n            await collection.update_many(\r\n                {operation[\"field\"]: {\"$exists\": False}},\r\n                {\"$set\": {operation[\"field\"]: operation[\"default_value\"]}}\r\n            )\r\n        elif op_type == \"remove_field\":\r\n            await collection.update_many(\r\n                {},\r\n                {\"$unset\": {operation[\"field\"]: \"\"}}\r\n            )\r\n        else:\r\n            raise ValueError(f\"Unknown migration operation: {op_type}\")\r\n\r\n    async def health_check(self) -> Dict[str, Any]:\r\n        \"\"\"Check MongoDB health\"\"\"\r\n        try:\r\n            # Test connection\r\n            await self.client.admin.command('ping')\r\n\r\n            # Get server status\r\n            server_status = await self.database.command(\"serverStatus\")\r\n\r\n            return {\r\n                \"status\": \"healthy\",\r\n                \"connected\": self.is_connected,\r\n                \"version\": server_status.get(\"version\", \"unknown\"),\r\n                \"uptime\": server_status.get(\"uptime\", 0),\r\n                \"connections\": {\r\n                    \"current\": server_status.get(\"connections\", {}).get(\"current\", 0),\r\n                    \"available\": server_status.get(\"connections\", {}).get(\"available\", 0)\r\n                }\r\n            }\r\n        except Exception as e:\r\n            return {\r\n                \"status\": \"unhealthy\",\r\n                \"connected\": False,\r\n                \"error\": str(e)\r\n            }\r\n\r\n    async def get_stats(self) -> Dict[str, Any]:\r\n        \"\"\"Get MongoDB performance statistics\"\"\"\r\n        try:\r\n            db_stats = await self.database.command(\"dbStats\")\r\n            server_status = await self.database.command(\"serverStatus\")\r\n\r\n            return {\r\n                \"database\": {\r\n                    \"collections\": db_stats.get(\"collections\", 0),\r\n                    \"objects\": db_stats.get(\"objects\", 0),\r\n                    \"data_size\": db_stats.get(\"dataSize\", 0),\r\n                    \"storage_size\": db_stats.get(\"storageSize\", 0),\r\n                    \"indexes\": db_stats.get(\"indexes\", 0),\r\n                    \"index_size\": db_stats.get(\"indexSize\", 0)\r\n                },\r\n                \"operations\": {\r\n                    \"insert\": server_status.get(\"opcounters\", {}).get(\"insert\", 0),\r\n                    \"query\": server_status.get(\"opcounters\", {}).get(\"query\", 0),\r\n                    \"update\": server_status.get(\"opcounters\", {}).get(\"update\", 0),\r\n                    \"delete\": server_status.get(\"opcounters\", {}).get(\"delete\", 0)\r\n                },\r\n                \"memory\": {\r\n                    \"resident\": server_status.get(\"mem\", {}).get(\"resident\", 0),\r\n                    \"virtual\": server_status.get(\"mem\", {}).get(\"virtual\", 0),\r\n                    \"mapped\": server_status.get(\"mem\", {}).get(\"mapped\", 0)\r\n                }\r\n            }\r\n        except Exception as e:\r\n            logger.error(f\"Failed to get MongoDB stats: {e}\")\r\n            return {}\r\n\r\nclass MongoDBTransaction(DatabaseTransaction):\r\n    \"\"\"MongoDB transaction context manager\"\"\"\r\n\r\n    def __init__(self, client):\r\n        self.client = client\r\n        self.session = None\r\n\r\n    async def __aenter__(self):\r\n        self.session = await self.client.start_session()\r\n        self.session.start_transaction()\r\n        return self\r\n\r\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\r\n        try:\r\n            if exc_type is None:\r\n                await self.session.commit_transaction()\r\n            else:\r\n                await self.session.abort_transaction()\r\n        finally:\r\n            await self.session.end_session()\r\n\r\n    async def commit(self) -> None:\r\n        if self.session:\r\n            await self.session.commit_transaction()\r\n\r\n    async def rollback(self) -> None:\r\n        if self.session:\r\n            await self.session.abort_transaction()\r\n```\r\n\r\n### 3. PostgreSQL Provider Implementation\r\n\r\n**Optional PostgreSQL Support:**\r\n\r\n```python\r\n# apps/api/src/database/providers/postgresql.py\r\nimport asyncpg\r\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\r\nfrom sqlalchemy.ext.declarative import declarative_base\r\nfrom sqlalchemy.orm import sessionmaker\r\nfrom typing import Dict, Any, List, Type, Optional\r\nimport logging\r\n\r\nfrom .base import DatabaseProvider, QueryBuilder, DatabaseTransaction\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nBase = declarative_base()\r\n\r\nclass PostgreSQLProvider(DatabaseProvider):\r\n    \"\"\"PostgreSQL provider using SQLAlchemy\"\"\"\r\n\r\n    def __init__(self, config: Dict[str, Any]):\r\n        super().__init__(config)\r\n        self.engine = None\r\n        self.session_maker = None\r\n        self.models = []\r\n\r\n    async def connect(self) -> None:\r\n        \"\"\"Establish PostgreSQL connection\"\"\"\r\n        try:\r\n            # Create async engine\r\n            self.engine = create_async_engine(\r\n                self.config[\"url\"],\r\n                pool_size=self.config.get(\"pool_size\", 20),\r\n                max_overflow=self.config.get(\"max_overflow\", 30),\r\n                pool_timeout=self.config.get(\"pool_timeout\", 30),\r\n                pool_recycle=self.config.get(\"pool_recycle\", 3600)\r\n            )\r\n\r\n            # Create session maker\r\n            self.session_maker = sessionmaker(\r\n                self.engine,\r\n                class_=AsyncSession,\r\n                expire_on_commit=False\r\n            )\r\n\r\n            # Test connection\r\n            async with self.engine.begin() as conn:\r\n                await conn.execute(\"SELECT 1\")\r\n\r\n            self.is_connected = True\r\n            logger.info(\"✅ Connected to PostgreSQL\")\r\n\r\n        except Exception as e:\r\n            logger.error(f\"❌ Failed to connect to PostgreSQL: {e}\")\r\n            raise\r\n\r\n    async def disconnect(self) -> None:\r\n        \"\"\"Close PostgreSQL connection\"\"\"\r\n        if self.engine:\r\n            await self.engine.dispose()\r\n            self.is_connected = False\r\n            logger.info(\"📴 Disconnected from PostgreSQL\")\r\n\r\n    def register_model(self, model_class: Type) -> None:\r\n        \"\"\"Register SQLAlchemy model\"\"\"\r\n        if model_class not in self.models:\r\n            self.models.append(model_class)\r\n\r\n    async def create_indexes(self, model_class: Type) -> None:\r\n        \"\"\"Create PostgreSQL indexes\"\"\"\r\n        # Indexes are typically defined in SQLAlchemy models\r\n        # This would create any additional indexes if needed\r\n        pass\r\n\r\n    async def migrate_schema(self, migrations: List[Dict[str, Any]]) -> None:\r\n        \"\"\"Apply PostgreSQL schema migrations using Alembic\"\"\"\r\n        # This would integrate with Alembic for schema migrations\r\n        # For now, simplified implementation\r\n        pass\r\n\r\n    async def health_check(self) -> Dict[str, Any]:\r\n        \"\"\"Check PostgreSQL health\"\"\"\r\n        try:\r\n            async with self.engine.begin() as conn:\r\n                result = await conn.execute(\"SELECT version()\")\r\n                version = result.scalar()\r\n\r\n                # Get connection stats\r\n                result = await conn.execute(\"\"\"\r\n                    SELECT\r\n                        count(*) as total_connections,\r\n                        count(*) FILTER (WHERE state = 'active') as active_connections\r\n                    FROM pg_stat_activity\r\n                \"\"\")\r\n                stats = result.fetchone()\r\n\r\n                return {\r\n                    \"status\": \"healthy\",\r\n                    \"connected\": self.is_connected,\r\n                    \"version\": version,\r\n                    \"connections\": {\r\n                        \"total\": stats[0],\r\n                        \"active\": stats[1]\r\n                    }\r\n                }\r\n        except Exception as e:\r\n            return {\r\n                \"status\": \"unhealthy\",\r\n                \"connected\": False,\r\n                \"error\": str(e)\r\n            }\r\n\r\n    async def get_stats(self) -> Dict[str, Any]:\r\n        \"\"\"Get PostgreSQL performance statistics\"\"\"\r\n        try:\r\n            async with self.engine.begin() as conn:\r\n                # Database size\r\n                result = await conn.execute(\"\"\"\r\n                    SELECT pg_database_size(current_database()) as db_size\r\n                \"\"\")\r\n                db_size = result.scalar()\r\n\r\n                # Table stats\r\n                result = await conn.execute(\"\"\"\r\n                    SELECT\r\n                        count(*) as table_count,\r\n                        sum(n_tup_ins) as total_inserts,\r\n                        sum(n_tup_upd) as total_updates,\r\n                        sum(n_tup_del) as total_deletes\r\n                    FROM pg_stat_user_tables\r\n                \"\"\")\r\n                table_stats = result.fetchone()\r\n\r\n                return {\r\n                    \"database\": {\r\n                        \"size\": db_size,\r\n                        \"tables\": table_stats[0]\r\n                    },\r\n                    \"operations\": {\r\n                        \"inserts\": table_stats[1] or 0,\r\n                        \"updates\": table_stats[2] or 0,\r\n                        \"deletes\": table_stats[3] or 0\r\n                    }\r\n                }\r\n        except Exception as e:\r\n            logger.error(f\"Failed to get PostgreSQL stats: {e}\")\r\n            return {}\r\n\r\nclass PostgreSQLTransaction(DatabaseTransaction):\r\n    \"\"\"PostgreSQL transaction context manager\"\"\"\r\n\r\n    def __init__(self, session_maker):\r\n        self.session_maker = session_maker\r\n        self.session = None\r\n\r\n    async def __aenter__(self):\r\n        self.session = self.session_maker()\r\n        await self.session.begin()\r\n        return self\r\n\r\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\r\n        try:\r\n            if exc_type is None:\r\n                await self.session.commit()\r\n            else:\r\n                await self.session.rollback()\r\n        finally:\r\n            await self.session.close()\r\n\r\n    async def commit(self) -> None:\r\n        if self.session:\r\n            await self.session.commit()\r\n\r\n    async def rollback(self) -> None:\r\n        if self.session:\r\n            await self.session.rollback()\r\n```\r\n\r\n---\r\n\r\n## Database Manager & Connection Pool\r\n\r\n### 1. Central Database Manager\r\n\r\n**Unified Database Management:**\r\n\r\n```python\r\n# apps/api/src/database/manager.py\r\nfrom typing import Dict, Any, Type, Optional, List\r\nimport asyncio\r\nimport logging\r\nfrom contextlib import asynccontextmanager\r\n\r\nfrom .providers.base import DatabaseProvider, DatabaseTransaction\r\nfrom .providers.mongodb import MongoDBProvider\r\nfrom .providers.postgresql import PostgreSQLProvider\r\nfrom .models.base import BaseDocument\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass DatabaseManager:\r\n    \"\"\"Central database management system\"\"\"\r\n\r\n    def __init__(self, config: Dict[str, Any]):\r\n        self.config = config\r\n        self.provider: Optional[DatabaseProvider] = None\r\n        self.provider_type = config.get(\"type\", \"mongodb\")\r\n        self.models: List[Type] = []\r\n        self.is_initialized = False\r\n\r\n    async def initialize(self) -> None:\r\n        \"\"\"Initialize database provider and connections\"\"\"\r\n        if self.is_initialized:\r\n            return\r\n\r\n        try:\r\n            # Create appropriate provider\r\n            if self.provider_type == \"mongodb\":\r\n                self.provider = MongoDBProvider(self.config)\r\n            elif self.provider_type == \"postgresql\":\r\n                self.provider = PostgreSQLProvider(self.config)\r\n            elif self.provider_type == \"mysql\":\r\n                # MySQL provider would be implemented similarly\r\n                raise NotImplementedError(\"MySQL provider not yet implemented\")\r\n            elif self.provider_type == \"sqlite\":\r\n                # SQLite provider for development\r\n                raise NotImplementedError(\"SQLite provider not yet implemented\")\r\n            else:\r\n                raise ValueError(f\"Unsupported database type: {self.provider_type}\")\r\n\r\n            # Register all models\r\n            for model in self.models:\r\n                self.provider.register_model(model)\r\n\r\n            # Connect to database\r\n            await self.provider.connect()\r\n\r\n            # Create indexes for all models\r\n            for model in self.models:\r\n                await self.provider.create_indexes(model)\r\n\r\n            self.is_initialized = True\r\n            logger.info(f\"✅ Database manager initialized with {self.provider_type}\")\r\n\r\n        except Exception as e:\r\n            logger.error(f\"❌ Failed to initialize database manager: {e}\")\r\n            raise\r\n\r\n    async def shutdown(self) -> None:\r\n        \"\"\"Shutdown database connections\"\"\"\r\n        if self.provider and self.provider.is_connected:\r\n            await self.provider.disconnect()\r\n            logger.info(\"📴 Database manager shutdown complete\")\r\n\r\n    def register_model(self, model_class: Type) -> None:\r\n        \"\"\"Register model class for database operations\"\"\"\r\n        if model_class not in self.models:\r\n            self.models.append(model_class)\r\n\r\n            # If already initialized, register with provider\r\n            if self.is_initialized and self.provider:\r\n                self.provider.register_model(model_class)\r\n\r\n    async def create_all_indexes(self) -> None:\r\n        \"\"\"Create indexes for all registered models\"\"\"\r\n        if not self.provider:\r\n            raise RuntimeError(\"Database not initialized\")\r\n\r\n        for model in self.models:\r\n            await self.provider.create_indexes(model)\r\n\r\n    async def migrate(self, migrations: List[Dict[str, Any]]) -> None:\r\n        \"\"\"Apply database migrations\"\"\"\r\n        if not self.provider:\r\n            raise RuntimeError(\"Database not initialized\")\r\n\r\n        await self.provider.migrate_schema(migrations)\r\n\r\n    async def health_check(self) -> Dict[str, Any]:\r\n        \"\"\"Check database health\"\"\"\r\n        if not self.provider:\r\n            return {\"status\": \"not_initialized\", \"connected\": False}\r\n\r\n        return await self.provider.health_check()\r\n\r\n    async def get_stats(self) -> Dict[str, Any]:\r\n        \"\"\"Get database performance statistics\"\"\"\r\n        if not self.provider:\r\n            return {}\r\n\r\n        return await self.provider.get_stats()\r\n\r\n    @asynccontextmanager\r\n    async def transaction(self) -> DatabaseTransaction:\r\n        \"\"\"Create database transaction context\"\"\"\r\n        if not self.provider:\r\n            raise RuntimeError(\"Database not initialized\")\r\n\r\n        if self.provider_type == \"mongodb\":\r\n            async with MongoDBTransaction(self.provider.client) as tx:\r\n                yield tx\r\n        elif self.provider_type == \"postgresql\":\r\n            async with PostgreSQLTransaction(self.provider.session_maker) as tx:\r\n                yield tx\r\n        else:\r\n            # For databases that don't support transactions, use no-op\r\n            yield NoOpTransaction()\r\n\r\nclass NoOpTransaction(DatabaseTransaction):\r\n    \"\"\"No-op transaction for databases that don't support transactions\"\"\"\r\n\r\n    async def __aenter__(self):\r\n        return self\r\n\r\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\r\n        pass\r\n\r\n    async def commit(self) -> None:\r\n        pass\r\n\r\n    async def rollback(self) -> None:\r\n        pass\r\n\r\n# Global database manager instance\r\ndb_manager = DatabaseManager({})\r\n\r\nasync def get_database_manager() -> DatabaseManager:\r\n    \"\"\"Get initialized database manager\"\"\"\r\n    if not db_manager.is_initialized:\r\n        raise RuntimeError(\"Database manager not initialized\")\r\n    return db_manager\r\n\r\nasync def init_database(config: Dict[str, Any]) -> DatabaseManager:\r\n    \"\"\"Initialize global database manager\"\"\"\r\n    global db_manager\r\n    db_manager = DatabaseManager(config)\r\n    await db_manager.initialize()\r\n    return db_manager\r\n```\r\n\r\n### 2. Connection Pool Management\r\n\r\n**Advanced Connection Pooling:**\r\n\r\n```python\r\n# apps/api/src/database/connection_pool.py\r\nimport asyncio\r\nfrom typing import Dict, Any, Optional\r\nfrom datetime import datetime, timedelta\r\nimport logging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass ConnectionPoolManager:\r\n    \"\"\"Advanced connection pool management\"\"\"\r\n\r\n    def __init__(self, provider: DatabaseProvider):\r\n        self.provider = provider\r\n        self.pool_stats = {\r\n            \"created\": 0,\r\n            \"destroyed\": 0,\r\n            \"active\": 0,\r\n            \"idle\": 0,\r\n            \"errors\": 0\r\n        }\r\n        self.connection_history = []\r\n        self.health_check_interval = 30  # seconds\r\n        self.health_check_task = None\r\n\r\n    async def start_health_monitoring(self) -> None:\r\n        \"\"\"Start periodic health checks\"\"\"\r\n        self.health_check_task = asyncio.create_task(self._health_check_loop())\r\n\r\n    async def stop_health_monitoring(self) -> None:\r\n        \"\"\"Stop health check monitoring\"\"\"\r\n        if self.health_check_task:\r\n            self.health_check_task.cancel()\r\n            try:\r\n                await self.health_check_task\r\n            except asyncio.CancelledError:\r\n                pass\r\n\r\n    async def _health_check_loop(self) -> None:\r\n        \"\"\"Periodic health check loop\"\"\"\r\n        while True:\r\n            try:\r\n                await asyncio.sleep(self.health_check_interval)\r\n                health = await self.provider.health_check()\r\n\r\n                # Log health status\r\n                if health.get(\"status\") != \"healthy\":\r\n                    logger.warning(f\"Database health check failed: {health}\")\r\n                    self.pool_stats[\"errors\"] += 1\r\n\r\n                # Record connection history\r\n                self.connection_history.append({\r\n                    \"timestamp\": datetime.utcnow(),\r\n                    \"health\": health,\r\n                    \"stats\": self.pool_stats.copy()\r\n                })\r\n\r\n                # Keep only last 100 health checks\r\n                if len(self.connection_history) > 100:\r\n                    self.connection_history = self.connection_history[-100:]\r\n\r\n            except asyncio.CancelledError:\r\n                break\r\n            except Exception as e:\r\n                logger.error(f\"Health check error: {e}\")\r\n                self.pool_stats[\"errors\"] += 1\r\n\r\n    def get_pool_metrics(self) -> Dict[str, Any]:\r\n        \"\"\"Get connection pool metrics\"\"\"\r\n        recent_history = [\r\n            h for h in self.connection_history\r\n            if h[\"timestamp\"] > datetime.utcnow() - timedelta(minutes=5)\r\n        ]\r\n\r\n        avg_connections = 0\r\n        if recent_history:\r\n            total_connections = sum(\r\n                h[\"health\"].get(\"connections\", {}).get(\"current\", 0)\r\n                for h in recent_history\r\n            )\r\n            avg_connections = total_connections / len(recent_history)\r\n\r\n        return {\r\n            \"pool_stats\": self.pool_stats,\r\n            \"recent_avg_connections\": avg_connections,\r\n            \"health_checks\": len(self.connection_history),\r\n            \"last_health_check\": (\r\n                self.connection_history[-1][\"timestamp\"]\r\n                if self.connection_history else None\r\n            )\r\n        }\r\n```\r\n\r\n---\r\n\r\n## Migration System\r\n\r\n### 1. Schema Migration Framework\r\n\r\n**Database-Agnostic Migration System:**\r\n\r\n```python\r\n# apps/api/src/database/migrations/manager.py\r\nimport os\r\nimport json\r\nfrom typing import List, Dict, Any, Optional\r\nfrom datetime import datetime, timezone\r\nimport logging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass MigrationManager:\r\n    \"\"\"Database migration management system\"\"\"\r\n\r\n    def __init__(self, database_manager: DatabaseManager):\r\n        self.db_manager = database_manager\r\n        self.migrations_dir = \"apps/api/migrations\"\r\n        self.migration_history = []\r\n\r\n    def create_migration(self, name: str, description: str = \"\") -> str:\r\n        \"\"\"Create new migration file\"\"\"\r\n        timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d_%H%M%S\")\r\n        migration_id = f\"{timestamp}_{name}\"\r\n\r\n        migration_template = {\r\n            \"id\": migration_id,\r\n            \"name\": name,\r\n            \"description\": description,\r\n            \"created_at\": datetime.now(timezone.utc).isoformat(),\r\n            \"operations\": []\r\n        }\r\n\r\n        # Create migrations directory if it doesn't exist\r\n        os.makedirs(self.migrations_dir, exist_ok=True)\r\n\r\n        # Write migration file\r\n        migration_file = os.path.join(self.migrations_dir, f\"{migration_id}.json\")\r\n        with open(migration_file, 'w') as f:\r\n            json.dump(migration_template, f, indent=2)\r\n\r\n        logger.info(f\"✅ Created migration: {migration_file}\")\r\n        return migration_id\r\n\r\n    def add_operation(self, migration_id: str, operation: Dict[str, Any]) -> None:\r\n        \"\"\"Add operation to existing migration\"\"\"\r\n        migration_file = os.path.join(self.migrations_dir, f\"{migration_id}.json\")\r\n\r\n        if not os.path.exists(migration_file):\r\n            raise FileNotFoundError(f\"Migration {migration_id} not found\")\r\n\r\n        with open(migration_file, 'r') as f:\r\n            migration = json.load(f)\r\n\r\n        migration[\"operations\"].append(operation)\r\n\r\n        with open(migration_file, 'w') as f:\r\n            json.dump(migration, f, indent=2)\r\n\r\n        logger.info(f\"➕ Added operation to migration {migration_id}\")\r\n\r\n    def load_migrations(self) -> List[Dict[str, Any]]:\r\n        \"\"\"Load all migration files\"\"\"\r\n        if not os.path.exists(self.migrations_dir):\r\n            return []\r\n\r\n        migrations = []\r\n        for filename in sorted(os.listdir(self.migrations_dir)):\r\n            if filename.endswith('.json'):\r\n                with open(os.path.join(self.migrations_dir, filename), 'r') as f:\r\n                    migration = json.load(f)\r\n                    migrations.append(migration)\r\n\r\n        return migrations\r\n\r\n    async def apply_migrations(self, target_migration: Optional[str] = None) -> None:\r\n        \"\"\"Apply pending migrations\"\"\"\r\n        migrations = self.load_migrations()\r\n\r\n        if target_migration:\r\n            # Apply migrations up to target\r\n            migrations = [m for m in migrations if m[\"id\"] <= target_migration]\r\n\r\n        await self.db_manager.migrate(migrations)\r\n        logger.info(f\"✅ Applied {len(migrations)} migrations\")\r\n\r\n    async def rollback_migration(self, migration_id: str) -> None:\r\n        \"\"\"Rollback specific migration (if supported)\"\"\"\r\n        # This would implement rollback logic\r\n        # Not all databases support easy rollbacks\r\n        raise NotImplementedError(\"Migration rollback not yet implemented\")\r\n\r\n    def generate_model_migration(self, model_class: Type, operation: str = \"create\") -> str:\r\n        \"\"\"Generate migration from model definition\"\"\"\r\n        model_name = model_class.__name__\r\n        collection_name = model_class.get_collection_name()\r\n\r\n        migration_id = self.create_migration(\r\n            f\"{operation}_{model_name.lower()}\",\r\n            f\"{operation.title()} {model_name} model\"\r\n        )\r\n\r\n        if operation == \"create\":\r\n            # Add create collection operation\r\n            self.add_operation(migration_id, {\r\n                \"type\": \"create_collection\",\r\n                \"collection\": collection_name,\r\n                \"schema\": self._extract_model_schema(model_class)\r\n            })\r\n\r\n            # Add indexes\r\n            indexes = model_class.get_indexes()\r\n            for index in indexes:\r\n                self.add_operation(migration_id, {\r\n                    \"type\": \"create_index\",\r\n                    \"collection\": collection_name,\r\n                    \"index\": index\r\n                })\r\n\r\n        return migration_id\r\n\r\n    def _extract_model_schema(self, model_class: Type) -> Dict[str, Any]:\r\n        \"\"\"Extract schema information from model class\"\"\"\r\n        # This would analyze the model and create a schema representation\r\n        # For now, simplified implementation\r\n        return {\r\n            \"type\": \"object\",\r\n            \"properties\": {},\r\n            \"required\": []\r\n        }\r\n\r\n# Migration operation builders\r\nclass MigrationOperations:\r\n    \"\"\"Helper class for building migration operations\"\"\"\r\n\r\n    @staticmethod\r\n    def create_index(collection: str, fields: List[str], unique: bool = False) -> Dict[str, Any]:\r\n        \"\"\"Create index operation\"\"\"\r\n        return {\r\n            \"type\": \"create_index\",\r\n            \"collection\": collection,\r\n            \"index\": fields,\r\n            \"unique\": unique\r\n        }\r\n\r\n    @staticmethod\r\n    def drop_index(collection: str, fields: List[str]) -> Dict[str, Any]:\r\n        \"\"\"Drop index operation\"\"\"\r\n        return {\r\n            \"type\": \"drop_index\",\r\n            \"collection\": collection,\r\n            \"index\": fields\r\n        }\r\n\r\n    @staticmethod\r\n    def add_field(collection: str, field: str, default_value: Any = None) -> Dict[str, Any]:\r\n        \"\"\"Add field operation\"\"\"\r\n        return {\r\n            \"type\": \"add_field\",\r\n            \"collection\": collection,\r\n            \"field\": field,\r\n            \"default_value\": default_value\r\n        }\r\n\r\n    @staticmethod\r\n    def remove_field(collection: str, field: str) -> Dict[str, Any]:\r\n        \"\"\"Remove field operation\"\"\"\r\n        return {\r\n            \"type\": \"remove_field\",\r\n            \"collection\": collection,\r\n            \"field\": field\r\n        }\r\n\r\n    @staticmethod\r\n    def rename_field(collection: str, old_name: str, new_name: str) -> Dict[str, Any]:\r\n        \"\"\"Rename field operation\"\"\"\r\n        return {\r\n            \"type\": \"rename_field\",\r\n            \"collection\": collection,\r\n            \"old_name\": old_name,\r\n            \"new_name\": new_name\r\n        }\r\n\r\n    @staticmethod\r\n    def rename_collection(old_name: str, new_name: str) -> Dict[str, Any]:\r\n        \"\"\"Rename collection operation\"\"\"\r\n        return {\r\n            \"type\": \"rename_collection\",\r\n            \"old_name\": old_name,\r\n            \"new_name\": new_name\r\n        }\r\n```\r\n\r\n---\r\n\r\n## Database CLI Commands\r\n\r\n### 1. Database Management Commands\r\n\r\n**CLI Integration for Database Operations:**\r\n\r\n```bash\r\n# Database connection management\r\nfarm db connect                     # Test database connection\r\nfarm db status                      # Show database status and health\r\nfarm db stats                       # Show database performance statistics\r\n\r\n# Schema and migration management\r\nfarm db migrate                     # Apply pending migrations\r\nfarm db migrate --target 20241201_120000  # Migrate to specific version\r\nfarm db rollback 20241201_120000    # Rollback to specific migration\r\nfarm db reset                       # Reset database (development only)\r\n\r\n# Migration creation\r\nfarm db migration create add_user_avatar    # Create new migration\r\nfarm db migration generate User             # Generate migration from model\r\nfarm db migration list                      # List all migrations\r\nfarm db migration status                    # Show migration status\r\n\r\n# Index management\r\nfarm db indexes create               # Create all missing indexes\r\nfarm db indexes list                 # List all indexes\r\nfarm db indexes optimize             # Optimize database indexes\r\n\r\n# Data management\r\nfarm db seed                         # Run database seeders\r\nfarm db seed --file users.json      # Seed specific data file\r\nfarm db backup                       # Create database backup\r\nfarm db restore backup.dump          # Restore from backup\r\n\r\n# Development utilities\r\nfarm db studio                       # Open database GUI (MongoDB Compass, pgAdmin, etc.)\r\nfarm db shell                        # Open database shell\r\nfarm db logs                         # Show database logs\r\n```\r\n\r\n### 2. CLI Implementation\r\n\r\n**Database CLI Commands:**\r\n\r\n```typescript\r\n// packages/cli/src/commands/db/index.ts\r\nimport { Command } from \"commander\";\r\nimport { DatabaseManager } from \"../../database/manager\";\r\nimport { MigrationManager } from \"../../database/migrations/manager\";\r\n\r\nexport function createDatabaseCommands(): Command {\r\n  const db = new Command(\"db\");\r\n  db.description(\"Database management commands\");\r\n\r\n  // Connection commands\r\n  db.command(\"connect\")\r\n    .description(\"Test database connection\")\r\n    .action(async () => {\r\n      try {\r\n        const config = await loadFarmConfig();\r\n        const dbManager = new DatabaseManager(config.database);\r\n        await dbManager.initialize();\r\n\r\n        const health = await dbManager.health_check();\r\n        if (health.status === \"healthy\") {\r\n          console.log(\"✅ Database connection successful\");\r\n          console.log(`Database: ${config.database.type}`);\r\n          console.log(`Version: ${health.version}`);\r\n        } else {\r\n          console.error(\"❌ Database connection failed\");\r\n          console.error(health.error);\r\n          process.exit(1);\r\n        }\r\n\r\n        await dbManager.shutdown();\r\n      } catch (error) {\r\n        console.error(\"❌ Database connection error:\", error.message);\r\n        process.exit(1);\r\n      }\r\n    });\r\n\r\n  db.command(\"status\")\r\n    .description(\"Show database status and health\")\r\n    .action(async () => {\r\n      const config = await loadFarmConfig();\r\n      const dbManager = new DatabaseManager(config.database);\r\n      await dbManager.initialize();\r\n\r\n      const health = await dbManager.health_check();\r\n      const stats = await dbManager.get_stats();\r\n\r\n      console.log(\"\\n🗄️  Database Status\");\r\n      console.log(\"─\".repeat(50));\r\n      console.log(\r\n        `Status: ${health.status === \"healthy\" ? \"✅ Healthy\" : \"❌ Unhealthy\"}`\r\n      );\r\n      console.log(`Type: ${config.database.type}`);\r\n      console.log(`Connected: ${health.connected ? \"Yes\" : \"No\"}`);\r\n\r\n      if (health.version) {\r\n        console.log(`Version: ${health.version}`);\r\n      }\r\n\r\n      if (health.connections) {\r\n        console.log(\"\\n📊 Connections\");\r\n        console.log(\r\n          `Current: ${\r\n            health.connections.current || health.connections.total || 0\r\n          }`\r\n        );\r\n        console.log(`Available: ${health.connections.available || \"N/A\"}`);\r\n      }\r\n\r\n      if (stats.database) {\r\n        console.log(\"\\n📈 Database Statistics\");\r\n        Object.entries(stats.database).forEach(([key, value]) => {\r\n          console.log(`${key}: ${value}`);\r\n        });\r\n      }\r\n\r\n      await dbManager.shutdown();\r\n    });\r\n\r\n  // Migration commands\r\n  const migration = db.command(\"migration\");\r\n\r\n  migration\r\n    .command(\"create <name>\")\r\n    .description(\"Create new migration\")\r\n    .option(\"-d, --description <desc>\", \"Migration description\")\r\n    .action(async (name: string, options: { description?: string }) => {\r\n      try {\r\n        const config = await loadFarmConfig();\r\n        const dbManager = new DatabaseManager(config.database);\r\n        const migrationManager = new MigrationManager(dbManager);\r\n\r\n        const migrationId = migrationManager.create_migration(\r\n          name,\r\n          options.description || \"\"\r\n        );\r\n\r\n        console.log(`✅ Created migration: ${migrationId}`);\r\n        console.log(`📁 File: apps/api/migrations/${migrationId}.json`);\r\n        console.log(\"\\n📝 Next steps:\");\r\n        console.log(`   1. Edit the migration file to add operations`);\r\n        console.log(`   2. Run: farm db migrate`);\r\n      } catch (error) {\r\n        console.error(\"❌ Failed to create migration:\", error.message);\r\n        process.exit(1);\r\n      }\r\n    });\r\n\r\n  migration\r\n    .command(\"generate <model>\")\r\n    .description(\"Generate migration from model\")\r\n    .option(\"-o, --operation <op>\", \"Operation type (create, update)\", \"create\")\r\n    .action(async (modelName: string, options: { operation: string }) => {\r\n      try {\r\n        // This would analyze the model and generate appropriate migration\r\n        console.log(`🔄 Generating migration for ${modelName}...`);\r\n\r\n        // Implementation would:\r\n        // 1. Import and analyze the model class\r\n        // 2. Compare with existing schema\r\n        // 3. Generate migration operations\r\n        // 4. Create migration file\r\n\r\n        console.log(`✅ Generated migration for ${modelName}`);\r\n      } catch (error) {\r\n        console.error(\"❌ Failed to generate migration:\", error.message);\r\n        process.exit(1);\r\n      }\r\n    });\r\n\r\n  db.command(\"migrate\")\r\n    .description(\"Apply pending migrations\")\r\n    .option(\"-t, --target <migration>\", \"Target migration ID\")\r\n    .action(async (options: { target?: string }) => {\r\n      try {\r\n        const config = await loadFarmConfig();\r\n        const dbManager = new DatabaseManager(config.database);\r\n        await dbManager.initialize();\r\n\r\n        const migrationManager = new MigrationManager(dbManager);\r\n        await migrationManager.apply_migrations(options.target);\r\n\r\n        console.log(\"✅ Migrations applied successfully\");\r\n\r\n        await dbManager.shutdown();\r\n      } catch (error) {\r\n        console.error(\"❌ Migration failed:\", error.message);\r\n        process.exit(1);\r\n      }\r\n    });\r\n\r\n  // Seed command\r\n  db.command(\"seed\")\r\n    .description(\"Run database seeders\")\r\n    .option(\"-f, --file <file>\", \"Specific seed file\")\r\n    .action(async (options: { file?: string }) => {\r\n      try {\r\n        const config = await loadFarmConfig();\r\n        const dbManager = new DatabaseManager(config.database);\r\n        await dbManager.initialize();\r\n\r\n        console.log(\"🌱 Running database seeders...\");\r\n\r\n        if (options.file) {\r\n          console.log(`📄 Seeding from file: ${options.file}`);\r\n          // Load and apply specific seed file\r\n        } else {\r\n          console.log(\"📁 Seeding from all seed files...\");\r\n          // Load and apply all seed files\r\n        }\r\n\r\n        console.log(\"✅ Database seeding completed\");\r\n\r\n        await dbManager.shutdown();\r\n      } catch (error) {\r\n        console.error(\"❌ Database seeding failed:\", error.message);\r\n        process.exit(1);\r\n      }\r\n    });\r\n\r\n  return db;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Performance Monitoring & Analytics\r\n\r\n### 1. Database Performance Monitor\r\n\r\n**Real-time Performance Monitoring:**\r\n\r\n```python\r\n# apps/api/src/database/monitoring.py\r\nimport asyncio\r\nfrom typing import Dict, Any, List, Optional\r\nfrom datetime import datetime, timedelta\r\nimport logging\r\nfrom dataclasses import dataclass, field\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\n@dataclass\r\nclass QueryMetrics:\r\n    \"\"\"Query performance metrics\"\"\"\r\n    query_type: str\r\n    collection: str\r\n    execution_time: float\r\n    timestamp: datetime\r\n    result_count: Optional[int] = None\r\n    index_used: Optional[str] = None\r\n    error: Optional[str] = None\r\n\r\n@dataclass\r\nclass PerformanceSnapshot:\r\n    \"\"\"Database performance snapshot\"\"\"\r\n    timestamp: datetime\r\n    active_connections: int\r\n    memory_usage: Dict[str, int]\r\n    query_metrics: List[QueryMetrics] = field(default_factory=list)\r\n    slow_queries: List[QueryMetrics] = field(default_factory=list)\r\n    index_stats: Dict[str, Any] = field(default_factory=dict)\r\n\r\nclass DatabaseMonitor:\r\n    \"\"\"Database performance monitoring system\"\"\"\r\n\r\n    def __init__(self, database_manager: DatabaseManager):\r\n        self.db_manager = database_manager\r\n        self.metrics_history: List[PerformanceSnapshot] = []\r\n        self.slow_query_threshold = 1.0  # seconds\r\n        self.monitoring_enabled = False\r\n        self.monitor_task = None\r\n        self.query_metrics: List[QueryMetrics] = []\r\n\r\n    async def start_monitoring(self, interval: int = 60) -> None:\r\n        \"\"\"Start performance monitoring\"\"\"\r\n        if self.monitoring_enabled:\r\n            return\r\n\r\n        self.monitoring_enabled = True\r\n        self.monitor_task = asyncio.create_task(\r\n            self._monitoring_loop(interval)\r\n        )\r\n        logger.info(\"📊 Database performance monitoring started\")\r\n\r\n    async def stop_monitoring(self) -> None:\r\n        \"\"\"Stop performance monitoring\"\"\"\r\n        self.monitoring_enabled = False\r\n\r\n        if self.monitor_task:\r\n            self.monitor_task.cancel()\r\n            try:\r\n                await self.monitor_task\r\n            except asyncio.CancelledError:\r\n                pass\r\n\r\n        logger.info(\"⏹️ Database performance monitoring stopped\")\r\n\r\n    async def _monitoring_loop(self, interval: int) -> None:\r\n        \"\"\"Main monitoring loop\"\"\"\r\n        while self.monitoring_enabled:\r\n            try:\r\n                await asyncio.sleep(interval)\r\n                snapshot = await self._capture_performance_snapshot()\r\n                self._process_snapshot(snapshot)\r\n\r\n            except asyncio.CancelledError:\r\n                break\r\n            except Exception as e:\r\n                logger.error(f\"Monitoring error: {e}\")\r\n\r\n    async def _capture_performance_snapshot(self) -> PerformanceSnapshot:\r\n        \"\"\"Capture current performance metrics\"\"\"\r\n        health = await self.db_manager.health_check()\r\n        stats = await self.db_manager.get_stats()\r\n\r\n        snapshot = PerformanceSnapshot(\r\n            timestamp=datetime.utcnow(),\r\n            active_connections=health.get(\"connections\", {}).get(\"current\", 0),\r\n            memory_usage=stats.get(\"memory\", {}),\r\n            query_metrics=self.query_metrics.copy(),\r\n            slow_queries=[\r\n                m for m in self.query_metrics\r\n                if m.execution_time > self.slow_query_threshold\r\n            ]\r\n        )\r\n\r\n        # Clear query metrics for next interval\r\n        self.query_metrics.clear()\r\n\r\n        return snapshot\r\n\r\n    def _process_snapshot(self, snapshot: PerformanceSnapshot) -> None:\r\n        \"\"\"Process and store performance snapshot\"\"\"\r\n        self.metrics_history.append(snapshot)\r\n\r\n        # Keep only last 24 hours of data\r\n        cutoff = datetime.utcnow() - timedelta(hours=24)\r\n        self.metrics_history = [\r\n            s for s in self.metrics_history\r\n            if s.timestamp > cutoff\r\n        ]\r\n\r\n        # Log alerts for performance issues\r\n        if snapshot.slow_queries:\r\n            logger.warning(\r\n                f\"⚠️ {len(snapshot.slow_queries)} slow queries detected in last interval\"\r\n            )\r\n\r\n        if snapshot.active_connections > 50:  # Configurable threshold\r\n            logger.warning(\r\n                f\"⚠️ High connection count: {snapshot.active_connections}\"\r\n            )\r\n\r\n    def record_query(self, metrics: QueryMetrics) -> None:\r\n        \"\"\"Record query execution metrics\"\"\"\r\n        self.query_metrics.append(metrics)\r\n\r\n        # Log slow queries immediately\r\n        if metrics.execution_time > self.slow_query_threshold:\r\n            logger.warning(\r\n                f\"🐌 Slow query detected: {metrics.query_type} on {metrics.collection} \"\r\n                f\"took {metrics.execution_time:.2f}s\"\r\n            )\r\n\r\n    def get_performance_summary(self, hours: int = 1) -> Dict[str, Any]:\r\n        \"\"\"Get performance summary for specified time period\"\"\"\r\n        cutoff = datetime.utcnow() - timedelta(hours=hours)\r\n        recent_snapshots = [\r\n            s for s in self.metrics_history\r\n            if s.timestamp > cutoff\r\n        ]\r\n\r\n        if not recent_snapshots:\r\n            return {\"error\": \"No performance data available\"}\r\n\r\n        # Aggregate metrics\r\n        total_queries = sum(len(s.query_metrics) for s in recent_snapshots)\r\n        total_slow_queries = sum(len(s.slow_queries) for s in recent_snapshots)\r\n\r\n        avg_connections = (\r\n            sum(s.active_connections for s in recent_snapshots) /\r\n            len(recent_snapshots)\r\n        )\r\n\r\n        # Query type distribution\r\n        query_types = {}\r\n        for snapshot in recent_snapshots:\r\n            for query in snapshot.query_metrics:\r\n                query_types[query.query_type] = query_types.get(query.query_type, 0) + 1\r\n\r\n        return {\r\n            \"period_hours\": hours,\r\n            \"snapshots_count\": len(recent_snapshots),\r\n            \"total_queries\": total_queries,\r\n            \"slow_queries\": total_slow_queries,\r\n            \"slow_query_percentage\": (\r\n                (total_slow_queries / total_queries * 100)\r\n                if total_queries > 0 else 0\r\n            ),\r\n            \"average_connections\": round(avg_connections, 1),\r\n            \"query_type_distribution\": query_types,\r\n            \"last_updated\": recent_snapshots[-1].timestamp if recent_snapshots else None\r\n        }\r\n\r\n# Performance monitoring middleware\r\nclass QueryPerformanceMiddleware:\r\n    \"\"\"Middleware to track query performance\"\"\"\r\n\r\n    def __init__(self, monitor: DatabaseMonitor):\r\n        self.monitor = monitor\r\n\r\n    async def __call__(self, query_func, *args, **kwargs):\r\n        \"\"\"Wrap database queries with performance tracking\"\"\"\r\n        start_time = datetime.utcnow()\r\n        error = None\r\n        result = None\r\n\r\n        try:\r\n            result = await query_func(*args, **kwargs)\r\n            return result\r\n        except Exception as e:\r\n            error = str(e)\r\n            raise\r\n        finally:\r\n            end_time = datetime.utcnow()\r\n            execution_time = (end_time - start_time).total_seconds()\r\n\r\n            # Extract query information\r\n            query_type = getattr(query_func, '__name__', 'unknown')\r\n            collection = getattr(query_func, '_collection', 'unknown')\r\n\r\n            # Record metrics\r\n            metrics = QueryMetrics(\r\n                query_type=query_type,\r\n                collection=collection,\r\n                execution_time=execution_time,\r\n                timestamp=start_time,\r\n                result_count=len(result) if isinstance(result, list) else None,\r\n                error=error\r\n            )\r\n\r\n            self.monitor.record_query(metrics)\r\n```\r\n\r\n---\r\n\r\n## Configuration Integration\r\n\r\n### 1. Farm Config Database Settings\r\n\r\n**TypeScript Configuration for Database:**\r\n\r\n```typescript\r\n// farm.config.ts - Database configuration\r\nimport { defineConfig } from \"@farm/core\";\r\n\r\nexport default defineConfig({\r\n  database: {\r\n    // Primary database configuration\r\n    type: \"mongodb\", // 'mongodb' | 'postgresql' | 'mysql' | 'sqlite'\r\n    url: process.env.DATABASE_URL || \"mongodb://localhost:27017/farmapp\",\r\n\r\n    // Connection pool settings\r\n    pool: {\r\n      minSize: 5,\r\n      maxSize: 50,\r\n      acquireTimeoutMs: 30000,\r\n      idleTimeoutMs: 300000,\r\n    },\r\n\r\n    // MongoDB-specific settings\r\n    mongodb: {\r\n      authSource: \"admin\",\r\n      retryWrites: true,\r\n      w: \"majority\",\r\n      readPreference: \"primaryPreferred\",\r\n      maxIdleTimeMS: 300000,\r\n      serverSelectionTimeoutMS: 5000,\r\n    },\r\n\r\n    // PostgreSQL-specific settings (when using PostgreSQL)\r\n    postgresql: {\r\n      ssl: process.env.NODE_ENV === \"production\",\r\n      poolSize: 20,\r\n      maxOverflow: 30,\r\n      poolTimeout: 30,\r\n      poolRecycle: 3600,\r\n    },\r\n\r\n    // Performance and monitoring\r\n    monitoring: {\r\n      enabled: true,\r\n      slowQueryThreshold: 1000, // milliseconds\r\n      metricsRetentionHours: 24,\r\n      healthCheckInterval: 30, // seconds\r\n    },\r\n\r\n    // Migration settings\r\n    migrations: {\r\n      directory: \"apps/api/migrations\",\r\n      autoRun: process.env.NODE_ENV === \"development\",\r\n      backupBeforeMigration: process.env.NODE_ENV === \"production\",\r\n    },\r\n\r\n    // Development settings\r\n    development: {\r\n      seedDatabase: true,\r\n      dropOnRestart: false,\r\n      showQueries: process.env.DATABASE_DEBUG === \"true\",\r\n    },\r\n\r\n    // Backup and recovery\r\n    backup: {\r\n      enabled: process.env.NODE_ENV === \"production\",\r\n      schedule: \"0 2 * * *\", // Daily at 2 AM\r\n      retention: 7, // days\r\n      storage: {\r\n        type: \"s3\", // 's3' | 'local' | 'gcp'\r\n        bucket: \"farm-app-backups\",\r\n        path: \"database-backups/\",\r\n      },\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n---\r\n\r\n_Status: ✅ Completed - Ready for implementation_\r\n\r\nThis database integration architecture provides:\r\n\r\n- **MongoDB-first approach** with Beanie ODM as primary choice\r\n- **Multi-database support** through provider abstraction layer\r\n- **Type-safe schema definitions** with automatic validation\r\n- **Comprehensive migration system** for schema evolution\r\n- **Advanced connection pooling** and performance optimization\r\n- **Real-time monitoring** and performance analytics\r\n- **CLI integration** for database management\r\n- **Seamless auth integration** with the authentication system\r\n- **Plugin-ready architecture** for custom database needs\r\n",
      "excerpt": "The FARM database integration provides a MongoDB-first approach with flexible multi-database support through an abstraction layer.",
      "category": "architectural-sketches-detailed/phase2",
      "type": "reference",
      "tags": [
        "mongodb",
        "farm",
        "typescript",
        "python",
        "authentication"
      ],
      "lastModified": "2025-06-12T21:57:32.780Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase2",
        "Database_integration_architecture"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Database Integration Architecture",
          "id": "database-integration-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "High-Level Database Architecture",
          "id": "high-level-database-architecture"
        },
        {
          "level": 2,
          "text": "Core Database Models",
          "id": "core-database-models"
        },
        {
          "level": 3,
          "text": "1. Enhanced Document Model Base",
          "id": "1-enhanced-document-model-base"
        },
        {
          "level": 1,
          "text": "apps/api/src/database/models/base.py",
          "id": "appsapisrcdatabasemodelsbasepy"
        },
        {
          "level": 1,
          "text": "Type variable for generic document operations",
          "id": "type-variable-for-generic-document-operations"
        },
        {
          "level": 3,
          "text": "2. Enhanced User Model Integration",
          "id": "2-enhanced-user-model-integration"
        },
        {
          "level": 1,
          "text": "apps/api/src/database/models/user.py",
          "id": "appsapisrcdatabasemodelsuserpy"
        },
        {
          "level": 2,
          "text": "Database Abstraction Layer",
          "id": "database-abstraction-layer"
        },
        {
          "level": 3,
          "text": "1. Database Provider Interface",
          "id": "1-database-provider-interface"
        },
        {
          "level": 1,
          "text": "apps/api/src/database/providers/base.py",
          "id": "appsapisrcdatabaseprovidersbasepy"
        },
        {
          "level": 3,
          "text": "2. MongoDB Provider Implementation",
          "id": "2-mongodb-provider-implementation"
        },
        {
          "level": 1,
          "text": "apps/api/src/database/providers/mongodb.py",
          "id": "appsapisrcdatabaseprovidersmongodbpy"
        },
        {
          "level": 3,
          "text": "3. PostgreSQL Provider Implementation",
          "id": "3-postgresql-provider-implementation"
        },
        {
          "level": 1,
          "text": "apps/api/src/database/providers/postgresql.py",
          "id": "appsapisrcdatabaseproviderspostgresqlpy"
        },
        {
          "level": 2,
          "text": "Database Manager & Connection Pool",
          "id": "database-manager-connection-pool"
        },
        {
          "level": 3,
          "text": "1. Central Database Manager",
          "id": "1-central-database-manager"
        },
        {
          "level": 1,
          "text": "apps/api/src/database/manager.py",
          "id": "appsapisrcdatabasemanagerpy"
        },
        {
          "level": 1,
          "text": "Global database manager instance",
          "id": "global-database-manager-instance"
        },
        {
          "level": 3,
          "text": "2. Connection Pool Management",
          "id": "2-connection-pool-management"
        },
        {
          "level": 1,
          "text": "apps/api/src/database/connection_pool.py",
          "id": "appsapisrcdatabaseconnection_poolpy"
        },
        {
          "level": 2,
          "text": "Migration System",
          "id": "migration-system"
        },
        {
          "level": 3,
          "text": "1. Schema Migration Framework",
          "id": "1-schema-migration-framework"
        },
        {
          "level": 1,
          "text": "apps/api/src/database/migrations/manager.py",
          "id": "appsapisrcdatabasemigrationsmanagerpy"
        },
        {
          "level": 1,
          "text": "Migration operation builders",
          "id": "migration-operation-builders"
        },
        {
          "level": 2,
          "text": "Database CLI Commands",
          "id": "database-cli-commands"
        },
        {
          "level": 3,
          "text": "1. Database Management Commands",
          "id": "1-database-management-commands"
        },
        {
          "level": 1,
          "text": "Database connection management",
          "id": "database-connection-management"
        },
        {
          "level": 1,
          "text": "Schema and migration management",
          "id": "schema-and-migration-management"
        },
        {
          "level": 1,
          "text": "Migration creation",
          "id": "migration-creation"
        },
        {
          "level": 1,
          "text": "Index management",
          "id": "index-management"
        },
        {
          "level": 1,
          "text": "Data management",
          "id": "data-management"
        },
        {
          "level": 1,
          "text": "Development utilities",
          "id": "development-utilities"
        },
        {
          "level": 3,
          "text": "2. CLI Implementation",
          "id": "2-cli-implementation"
        },
        {
          "level": 2,
          "text": "Performance Monitoring & Analytics",
          "id": "performance-monitoring-analytics"
        },
        {
          "level": 3,
          "text": "1. Database Performance Monitor",
          "id": "1-database-performance-monitor"
        },
        {
          "level": 1,
          "text": "apps/api/src/database/monitoring.py",
          "id": "appsapisrcdatabasemonitoringpy"
        },
        {
          "level": 1,
          "text": "Performance monitoring middleware",
          "id": "performance-monitoring-middleware"
        },
        {
          "level": 2,
          "text": "Configuration Integration",
          "id": "configuration-integration"
        },
        {
          "level": 3,
          "text": "1. Farm Config Database Settings",
          "id": "1-farm-config-database-settings"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase2-error_handling_developer_feedback",
      "title": "Error_handling_developer_feedback",
      "url": "/architectural-sketches-detailed/phase2/error_handling_developer_feedback",
      "content": "# Error Handling & Developer Feedback\r\n\r\n## Overview\r\n\r\nThe FARM error handling system provides comprehensive error management, developer-friendly feedback, and intelligent debugging assistance across the entire stack. It features cross-component error correlation, AI-powered error analysis, actionable suggestions, and seamless integration with the development workflow to maintain exceptional developer experience even when things go wrong.\r\n\r\n---\r\n\r\n## High-Level Error Management Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                  FARM Error Management System                  │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │   Error     │  │ Cross-Stack │  │  Developer  │  │   AI    │ │\r\n│  │Aggregation  │  │Correlation  │  │  Feedback   │  │Analysis │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │  Frontend   │  │  Backend    │  │ Database    │  │   AI    │ │\r\n│  │   Errors    │  │   Errors    │  │   Errors    │  │ Errors  │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Performance │  │ Debug Tools │  │   Error     │  │Solution │ │\r\n│  │ Monitoring  │  │ Integration │  │ Recovery    │  │Suggestions│ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Error Management System\r\n\r\n### 1. Central Error Aggregator\r\n\r\n**Unified Error Collection and Processing:**\r\n\r\n```typescript\r\n// packages/core/src/errors/aggregator.ts\r\nimport { EventEmitter } from \"events\";\r\nimport { ErrorAnalyzer } from \"./analyzer\";\r\nimport { ErrorCorrelator } from \"./correlator\";\r\nimport { DeveloperFeedback } from \"./feedback\";\r\n\r\nexport class ErrorAggregator extends EventEmitter {\r\n  private errors: Map<string, ErrorContext> = new Map();\r\n  private analyzer: ErrorAnalyzer;\r\n  private correlator: ErrorCorrelator;\r\n  private feedback: DeveloperFeedback;\r\n  private config: ErrorHandlingConfig;\r\n\r\n  constructor(config: ErrorHandlingConfig) {\r\n    super();\r\n    this.config = config;\r\n    this.analyzer = new ErrorAnalyzer(config);\r\n    this.correlator = new ErrorCorrelator(config);\r\n    this.feedback = new DeveloperFeedback(config);\r\n\r\n    this.setupErrorSources();\r\n  }\r\n\r\n  private setupErrorSources(): void {\r\n    // Listen for errors from different components\r\n    process.on(\"uncaughtException\", this.handleUncaughtException.bind(this));\r\n    process.on(\"unhandledRejection\", this.handleUnhandledRejection.bind(this));\r\n\r\n    // Setup custom error handlers\r\n    this.setupFrontendErrorHandler();\r\n    this.setupBackendErrorHandler();\r\n    this.setupDatabaseErrorHandler();\r\n    this.setupAIErrorHandler();\r\n    this.setupBuildErrorHandler();\r\n    this.setupHotReloadErrorHandler();\r\n  }\r\n\r\n  async reportError(error: FarmError): Promise<void> {\r\n    const errorId = this.generateErrorId(error);\r\n\r\n    // Create error context\r\n    const context: ErrorContext = {\r\n      id: errorId,\r\n      error,\r\n      timestamp: Date.now(),\r\n      stack: this.captureStackTrace(),\r\n      environment: this.captureEnvironment(),\r\n      correlation: null,\r\n      analysis: null,\r\n      suggestions: [],\r\n    };\r\n\r\n    // Store error\r\n    this.errors.set(errorId, context);\r\n\r\n    try {\r\n      // Analyze error\r\n      context.analysis = await this.analyzer.analyze(error);\r\n\r\n      // Find correlations with other errors\r\n      context.correlation = await this.correlator.findCorrelations(\r\n        error,\r\n        context\r\n      );\r\n\r\n      // Generate suggestions\r\n      context.suggestions = await this.generateSuggestions(context);\r\n\r\n      // Provide developer feedback\r\n      await this.feedback.displayError(context);\r\n\r\n      // Emit for external handlers\r\n      this.emit(\"error-processed\", context);\r\n    } catch (analysisError) {\r\n      console.error(\"Failed to analyze error:\", analysisError);\r\n      // Still provide basic feedback\r\n      await this.feedback.displayBasicError(error);\r\n    }\r\n  }\r\n\r\n  private generateErrorId(error: FarmError): string {\r\n    const hash = require(\"crypto\").createHash(\"md5\");\r\n    hash.update(error.message + error.component + error.type);\r\n    return hash.digest(\"hex\").substring(0, 8);\r\n  }\r\n\r\n  private captureStackTrace(): StackFrame[] {\r\n    const stack = new Error().stack || \"\";\r\n    return stack\r\n      .split(\"\\n\")\r\n      .slice(2)\r\n      .map((line) => {\r\n        const match = line.match(/at\\s+(.+?)\\s+\\((.+?):(\\d+):(\\d+)\\)/);\r\n        if (match) {\r\n          return {\r\n            function: match[1],\r\n            file: match[2],\r\n            line: parseInt(match[3]),\r\n            column: parseInt(match[4]),\r\n          };\r\n        }\r\n        return { function: \"unknown\", file: \"unknown\", line: 0, column: 0 };\r\n      });\r\n  }\r\n\r\n  private captureEnvironment(): EnvironmentContext {\r\n    return {\r\n      nodeVersion: process.version,\r\n      platform: process.platform,\r\n      arch: process.arch,\r\n      memory: process.memoryUsage(),\r\n      uptime: process.uptime(),\r\n      farmVersion: this.config.farmVersion,\r\n      developmentMode: process.env.NODE_ENV === \"development\",\r\n      services: this.getServiceStatus(),\r\n    };\r\n  }\r\n\r\n  private async generateSuggestions(\r\n    context: ErrorContext\r\n  ): Promise<ErrorSuggestion[]> {\r\n    const suggestions: ErrorSuggestion[] = [];\r\n\r\n    // Rule-based suggestions\r\n    const ruleSuggestions = await this.analyzer.generateRuleSuggestions(\r\n      context.error\r\n    );\r\n    suggestions.push(...ruleSuggestions);\r\n\r\n    // AI-powered suggestions (if enabled)\r\n    if (this.config.aiSuggestions.enabled) {\r\n      const aiSuggestions = await this.analyzer.generateAISuggestions(context);\r\n      suggestions.push(...aiSuggestions);\r\n    }\r\n\r\n    // Community knowledge suggestions\r\n    const communitySuggestions =\r\n      await this.analyzer.generateCommunitySuggestions(context.error);\r\n    suggestions.push(...communitySuggestions);\r\n\r\n    return suggestions.slice(0, 5); // Limit to top 5 suggestions\r\n  }\r\n\r\n  async getErrorHistory(hours: number = 24): Promise<ErrorContext[]> {\r\n    const cutoff = Date.now() - hours * 60 * 60 * 1000;\r\n    return Array.from(this.errors.values())\r\n      .filter((context) => context.timestamp > cutoff)\r\n      .sort((a, b) => b.timestamp - a.timestamp);\r\n  }\r\n\r\n  async getErrorStats(): Promise<ErrorStats> {\r\n    const recent = await this.getErrorHistory(24);\r\n\r\n    const byComponent = recent.reduce((acc, context) => {\r\n      const component = context.error.component;\r\n      acc[component] = (acc[component] || 0) + 1;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n\r\n    const byType = recent.reduce((acc, context) => {\r\n      const type = context.error.type;\r\n      acc[type] = (acc[type] || 0) + 1;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n\r\n    return {\r\n      total: recent.length,\r\n      byComponent,\r\n      byType,\r\n      mostCommon: this.findMostCommonError(recent),\r\n      trends: this.analyzeErrorTrends(recent),\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n### 2. Cross-Stack Error Correlation\r\n\r\n**Intelligent Error Relationship Detection:**\r\n\r\n```typescript\r\n// packages/core/src/errors/correlator.ts\r\nexport class ErrorCorrelator {\r\n  private recentErrors: Map<string, ErrorContext[]> = new Map();\r\n  private correlationRules: CorrelationRule[] = [];\r\n\r\n  constructor(config: ErrorHandlingConfig) {\r\n    this.setupCorrelationRules();\r\n  }\r\n\r\n  async findCorrelations(\r\n    error: FarmError,\r\n    context: ErrorContext\r\n  ): Promise<ErrorCorrelation | null> {\r\n    // Get recent errors from the same and different components\r\n    const recentErrors = this.getRecentErrors(5 * 60 * 1000); // Last 5 minutes\r\n\r\n    if (recentErrors.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Apply correlation rules\r\n    for (const rule of this.correlationRules) {\r\n      const correlation = await rule.check(error, context, recentErrors);\r\n      if (correlation) {\r\n        return correlation;\r\n      }\r\n    }\r\n\r\n    // Check for timing-based correlations\r\n    const timingCorrelation = this.findTimingCorrelations(error, recentErrors);\r\n    if (timingCorrelation) {\r\n      return timingCorrelation;\r\n    }\r\n\r\n    // Check for cascade errors\r\n    const cascadeCorrelation = this.findCascadeErrors(error, recentErrors);\r\n    if (cascadeCorrelation) {\r\n      return cascadeCorrelation;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  private setupCorrelationRules(): void {\r\n    // Database connection errors often cause backend API failures\r\n    this.correlationRules.push({\r\n      name: \"database-backend-cascade\",\r\n      check: async (error, context, recent) => {\r\n        if (error.component === \"backend\" && error.type === \"api-error\") {\r\n          const dbError = recent.find(\r\n            (e) =>\r\n              e.error.component === \"database\" &&\r\n              e.error.type === \"connection-error\" &&\r\n              e.timestamp > context.timestamp - 30000 // Within 30 seconds\r\n          );\r\n\r\n          if (dbError) {\r\n            return {\r\n              type: \"cascade\",\r\n              rootCause: dbError,\r\n              description:\r\n                \"Backend API error likely caused by database connection issue\",\r\n              confidence: 0.9,\r\n            };\r\n          }\r\n        }\r\n        return null;\r\n      },\r\n    });\r\n\r\n    // Type generation errors often cause frontend compilation issues\r\n    this.correlationRules.push({\r\n      name: \"types-frontend-cascade\",\r\n      check: async (error, context, recent) => {\r\n        if (\r\n          error.component === \"frontend\" &&\r\n          error.type === \"compilation-error\"\r\n        ) {\r\n          const typeError = recent.find(\r\n            (e) =>\r\n              e.error.component === \"codegen\" &&\r\n              e.error.type === \"type-generation-error\" &&\r\n              e.timestamp > context.timestamp - 60000 // Within 1 minute\r\n          );\r\n\r\n          if (typeError) {\r\n            return {\r\n              type: \"cascade\",\r\n              rootCause: typeError,\r\n              description:\r\n                \"Frontend compilation error caused by type generation failure\",\r\n              confidence: 0.85,\r\n            };\r\n          }\r\n        }\r\n        return null;\r\n      },\r\n    });\r\n\r\n    // AI model loading errors affect AI API endpoints\r\n    this.correlationRules.push({\r\n      name: \"ai-model-api-cascade\",\r\n      check: async (error, context, recent) => {\r\n        if (\r\n          (error.component === \"backend\" && error.message.includes(\"AI\")) ||\r\n          error.message.includes(\"model\")\r\n        ) {\r\n          const aiError = recent.find(\r\n            (e) =>\r\n              e.error.component === \"ai\" &&\r\n              (e.error.type === \"model-load-error\" ||\r\n                e.error.type === \"provider-error\") &&\r\n              e.timestamp > context.timestamp - 120000 // Within 2 minutes\r\n          );\r\n\r\n          if (aiError) {\r\n            return {\r\n              type: \"cascade\",\r\n              rootCause: aiError,\r\n              description:\r\n                \"Backend AI endpoint error caused by AI model loading failure\",\r\n              confidence: 0.8,\r\n            };\r\n          }\r\n        }\r\n        return null;\r\n      },\r\n    });\r\n\r\n    // Plugin errors can affect both frontend and backend\r\n    this.correlationRules.push({\r\n      name: \"plugin-cross-stack-cascade\",\r\n      check: async (error, context, recent) => {\r\n        const pluginError = recent.find(\r\n          (e) =>\r\n            e.error.component === \"plugin\" &&\r\n            e.timestamp > context.timestamp - 60000 // Within 1 minute\r\n        );\r\n\r\n        if (pluginError && error.component !== \"plugin\") {\r\n          return {\r\n            type: \"cascade\",\r\n            rootCause: pluginError,\r\n            description: `${error.component} error likely caused by plugin system issue`,\r\n            confidence: 0.7,\r\n          };\r\n        }\r\n        return null;\r\n      },\r\n    });\r\n  }\r\n\r\n  private findTimingCorrelations(\r\n    error: FarmError,\r\n    recentErrors: ErrorContext[]\r\n  ): ErrorCorrelation | null {\r\n    // Find errors that occurred very close in time\r\n    const timeWindow = 5000; // 5 seconds\r\n    const nearbyErrors = recentErrors.filter(\r\n      (e) => Math.abs(e.timestamp - Date.now()) < timeWindow\r\n    );\r\n\r\n    if (nearbyErrors.length > 1) {\r\n      return {\r\n        type: \"timing\",\r\n        description: `Multiple errors occurred within ${timeWindow}ms, suggesting a common trigger`,\r\n        confidence: 0.6,\r\n        relatedErrors: nearbyErrors,\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  private findCascadeErrors(\r\n    error: FarmError,\r\n    recentErrors: ErrorContext[]\r\n  ): ErrorCorrelation | null {\r\n    // Look for patterns indicating error cascades\r\n    const componentOrder = [\"database\", \"ai\", \"backend\", \"codegen\", \"frontend\"];\r\n    const errorIndex = componentOrder.indexOf(error.component);\r\n\r\n    if (errorIndex > 0) {\r\n      // Check for errors in upstream components\r\n      const upstreamErrors = recentErrors.filter((e) => {\r\n        const upstreamIndex = componentOrder.indexOf(e.error.component);\r\n        return upstreamIndex >= 0 && upstreamIndex < errorIndex;\r\n      });\r\n\r\n      if (upstreamErrors.length > 0) {\r\n        const rootCause = upstreamErrors.reduce((earliest, current) =>\r\n          current.timestamp < earliest.timestamp ? current : earliest\r\n        );\r\n\r\n        return {\r\n          type: \"cascade\",\r\n          rootCause,\r\n          description:\r\n            \"This error appears to be caused by an upstream component failure\",\r\n          confidence: 0.75,\r\n        };\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n```\r\n\r\n### 3. AI-Powered Error Analysis\r\n\r\n**Intelligent Error Diagnosis:**\r\n\r\n```typescript\r\n// packages/core/src/errors/ai-analyzer.ts\r\nexport class AIErrorAnalyzer {\r\n  private aiProvider: any;\r\n  private knowledgeBase: ErrorKnowledgeBase;\r\n\r\n  constructor(config: ErrorHandlingConfig) {\r\n    this.aiProvider = config.aiProvider;\r\n    this.knowledgeBase = new ErrorKnowledgeBase();\r\n  }\r\n\r\n  async analyzeError(context: ErrorContext): Promise<AIErrorAnalysis> {\r\n    const prompt = this.buildAnalysisPrompt(context);\r\n\r\n    try {\r\n      const response = await this.aiProvider.chat(\r\n        [\r\n          {\r\n            role: \"system\",\r\n            content: `You are an expert developer assistant specializing in FARM stack applications. \r\n          Analyze errors and provide actionable solutions. Be specific and practical.`,\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: prompt,\r\n          },\r\n        ],\r\n        {\r\n          model: \"gpt-4\", // Use most capable model for error analysis\r\n          temperature: 0.1, // Low temperature for consistent, accurate responses\r\n          max_tokens: 1000,\r\n        }\r\n      );\r\n\r\n      return this.parseAIResponse(response);\r\n    } catch (error) {\r\n      console.warn(\"AI error analysis failed:\", error.message);\r\n      return this.fallbackAnalysis(context);\r\n    }\r\n  }\r\n\r\n  private buildAnalysisPrompt(context: ErrorContext): string {\r\n    return `\r\nAnalyze this FARM stack application error:\r\n\r\nComponent: ${context.error.component}\r\nError Type: ${context.error.type}\r\nMessage: ${context.error.message}\r\n\r\nStack Trace:\r\n${context.error.stack?.slice(0, 10).join(\"\\n\") || \"No stack trace available\"}\r\n\r\nEnvironment:\r\n- Node.js: ${context.environment.nodeVersion}\r\n- Platform: ${context.environment.platform}\r\n- Development Mode: ${context.environment.developmentMode}\r\n- FARM Version: ${context.environment.farmVersion}\r\n\r\n${\r\n  context.correlation\r\n    ? `\r\nRelated Error: This error may be related to a ${context.correlation.type} error in ${context.correlation.rootCause?.error.component}\r\n`\r\n    : \"\"\r\n}\r\n\r\nPlease provide:\r\n1. Root cause analysis\r\n2. Specific steps to fix this error\r\n3. Prevention strategies\r\n4. Related documentation or resources\r\n\r\nFocus on FARM stack specifics including:\r\n- React/TypeScript frontend issues\r\n- FastAPI/Python backend issues  \r\n- MongoDB database connectivity\r\n- AI/ML model integration (Ollama, OpenAI)\r\n- Type generation pipeline\r\n- Hot reload system\r\n- Plugin system\r\n`;\r\n  }\r\n\r\n  private parseAIResponse(response: string): AIErrorAnalysis {\r\n    // Parse structured response from AI\r\n    const sections = this.extractSections(response);\r\n\r\n    return {\r\n      rootCause: sections.rootCause || \"Unable to determine root cause\",\r\n      fixSteps: this.parseSteps(sections.fixSteps || []),\r\n      prevention: sections.prevention || [],\r\n      resources: this.parseResources(sections.resources || []),\r\n      confidence: this.calculateConfidence(response),\r\n      generatedAt: Date.now(),\r\n    };\r\n  }\r\n\r\n  private extractSections(response: string): any {\r\n    const sections: any = {};\r\n\r\n    // Extract root cause\r\n    const rootCauseMatch = response.match(\r\n      /root cause[:\\s]*(.*?)(?=\\n\\d\\.|\\nsteps|\\nprevention|$)/is\r\n    );\r\n    if (rootCauseMatch) {\r\n      sections.rootCause = rootCauseMatch[1].trim();\r\n    }\r\n\r\n    // Extract fix steps\r\n    const stepsMatch = response.match(\r\n      /steps?(.*?)(?=\\nprevention|\\nresources|$)/is\r\n    );\r\n    if (stepsMatch) {\r\n      sections.fixSteps = this.parseNumberedList(stepsMatch[1]);\r\n    }\r\n\r\n    // Extract prevention strategies\r\n    const preventionMatch = response.match(\r\n      /prevention(.*?)(?=\\nresources|$)/is\r\n    );\r\n    if (preventionMatch) {\r\n      sections.prevention = this.parseNumberedList(preventionMatch[1]);\r\n    }\r\n\r\n    // Extract resources\r\n    const resourcesMatch = response.match(/resources?(.*?)$/is);\r\n    if (resourcesMatch) {\r\n      sections.resources = this.parseNumberedList(resourcesMatch[1]);\r\n    }\r\n\r\n    return sections;\r\n  }\r\n\r\n  private parseNumberedList(text: string): string[] {\r\n    return text\r\n      .split(/\\n\\s*\\d+\\./)\r\n      .map((item) => item.trim())\r\n      .filter((item) => item.length > 0);\r\n  }\r\n\r\n  async generateCodeFix(\r\n    error: FarmError,\r\n    context: ErrorContext\r\n  ): Promise<CodeFixSuggestion | null> {\r\n    if (!this.shouldGenerateCodeFix(error)) {\r\n      return null;\r\n    }\r\n\r\n    const prompt = `\r\nGenerate a code fix for this FARM stack error:\r\n\r\nError: ${error.message}\r\nComponent: ${error.component}\r\nFile: ${error.file || \"unknown\"}\r\n\r\n${\r\n  error.code\r\n    ? `\r\nCurrent Code:\r\n${error.code}\r\n`\r\n    : \"\"\r\n}\r\n\r\nProvide a corrected version of the code with explanation.\r\nFocus on FARM stack patterns and best practices.\r\n`;\r\n\r\n    try {\r\n      const response = await this.aiProvider.chat(\r\n        [\r\n          {\r\n            role: \"system\",\r\n            content:\r\n              \"You are a FARM stack expert. Provide accurate, working code fixes.\",\r\n          },\r\n          {\r\n            role: \"user\",\r\n            content: prompt,\r\n          },\r\n        ],\r\n        {\r\n          model: \"gpt-4\",\r\n          temperature: 0.1,\r\n          max_tokens: 800,\r\n        }\r\n      );\r\n\r\n      return this.parseCodeFix(response);\r\n    } catch (error) {\r\n      console.warn(\"AI code fix generation failed:\", error.message);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private shouldGenerateCodeFix(error: FarmError): boolean {\r\n    const fixableTypes = [\r\n      \"syntax-error\",\r\n      \"type-error\",\r\n      \"import-error\",\r\n      \"api-error\",\r\n      \"validation-error\",\r\n    ];\r\n\r\n    return fixableTypes.includes(error.type) && error.file && error.line;\r\n  }\r\n}\r\n```\r\n\r\n### 4. Developer Feedback Interface\r\n\r\n**Rich, Actionable Error Display:**\r\n\r\n```typescript\r\n// packages/core/src/errors/feedback.ts\r\nimport chalk from \"chalk\";\r\nimport boxen from \"boxen\";\r\nimport figures from \"figures\";\r\n\r\nexport class DeveloperFeedback {\r\n  private config: ErrorHandlingConfig;\r\n\r\n  constructor(config: ErrorHandlingConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  async displayError(context: ErrorContext): Promise<void> {\r\n    const { error, correlation, analysis, suggestions } = context;\r\n\r\n    console.log(\"\\n\"); // Add spacing\r\n\r\n    // Main error display\r\n    this.displayMainError(error);\r\n\r\n    // Show correlation if exists\r\n    if (correlation) {\r\n      this.displayCorrelation(correlation);\r\n    }\r\n\r\n    // Show AI analysis if available\r\n    if (analysis) {\r\n      this.displayAnalysis(analysis);\r\n    }\r\n\r\n    // Show suggestions\r\n    if (suggestions.length > 0) {\r\n      this.displaySuggestions(suggestions);\r\n    }\r\n\r\n    // Show debugging tools\r\n    this.displayDebuggingTools(context);\r\n\r\n    // Show related resources\r\n    this.displayResources(error);\r\n\r\n    console.log(\"\\n\"); // Add spacing\r\n  }\r\n\r\n  private displayMainError(error: FarmError): void {\r\n    const icon = this.getErrorIcon(error.type);\r\n    const title = chalk.red.bold(\r\n      `${icon} ${error.component.toUpperCase()} ERROR`\r\n    );\r\n\r\n    const content = [\r\n      `${chalk.red(\"Message:\")} ${error.message}`,\r\n      `${chalk.gray(\"Type:\")} ${error.type}`,\r\n      `${chalk.gray(\"Component:\")} ${error.component}`,\r\n      error.file && `${chalk.gray(\"File:\")} ${error.file}:${error.line || \"?\"}`,\r\n      error.timestamp &&\r\n        `${chalk.gray(\"Time:\")} ${new Date(\r\n          error.timestamp\r\n        ).toLocaleTimeString()}`,\r\n    ]\r\n      .filter(Boolean)\r\n      .join(\"\\n\");\r\n\r\n    console.log(\r\n      boxen(content, {\r\n        title,\r\n        padding: 1,\r\n        margin: 1,\r\n        borderStyle: \"round\",\r\n        borderColor: \"red\",\r\n      })\r\n    );\r\n\r\n    // Show stack trace if available\r\n    if (error.stack && this.config.showStackTrace) {\r\n      this.displayStackTrace(error.stack);\r\n    }\r\n  }\r\n\r\n  private displayCorrelation(correlation: ErrorCorrelation): void {\r\n    if (correlation.type === \"cascade\" && correlation.rootCause) {\r\n      const icon = figures.arrowDown;\r\n      console.log(chalk.yellow(`\\n${icon} RELATED ERROR DETECTED`));\r\n      console.log(\r\n        chalk.gray(`Root cause in ${correlation.rootCause.error.component}:`)\r\n      );\r\n      console.log(chalk.gray(`\"${correlation.rootCause.error.message}\"`));\r\n      console.log(chalk.yellow(`${figures.info} ${correlation.description}`));\r\n      console.log(\r\n        chalk.gray(`Confidence: ${Math.round(correlation.confidence * 100)}%`)\r\n      );\r\n    }\r\n  }\r\n\r\n  private displayAnalysis(analysis: AIErrorAnalysis): void {\r\n    console.log(chalk.blue(`\\n${figures.lightbulb} AI ANALYSIS`));\r\n\r\n    // Root cause\r\n    if (analysis.rootCause) {\r\n      console.log(chalk.blue(\"Root Cause:\"));\r\n      console.log(chalk.gray(this.wrapText(analysis.rootCause, 80)));\r\n    }\r\n\r\n    // Fix steps\r\n    if (analysis.fixSteps.length > 0) {\r\n      console.log(chalk.blue(\"\\nRecommended Fix:\"));\r\n      analysis.fixSteps.forEach((step, index) => {\r\n        console.log(chalk.gray(`${index + 1}. ${step}`));\r\n      });\r\n    }\r\n  }\r\n\r\n  private displaySuggestions(suggestions: ErrorSuggestion[]): void {\r\n    console.log(chalk.green(`\\n${figures.play} QUICK FIXES`));\r\n\r\n    suggestions.forEach((suggestion, index) => {\r\n      const icon = this.getSuggestionIcon(suggestion.type);\r\n      console.log(chalk.green(`${icon} ${suggestion.title}`));\r\n\r\n      if (suggestion.description) {\r\n        console.log(chalk.gray(`   ${suggestion.description}`));\r\n      }\r\n\r\n      if (suggestion.command) {\r\n        console.log(chalk.cyan(`   $ ${suggestion.command}`));\r\n      }\r\n\r\n      if (suggestion.codeExample) {\r\n        console.log(chalk.gray(\"   Example:\"));\r\n        console.log(\r\n          chalk.gray(\"   \" + suggestion.codeExample.split(\"\\n\").join(\"\\n   \"))\r\n        );\r\n      }\r\n\r\n      console.log(); // Add spacing between suggestions\r\n    });\r\n  }\r\n\r\n  private displayDebuggingTools(context: ErrorContext): void {\r\n    const tools = this.getAvailableDebuggingTools(context.error);\r\n\r\n    if (tools.length > 0) {\r\n      console.log(chalk.magenta(`\\n${figures.wrench} DEBUGGING TOOLS`));\r\n\r\n      tools.forEach((tool) => {\r\n        console.log(\r\n          chalk.magenta(`${figures.pointer} ${tool.name}: ${tool.command}`)\r\n        );\r\n        if (tool.description) {\r\n          console.log(chalk.gray(`   ${tool.description}`));\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  private displayResources(error: FarmError): void {\r\n    const resources = this.getRelatedResources(error);\r\n\r\n    if (resources.length > 0) {\r\n      console.log(chalk.blue(`\\n${figures.info} HELPFUL RESOURCES`));\r\n\r\n      resources.forEach((resource) => {\r\n        console.log(chalk.blue(`${figures.arrowRight} ${resource.title}`));\r\n        console.log(chalk.gray(`   ${resource.url}`));\r\n      });\r\n    }\r\n  }\r\n\r\n  private displayStackTrace(stack: string[]): void {\r\n    console.log(chalk.gray(\"\\nStack Trace:\"));\r\n    stack.slice(0, 5).forEach((line, index) => {\r\n      const isUserCode = this.isUserCode(line);\r\n      const color = isUserCode ? chalk.white : chalk.gray;\r\n      console.log(color(`  ${index + 1}. ${line}`));\r\n    });\r\n\r\n    if (stack.length > 5) {\r\n      console.log(chalk.gray(`  ... and ${stack.length - 5} more`));\r\n    }\r\n  }\r\n\r\n  private getErrorIcon(errorType: string): string {\r\n    const icons: Record<string, string> = {\r\n      \"syntax-error\": \"❌\",\r\n      \"type-error\": \"🔤\",\r\n      \"import-error\": \"📦\",\r\n      \"api-error\": \"🌐\",\r\n      \"database-error\": \"🗄️\",\r\n      \"ai-error\": \"🤖\",\r\n      \"build-error\": \"🔨\",\r\n      \"runtime-error\": \"⚡\",\r\n      \"validation-error\": \"✅\",\r\n      \"permission-error\": \"🔒\",\r\n      \"network-error\": \"📡\",\r\n      \"configuration-error\": \"⚙️\",\r\n    };\r\n\r\n    return icons[errorType] || \"❌\";\r\n  }\r\n\r\n  private getSuggestionIcon(suggestionType: string): string {\r\n    const icons: Record<string, string> = {\r\n      command: \"💻\",\r\n      \"code-fix\": \"🔧\",\r\n      configuration: \"⚙️\",\r\n      documentation: \"📚\",\r\n      dependency: \"📦\",\r\n      restart: \"🔄\",\r\n    };\r\n\r\n    return icons[suggestionType] || \"💡\";\r\n  }\r\n\r\n  private getAvailableDebuggingTools(error: FarmError): DebuggingTool[] {\r\n    const tools: DebuggingTool[] = [];\r\n\r\n    // Component-specific debugging tools\r\n    switch (error.component) {\r\n      case \"frontend\":\r\n        tools.push({\r\n          name: \"Open React DevTools\",\r\n          command: \"farm debug react\",\r\n          description: \"Inspect React component tree and state\",\r\n        });\r\n        break;\r\n\r\n      case \"backend\":\r\n        tools.push({\r\n          name: \"View API Logs\",\r\n          command: \"farm logs backend\",\r\n          description: \"Show recent FastAPI server logs\",\r\n        });\r\n        break;\r\n\r\n      case \"database\":\r\n        tools.push({\r\n          name: \"Test Database Connection\",\r\n          command: \"farm db connect\",\r\n          description: \"Verify database connectivity\",\r\n        });\r\n        break;\r\n\r\n      case \"ai\":\r\n        tools.push({\r\n          name: \"Check AI Provider Status\",\r\n          command: \"farm ai status\",\r\n          description: \"Verify AI provider connections and models\",\r\n        });\r\n        break;\r\n    }\r\n\r\n    // General debugging tools\r\n    tools.push({\r\n      name: \"View All Logs\",\r\n      command: \"farm logs --all\",\r\n      description: \"Show logs from all services\",\r\n    });\r\n\r\n    tools.push({\r\n      name: \"System Health Check\",\r\n      command: \"farm health\",\r\n      description: \"Check status of all FARM components\",\r\n    });\r\n\r\n    return tools;\r\n  }\r\n\r\n  private getRelatedResources(error: FarmError): Resource[] {\r\n    const resources: Resource[] = [];\r\n\r\n    // Add component-specific documentation\r\n    const baseUrl = \"https://farm-stack.dev/docs\";\r\n\r\n    switch (error.component) {\r\n      case \"frontend\":\r\n        resources.push({\r\n          title: \"Frontend Troubleshooting Guide\",\r\n          url: `${baseUrl}/frontend/troubleshooting`,\r\n        });\r\n        break;\r\n\r\n      case \"backend\":\r\n        resources.push({\r\n          title: \"Backend API Documentation\",\r\n          url: `${baseUrl}/backend/api`,\r\n        });\r\n        break;\r\n\r\n      case \"database\":\r\n        resources.push({\r\n          title: \"Database Configuration Guide\",\r\n          url: `${baseUrl}/database/configuration`,\r\n        });\r\n        break;\r\n\r\n      case \"ai\":\r\n        resources.push({\r\n          title: \"AI Integration Guide\",\r\n          url: `${baseUrl}/ai/setup`,\r\n        });\r\n        break;\r\n    }\r\n\r\n    // Add error-type specific resources\r\n    if (error.type === \"type-error\") {\r\n      resources.push({\r\n        title: \"TypeScript Type System Guide\",\r\n        url: `${baseUrl}/typescript/types`,\r\n      });\r\n    }\r\n\r\n    // Always add general troubleshooting\r\n    resources.push({\r\n      title: \"General Troubleshooting\",\r\n      url: `${baseUrl}/troubleshooting`,\r\n    });\r\n\r\n    return resources;\r\n  }\r\n\r\n  private isUserCode(stackLine: string): boolean {\r\n    return (\r\n      stackLine.includes(\"/apps/\") ||\r\n      stackLine.includes(\"/src/\") ||\r\n      !stackLine.includes(\"node_modules\")\r\n    );\r\n  }\r\n\r\n  private wrapText(text: string, width: number): string {\r\n    const words = text.split(\" \");\r\n    const lines: string[] = [];\r\n    let currentLine = \"\";\r\n\r\n    words.forEach((word) => {\r\n      if (currentLine.length + word.length + 1 <= width) {\r\n        currentLine += (currentLine ? \" \" : \"\") + word;\r\n      } else {\r\n        if (currentLine) lines.push(currentLine);\r\n        currentLine = word;\r\n      }\r\n    });\r\n\r\n    if (currentLine) lines.push(currentLine);\r\n    return lines.join(\"\\n\");\r\n  }\r\n}\r\n```\r\n\r\n### 5. Performance Issue Detection\r\n\r\n**Proactive Performance Monitoring:**\r\n\r\n```typescript\r\n// packages/core/src/errors/performance-monitor.ts\r\nexport class PerformanceMonitor {\r\n  private metrics: PerformanceMetric[] = [];\r\n  private thresholds: PerformanceThresholds;\r\n  private alerts: PerformanceAlert[] = [];\r\n\r\n  constructor(config: ErrorHandlingConfig) {\r\n    this.thresholds = config.performanceThresholds;\r\n    this.startMonitoring();\r\n  }\r\n\r\n  private startMonitoring(): void {\r\n    // Monitor memory usage\r\n    setInterval(() => {\r\n      this.checkMemoryUsage();\r\n    }, 30000); // Every 30 seconds\r\n\r\n    // Monitor response times\r\n    this.setupResponseTimeMonitoring();\r\n\r\n    // Monitor build performance\r\n    this.setupBuildPerformanceMonitoring();\r\n\r\n    // Monitor hot reload performance\r\n    this.setupHotReloadMonitoring();\r\n  }\r\n\r\n  private checkMemoryUsage(): void {\r\n    const usage = process.memoryUsage();\r\n    const heapUsedMB = usage.heapUsed / 1024 / 1024;\r\n\r\n    if (heapUsedMB > this.thresholds.memoryUsageMB) {\r\n      this.createAlert({\r\n        type: \"memory\",\r\n        severity: \"warning\",\r\n        message: `High memory usage detected: ${heapUsedMB.toFixed(1)}MB`,\r\n        suggestions: [\r\n          {\r\n            type: \"command\",\r\n            title: \"Restart development server\",\r\n            command: \"farm dev --restart\",\r\n            description: \"Clear memory and restart all services\",\r\n          },\r\n          {\r\n            type: \"documentation\",\r\n            title: \"Memory optimization guide\",\r\n            description:\r\n              \"Learn how to optimize memory usage in FARM applications\",\r\n          },\r\n        ],\r\n      });\r\n    }\r\n  }\r\n\r\n  recordAPIResponseTime(endpoint: string, duration: number): void {\r\n    if (duration > this.thresholds.apiResponseTimeMs) {\r\n      this.createAlert({\r\n        type: \"api-performance\",\r\n        severity: \"warning\",\r\n        message: `Slow API response: ${endpoint} took ${duration}ms`,\r\n        suggestions: [\r\n          {\r\n            type: \"code-fix\",\r\n            title: \"Optimize database queries\",\r\n            description: \"Add database indexes or optimize query logic\",\r\n          },\r\n          {\r\n            type: \"command\",\r\n            title: \"Profile API endpoint\",\r\n            command: `farm profile api ${endpoint}`,\r\n            description: \"Get detailed performance breakdown\",\r\n          },\r\n        ],\r\n      });\r\n    }\r\n  }\r\n\r\n  recordBuildTime(component: string, duration: number): void {\r\n    if (duration > this.thresholds.buildTimeMs) {\r\n      this.createAlert({\r\n        type: \"build-performance\",\r\n        severity: \"info\",\r\n        message: `Slow build detected: ${component} took ${duration}ms`,\r\n        suggestions: [\r\n          {\r\n            type: \"configuration\",\r\n            title: \"Enable build cache\",\r\n            description: \"Reduce build times with intelligent caching\",\r\n          },\r\n          {\r\n            type: \"command\",\r\n            title: \"Analyze build bundle\",\r\n            command: \"farm build --analyze\",\r\n            description:\r\n              \"Identify large dependencies and optimization opportunities\",\r\n          },\r\n        ],\r\n      });\r\n    }\r\n  }\r\n\r\n  recordHotReloadTime(type: string, duration: number): void {\r\n    if (duration > this.thresholds.hotReloadTimeMs) {\r\n      this.createAlert({\r\n        type: \"hot-reload-performance\",\r\n        severity: \"info\",\r\n        message: `Slow hot reload: ${type} took ${duration}ms`,\r\n        suggestions: [\r\n          {\r\n            type: \"configuration\",\r\n            title: \"Optimize file watching\",\r\n            description: \"Adjust file watch patterns to reduce overhead\",\r\n          },\r\n          {\r\n            type: \"command\",\r\n            title: \"Check system resources\",\r\n            command: \"farm status --verbose\",\r\n            description: \"Verify system has adequate resources\",\r\n          },\r\n        ],\r\n      });\r\n    }\r\n  }\r\n\r\n  private createAlert(alert: PerformanceAlert): void {\r\n    this.alerts.push({\r\n      ...alert,\r\n      timestamp: Date.now(),\r\n      id: this.generateAlertId(),\r\n    });\r\n\r\n    // Limit alert history\r\n    if (this.alerts.length > 50) {\r\n      this.alerts = this.alerts.slice(-50);\r\n    }\r\n\r\n    // Display alert to developer\r\n    this.displayPerformanceAlert(alert);\r\n  }\r\n\r\n  private displayPerformanceAlert(alert: PerformanceAlert): void {\r\n    const icon = alert.severity === \"warning\" ? \"⚠️\" : \"ℹ️\";\r\n    const color = alert.severity === \"warning\" ? chalk.yellow : chalk.blue;\r\n\r\n    console.log(\"\\n\" + color(`${icon} PERFORMANCE ALERT`));\r\n    console.log(color(alert.message));\r\n\r\n    if (alert.suggestions && alert.suggestions.length > 0) {\r\n      console.log(color(\"\\nSuggestions:\"));\r\n      alert.suggestions.forEach((suggestion) => {\r\n        console.log(color(`• ${suggestion.title}`));\r\n        if (suggestion.command) {\r\n          console.log(chalk.gray(`  $ ${suggestion.command}`));\r\n        }\r\n        if (suggestion.description) {\r\n          console.log(chalk.gray(`  ${suggestion.description}`));\r\n        }\r\n      });\r\n    }\r\n\r\n    console.log(); // Add spacing\r\n  }\r\n}\r\n```\r\n\r\n### 6. Error Recovery Mechanisms\r\n\r\n**Automatic Error Recovery:**\r\n\r\n```typescript\r\n// packages/core/src/errors/recovery.ts\r\nexport class ErrorRecovery {\r\n  private recoveryStrategies: Map<string, RecoveryStrategy> = new Map();\r\n  private recoveryAttempts: Map<string, number> = new Map();\r\n\r\n  constructor() {\r\n    this.setupRecoveryStrategies();\r\n  }\r\n\r\n  async attemptRecovery(\r\n    error: FarmError,\r\n    context: ErrorContext\r\n  ): Promise<RecoveryResult> {\r\n    const strategyKey = `${error.component}-${error.type}`;\r\n    const strategy =\r\n      this.recoveryStrategies.get(strategyKey) ||\r\n      this.recoveryStrategies.get(error.component) ||\r\n      this.recoveryStrategies.get(\"default\");\r\n\r\n    if (!strategy) {\r\n      return { success: false, message: \"No recovery strategy available\" };\r\n    }\r\n\r\n    const attempts = this.recoveryAttempts.get(strategyKey) || 0;\r\n\r\n    if (attempts >= strategy.maxAttempts) {\r\n      return {\r\n        success: false,\r\n        message: `Maximum recovery attempts (${strategy.maxAttempts}) exceeded`,\r\n      };\r\n    }\r\n\r\n    console.log(\r\n      `🔄 Attempting automatic recovery for ${error.component} ${error.type}...`\r\n    );\r\n\r\n    try {\r\n      const result = await strategy.recover(error, context);\r\n\r\n      if (result.success) {\r\n        console.log(`✅ Recovery successful: ${result.message}`);\r\n        this.recoveryAttempts.delete(strategyKey);\r\n      } else {\r\n        this.recoveryAttempts.set(strategyKey, attempts + 1);\r\n        console.log(`❌ Recovery failed: ${result.message}`);\r\n      }\r\n\r\n      return result;\r\n    } catch (recoveryError) {\r\n      this.recoveryAttempts.set(strategyKey, attempts + 1);\r\n      console.error(`❌ Recovery attempt failed:`, recoveryError.message);\r\n\r\n      return {\r\n        success: false,\r\n        message: `Recovery attempt failed: ${recoveryError.message}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  private setupRecoveryStrategies(): void {\r\n    // Database connection recovery\r\n    this.recoveryStrategies.set(\"database-connection-error\", {\r\n      name: \"Database Connection Recovery\",\r\n      maxAttempts: 3,\r\n      recover: async (error, context) => {\r\n        // Wait and retry connection\r\n        await this.delay(2000);\r\n\r\n        try {\r\n          // Attempt to reconnect\r\n          await this.testDatabaseConnection();\r\n          return { success: true, message: \"Database connection restored\" };\r\n        } catch (e) {\r\n          return { success: false, message: \"Database still unreachable\" };\r\n        }\r\n      },\r\n    });\r\n\r\n    // AI provider recovery\r\n    this.recoveryStrategies.set(\"ai-provider-error\", {\r\n      name: \"AI Provider Recovery\",\r\n      maxAttempts: 2,\r\n      recover: async (error, context) => {\r\n        // Try to restart AI provider or switch to fallback\r\n        if (error.message.includes(\"ollama\")) {\r\n          try {\r\n            await this.restartOllamaService();\r\n            return { success: true, message: \"Ollama service restarted\" };\r\n          } catch (e) {\r\n            // Fallback to OpenAI if available\r\n            try {\r\n              await this.switchToFallbackAIProvider();\r\n              return {\r\n                success: true,\r\n                message: \"Switched to fallback AI provider\",\r\n              };\r\n            } catch (fallbackError) {\r\n              return {\r\n                success: false,\r\n                message: \"All AI providers unavailable\",\r\n              };\r\n            }\r\n          }\r\n        }\r\n\r\n        return { success: false, message: \"Unknown AI provider error\" };\r\n      },\r\n    });\r\n\r\n    // Type generation recovery\r\n    this.recoveryStrategies.set(\"codegen-type-generation-error\", {\r\n      name: \"Type Generation Recovery\",\r\n      maxAttempts: 2,\r\n      recover: async (error, context) => {\r\n        try {\r\n          // Clear type cache and regenerate\r\n          await this.clearTypeCache();\r\n          await this.regenerateTypes();\r\n          return { success: true, message: \"Types regenerated successfully\" };\r\n        } catch (e) {\r\n          return { success: false, message: \"Type generation still failing\" };\r\n        }\r\n      },\r\n    });\r\n\r\n    // Frontend compilation recovery\r\n    this.recoveryStrategies.set(\"frontend-compilation-error\", {\r\n      name: \"Frontend Compilation Recovery\",\r\n      maxAttempts: 1,\r\n      recover: async (error, context) => {\r\n        try {\r\n          // Clear node_modules cache and reinstall\r\n          await this.clearNodeCache();\r\n          await this.reinstallDependencies();\r\n          return { success: true, message: \"Dependencies reinstalled\" };\r\n        } catch (e) {\r\n          return { success: false, message: \"Dependency reinstall failed\" };\r\n        }\r\n      },\r\n    });\r\n\r\n    // Default recovery strategy\r\n    this.recoveryStrategies.set(\"default\", {\r\n      name: \"Default Recovery\",\r\n      maxAttempts: 1,\r\n      recover: async (error, context) => {\r\n        // Generic recovery: restart the affected service\r\n        try {\r\n          await this.restartService(error.component);\r\n          return {\r\n            success: true,\r\n            message: `${error.component} service restarted`,\r\n          };\r\n        } catch (e) {\r\n          return { success: false, message: \"Service restart failed\" };\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  private async delay(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n\r\n  private async testDatabaseConnection(): Promise<void> {\r\n    // Implementation would test actual database connection\r\n    throw new Error(\"Not implemented\");\r\n  }\r\n\r\n  private async restartOllamaService(): Promise<void> {\r\n    // Implementation would restart Ollama Docker container\r\n    throw new Error(\"Not implemented\");\r\n  }\r\n\r\n  private async switchToFallbackAIProvider(): Promise<void> {\r\n    // Implementation would switch AI provider configuration\r\n    throw new Error(\"Not implemented\");\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## CLI Error Commands\r\n\r\n### 1. Error Management CLI\r\n\r\n**Developer Error Tools:**\r\n\r\n```bash\r\n# Error investigation commands\r\nfarm errors list                    # Show recent errors\r\nfarm errors show <error-id>         # Show detailed error information\r\nfarm errors search <query>          # Search error history\r\nfarm errors export                  # Export error logs for support\r\n\r\n# Debugging commands\r\nfarm debug                          # Start interactive debugging session\r\nfarm debug component <name>         # Debug specific component\r\nfarm logs --follow                  # Follow live logs from all services\r\nfarm logs backend --errors          # Show only backend errors\r\n\r\n# Health and status\r\nfarm health                         # System health check\r\nfarm status --verbose               # Detailed system status\r\nfarm doctor                         # Automated problem detection\r\n\r\n# Recovery commands\r\nfarm recover                        # Attempt automatic recovery\r\nfarm restart <component>            # Restart specific component\r\nfarm reset --dev                    # Reset development environment\r\n```\r\n\r\n### 2. CLI Implementation\r\n\r\n**Error CLI Commands:**\r\n\r\n```typescript\r\n// packages/cli/src/commands/errors/index.ts\r\nexport function createErrorCommands(): Command {\r\n  const errors = new Command(\"errors\");\r\n  errors.description(\"Error management and debugging tools\");\r\n\r\n  errors\r\n    .command(\"list\")\r\n    .option(\"-h, --hours <hours>\", \"Hours of history to show\", \"24\")\r\n    .option(\"-c, --component <component>\", \"Filter by component\")\r\n    .option(\"-t, --type <type>\", \"Filter by error type\")\r\n    .action(async (options) => {\r\n      const errorManager = await getErrorManager();\r\n      const history = await errorManager.getErrorHistory(\r\n        parseInt(options.hours)\r\n      );\r\n\r\n      if (history.length === 0) {\r\n        console.log(\r\n          chalk.green(\"🎉 No errors found in the specified time period!\")\r\n        );\r\n        return;\r\n      }\r\n\r\n      console.log(\r\n        chalk.blue(\r\n          `\\n📋 Found ${history.length} errors in the last ${options.hours} hours:\\n`\r\n        )\r\n      );\r\n\r\n      history.forEach((context, index) => {\r\n        const error = context.error;\r\n        const timeAgo = formatTimeAgo(context.timestamp);\r\n        const icon = getErrorIcon(error.type);\r\n\r\n        console.log(\r\n          `${icon} ${chalk.red(error.component)} - ${error.message.substring(\r\n            0,\r\n            60\r\n          )}...`\r\n        );\r\n        console.log(\r\n          chalk.gray(`   ${timeAgo} • Type: ${error.type} • ID: ${context.id}`)\r\n        );\r\n        console.log();\r\n      });\r\n\r\n      console.log(\r\n        chalk.blue(`Use 'farm errors show <id>' for detailed information`)\r\n      );\r\n    });\r\n\r\n  const doctor = new Command(\"doctor\");\r\n  doctor.description(\"Automated problem detection and solutions\");\r\n\r\n  doctor.action(async () => {\r\n    console.log(chalk.blue(\"🩺 Running FARM health diagnostics...\\n\"));\r\n\r\n    const diagnostics = new HealthDiagnostics();\r\n    const results = await diagnostics.runFullDiagnostic();\r\n\r\n    displayDiagnosticResults(results);\r\n  });\r\n\r\n  return errors;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Integration with Development Workflow\r\n\r\n### 1. IDE Integration\r\n\r\n**Error Information in Development Environment:**\r\n\r\n```typescript\r\n// packages/core/src/errors/ide-integration.ts\r\nexport class IDEIntegration {\r\n  async sendErrorToIDE(context: ErrorContext): Promise<void> {\r\n    // Send error information to VS Code, WebStorm, etc.\r\n    const errorData = {\r\n      file: context.error.file,\r\n      line: context.error.line,\r\n      column: context.error.column,\r\n      message: context.error.message,\r\n      severity: this.mapSeverity(context.error.type),\r\n      suggestions: context.suggestions,\r\n      quickFixes: await this.generateQuickFixes(context),\r\n    };\r\n\r\n    // VS Code integration\r\n    await this.sendToVSCode(errorData);\r\n\r\n    // Create problem matcher output for terminal\r\n    this.outputProblemMatcher(errorData);\r\n  }\r\n\r\n  private async generateQuickFixes(context: ErrorContext): Promise<QuickFix[]> {\r\n    const fixes: QuickFix[] = [];\r\n\r\n    // Generate code fixes based on error type\r\n    if (context.error.type === \"import-error\") {\r\n      fixes.push({\r\n        title: \"Add missing import\",\r\n        edit: await this.generateImportFix(context.error),\r\n      });\r\n    }\r\n\r\n    if (context.error.type === \"type-error\") {\r\n      fixes.push({\r\n        title: \"Fix type annotation\",\r\n        edit: await this.generateTypeFix(context.error),\r\n      });\r\n    }\r\n\r\n    return fixes;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Configuration Integration\r\n\r\n### 1. Error Handling Configuration\r\n\r\n**TypeScript Configuration:**\r\n\r\n```typescript\r\n// farm.config.ts - Error handling configuration\r\nexport default defineConfig({\r\n  errorHandling: {\r\n    // Error collection and analysis\r\n    enabled: true,\r\n    collectStackTraces: true,\r\n    maxErrorHistory: 1000,\r\n\r\n    // AI-powered error analysis\r\n    aiSuggestions: {\r\n      enabled: true,\r\n      provider: \"openai\", // or 'ollama'\r\n      model: \"gpt-4\",\r\n      maxSuggestions: 5,\r\n    },\r\n\r\n    // Developer feedback\r\n    feedback: {\r\n      showInTerminal: true,\r\n      showStackTrace: process.env.NODE_ENV === \"development\",\r\n      colorOutput: true,\r\n      detailedSuggestions: true,\r\n      showPerformanceAlerts: true,\r\n    },\r\n\r\n    // Error correlation\r\n    correlation: {\r\n      enabled: true,\r\n      timeWindowMs: 300000, // 5 minutes\r\n      cascadeDetection: true,\r\n      crossComponentAnalysis: true,\r\n    },\r\n\r\n    // Performance monitoring\r\n    performanceThresholds: {\r\n      memoryUsageMB: 1024,\r\n      apiResponseTimeMs: 2000,\r\n      buildTimeMs: 30000,\r\n      hotReloadTimeMs: 5000,\r\n    },\r\n\r\n    // Recovery mechanisms\r\n    autoRecovery: {\r\n      enabled: true,\r\n      maxAttempts: 3,\r\n      strategies: [\"restart\", \"fallback\", \"cache-clear\"],\r\n    },\r\n\r\n    // Production error handling\r\n    production: {\r\n      reportErrors: true,\r\n      errorReporting: {\r\n        service: \"sentry\", // or 'custom'\r\n        apiKey: process.env.ERROR_REPORTING_KEY,\r\n      },\r\n      suppressStackTraces: true,\r\n      logLevel: \"error\",\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n---\r\n\r\n_Status: ✅ Completed - Ready for implementation_\r\n\r\nThis comprehensive error handling system provides:\r\n\r\n- **Central error aggregation** across all FARM components\r\n- **Intelligent error correlation** to identify root causes and cascading failures\r\n- **AI-powered error analysis** with actionable solutions and code fixes\r\n- **Rich developer feedback** with terminal-based error display\r\n- **Performance monitoring** with proactive issue detection\r\n- **Automatic error recovery** mechanisms to maintain development flow\r\n- **Cross-stack debugging tools** integrated with the CLI\r\n- **IDE integration** for seamless development workflow\r\n- **Production-ready error reporting** with privacy and security considerations\r\n\r\nThe system maintains FARM's commitment to excellent developer experience by turning errors from roadblocks into learning opportunities with clear, actionable guidance for resolution.\r\n\r\n---\r\n\r\n## Phase 2 Completion Summary\r\n\r\n✅ **Plugin System Architecture** - Type-safe, hot-reloadable plugin system\r\n✅ **Authentication & Authorization Flow** - Comprehensive auth with RBAC and AI integration  \r\n✅ **Database Integration Architecture** - MongoDB-first with flexible multi-database support\r\n✅ **Build System Architecture** - Production-ready build pipeline with optimization\r\n✅ **Hot Reload System Design** - Intelligent cross-stack hot reloading\r\n✅ **Error Handling & Developer Feedback** - AI-powered error management and recovery\r\n",
      "excerpt": "The FARM error handling system provides comprehensive error management, developer-friendly feedback, and intelligent debugging assistance across the entire stac...",
      "category": "architectural-sketches-detailed/phase2",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.781Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase2",
        "Error_handling_developer_feedback"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Error Handling & Developer Feedback",
          "id": "error-handling-developer-feedback"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "High-Level Error Management Architecture",
          "id": "high-level-error-management-architecture"
        },
        {
          "level": 2,
          "text": "Core Error Management System",
          "id": "core-error-management-system"
        },
        {
          "level": 3,
          "text": "1. Central Error Aggregator",
          "id": "1-central-error-aggregator"
        },
        {
          "level": 3,
          "text": "2. Cross-Stack Error Correlation",
          "id": "2-cross-stack-error-correlation"
        },
        {
          "level": 3,
          "text": "3. AI-Powered Error Analysis",
          "id": "3-ai-powered-error-analysis"
        },
        {
          "level": 3,
          "text": "4. Developer Feedback Interface",
          "id": "4-developer-feedback-interface"
        },
        {
          "level": 3,
          "text": "5. Performance Issue Detection",
          "id": "5-performance-issue-detection"
        },
        {
          "level": 3,
          "text": "6. Error Recovery Mechanisms",
          "id": "6-error-recovery-mechanisms"
        },
        {
          "level": 2,
          "text": "CLI Error Commands",
          "id": "cli-error-commands"
        },
        {
          "level": 3,
          "text": "1. Error Management CLI",
          "id": "1-error-management-cli"
        },
        {
          "level": 1,
          "text": "Error investigation commands",
          "id": "error-investigation-commands"
        },
        {
          "level": 1,
          "text": "Debugging commands",
          "id": "debugging-commands"
        },
        {
          "level": 1,
          "text": "Health and status",
          "id": "health-and-status"
        },
        {
          "level": 1,
          "text": "Recovery commands",
          "id": "recovery-commands"
        },
        {
          "level": 3,
          "text": "2. CLI Implementation",
          "id": "2-cli-implementation"
        },
        {
          "level": 2,
          "text": "Integration with Development Workflow",
          "id": "integration-with-development-workflow"
        },
        {
          "level": 3,
          "text": "1. IDE Integration",
          "id": "1-ide-integration"
        },
        {
          "level": 2,
          "text": "Configuration Integration",
          "id": "configuration-integration"
        },
        {
          "level": 3,
          "text": "1. Error Handling Configuration",
          "id": "1-error-handling-configuration"
        },
        {
          "level": 2,
          "text": "Phase 2 Completion Summary",
          "id": "phase-2-completion-summary"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase2-hot_reload_system_design",
      "title": "Hot_reload_system_design",
      "url": "/architectural-sketches-detailed/phase2/hot_reload_system_design",
      "content": "# Hot Reload System Design\r\n\r\n## Overview\r\n\r\nThe FARM hot reload system provides intelligent, cross-stack hot reloading that coordinates updates across React frontend, FastAPI backend, database schemas, AI models, and plugins. It features dependency-aware reloading, type generation integration, and AI model hot-swapping to maintain development flow without service restarts.\r\n\r\n---\r\n\r\n## High-Level Hot Reload Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Hot Reload System                      │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │File Watcher │  │ Dependency  │  │   Change    │  │ Reload  │ │\r\n│  │   Engine    │  │   Graph     │  │ Analyzer    │  │Coordinator│ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │   Vite      │  │  FastAPI    │  │    Type     │  │   AI    │ │\r\n│  │    HMR      │  │   Reload    │  │ Generation  │  │ Models  │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Database    │  │   Plugin    │  │   Error     │  │ Client  │ │\r\n│  │   Schema    │  │   System    │  │  Recovery   │  │ Notify  │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Hot Reload Components\r\n\r\n### 1. Hot Reload Coordinator\r\n\r\n**Central Intelligence for Cross-Stack Reloading:**\r\n\r\n```typescript\r\n// packages/core/src/hot-reload/coordinator.ts\r\nimport { EventEmitter } from \"events\";\r\nimport { FileWatcher } from \"./file-watcher\";\r\nimport { DependencyGraph } from \"./dependency-graph\";\r\nimport { ChangeAnalyzer } from \"./change-analyzer\";\r\nimport { TypeGenerator } from \"../codegen/type-generator\";\r\n\r\nexport class HotReloadCoordinator extends EventEmitter {\r\n  private fileWatcher: FileWatcher;\r\n  private dependencyGraph: DependencyGraph;\r\n  private changeAnalyzer: ChangeAnalyzer;\r\n  private typeGenerator: TypeGenerator;\r\n  private reloadQueue: ReloadTask[] = [];\r\n  private isProcessing = false;\r\n  private config: HotReloadConfig;\r\n\r\n  constructor(config: HotReloadConfig) {\r\n    super();\r\n    this.config = config;\r\n    this.fileWatcher = new FileWatcher(config.watchPaths);\r\n    this.dependencyGraph = new DependencyGraph();\r\n    this.changeAnalyzer = new ChangeAnalyzer();\r\n    this.typeGenerator = new TypeGenerator(config);\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    console.log(\"🔥 Initializing hot reload system...\");\r\n\r\n    // Build initial dependency graph\r\n    await this.buildDependencyGraph();\r\n\r\n    // Start file watching\r\n    await this.fileWatcher.start();\r\n\r\n    // Setup debounced processing\r\n    this.setupDebouncedProcessing();\r\n\r\n    console.log(\"✅ Hot reload system ready\");\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    this.fileWatcher.on(\"change\", this.handleFileChange.bind(this));\r\n    this.fileWatcher.on(\"add\", this.handleFileAdd.bind(this));\r\n    this.fileWatcher.on(\"unlink\", this.handleFileDelete.bind(this));\r\n    this.fileWatcher.on(\"addDir\", this.handleDirectoryAdd.bind(this));\r\n    this.fileWatcher.on(\"unlinkDir\", this.handleDirectoryDelete.bind(this));\r\n  }\r\n\r\n  private async handleFileChange(filePath: string): Promise<void> {\r\n    console.log(`📝 File changed: ${filePath}`);\r\n\r\n    try {\r\n      // Analyze the change\r\n      const change = await this.changeAnalyzer.analyzeFileChange(filePath);\r\n\r\n      // Determine affected components\r\n      const affectedComponents =\r\n        this.dependencyGraph.getAffectedComponents(filePath);\r\n\r\n      // Create reload tasks\r\n      const reloadTasks = this.createReloadTasks(change, affectedComponents);\r\n\r\n      // Queue tasks for processing\r\n      this.queueReloadTasks(reloadTasks);\r\n    } catch (error) {\r\n      console.error(\r\n        `❌ Error handling file change for ${filePath}:`,\r\n        error.message\r\n      );\r\n      this.emit(\"reload-error\", { filePath, error });\r\n    }\r\n  }\r\n\r\n  private createReloadTasks(\r\n    change: FileChange,\r\n    affected: AffectedComponent[]\r\n  ): ReloadTask[] {\r\n    const tasks: ReloadTask[] = [];\r\n\r\n    // Determine task types based on change type and affected components\r\n    if (change.type === \"backend-model\") {\r\n      tasks.push({\r\n        type: \"type-generation\",\r\n        priority: 1,\r\n        dependencies: [],\r\n        metadata: { modelFile: change.filePath },\r\n      });\r\n\r\n      tasks.push({\r\n        type: \"frontend-hmr\",\r\n        priority: 2,\r\n        dependencies: [\"type-generation\"],\r\n        metadata: { reason: \"types-updated\" },\r\n      });\r\n    }\r\n\r\n    if (change.type === \"backend-route\") {\r\n      tasks.push({\r\n        type: \"api-client-generation\",\r\n        priority: 1,\r\n        dependencies: [],\r\n        metadata: { routeFile: change.filePath },\r\n      });\r\n\r\n      tasks.push({\r\n        type: \"backend-reload\",\r\n        priority: 2,\r\n        dependencies: [\"api-client-generation\"],\r\n        metadata: { reason: \"route-updated\" },\r\n      });\r\n    }\r\n\r\n    if (change.type === \"ai-config\") {\r\n      tasks.push({\r\n        type: \"ai-model-reload\",\r\n        priority: 1,\r\n        dependencies: [],\r\n        metadata: { configFile: change.filePath },\r\n      });\r\n    }\r\n\r\n    if (change.type === \"frontend-component\") {\r\n      tasks.push({\r\n        type: \"frontend-hmr\",\r\n        priority: 1,\r\n        dependencies: [],\r\n        metadata: { component: change.filePath },\r\n      });\r\n    }\r\n\r\n    if (change.type === \"database-model\") {\r\n      tasks.push({\r\n        type: \"database-schema-update\",\r\n        priority: 1,\r\n        dependencies: [],\r\n        metadata: { modelFile: change.filePath },\r\n      });\r\n\r\n      tasks.push({\r\n        type: \"type-generation\",\r\n        priority: 2,\r\n        dependencies: [\"database-schema-update\"],\r\n        metadata: { reason: \"schema-updated\" },\r\n      });\r\n    }\r\n\r\n    if (change.type === \"plugin-config\") {\r\n      tasks.push({\r\n        type: \"plugin-reload\",\r\n        priority: 1,\r\n        dependencies: [],\r\n        metadata: { pluginPath: change.filePath },\r\n      });\r\n    }\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private queueReloadTasks(tasks: ReloadTask[]): void {\r\n    // Add tasks to queue with deduplication\r\n    for (const task of tasks) {\r\n      const existingIndex = this.reloadQueue.findIndex(\r\n        (existing) =>\r\n          existing.type === task.type &&\r\n          JSON.stringify(existing.metadata) === JSON.stringify(task.metadata)\r\n      );\r\n\r\n      if (existingIndex !== -1) {\r\n        // Update existing task\r\n        this.reloadQueue[existingIndex] = task;\r\n      } else {\r\n        // Add new task\r\n        this.reloadQueue.push(task);\r\n      }\r\n    }\r\n\r\n    // Trigger processing if not already running\r\n    if (!this.isProcessing) {\r\n      this.processReloadQueue();\r\n    }\r\n  }\r\n\r\n  private setupDebouncedProcessing(): void {\r\n    let debounceTimer: NodeJS.Timeout;\r\n\r\n    this.on(\"queue-updated\", () => {\r\n      clearTimeout(debounceTimer);\r\n      debounceTimer = setTimeout(() => {\r\n        if (!this.isProcessing && this.reloadQueue.length > 0) {\r\n          this.processReloadQueue();\r\n        }\r\n      }, this.config.debounceMs || 100);\r\n    });\r\n  }\r\n\r\n  private async processReloadQueue(): Promise<void> {\r\n    if (this.isProcessing || this.reloadQueue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    this.isProcessing = true;\r\n    console.log(`🔄 Processing ${this.reloadQueue.length} reload tasks...`);\r\n\r\n    try {\r\n      // Sort tasks by priority and dependencies\r\n      const sortedTasks = this.sortTasksByDependencies(this.reloadQueue);\r\n\r\n      // Execute tasks in order\r\n      for (const task of sortedTasks) {\r\n        await this.executeReloadTask(task);\r\n      }\r\n\r\n      // Clear completed tasks\r\n      this.reloadQueue = [];\r\n\r\n      console.log(\"✅ Hot reload completed\");\r\n      this.emit(\"reload-complete\");\r\n    } catch (error) {\r\n      console.error(\"❌ Hot reload failed:\", error.message);\r\n      this.emit(\"reload-error\", error);\r\n    } finally {\r\n      this.isProcessing = false;\r\n    }\r\n  }\r\n\r\n  private sortTasksByDependencies(tasks: ReloadTask[]): ReloadTask[] {\r\n    const sorted: ReloadTask[] = [];\r\n    const remaining = [...tasks];\r\n\r\n    while (remaining.length > 0) {\r\n      const readyTasks = remaining.filter((task) =>\r\n        task.dependencies.every((dep) =>\r\n          sorted.some((completed) => completed.type === dep)\r\n        )\r\n      );\r\n\r\n      if (readyTasks.length === 0) {\r\n        throw new Error(\"Circular dependency detected in reload tasks\");\r\n      }\r\n\r\n      // Sort ready tasks by priority\r\n      readyTasks.sort((a, b) => a.priority - b.priority);\r\n\r\n      // Add first ready task to sorted list\r\n      const nextTask = readyTasks[0];\r\n      sorted.push(nextTask);\r\n\r\n      // Remove from remaining\r\n      const index = remaining.indexOf(nextTask);\r\n      remaining.splice(index, 1);\r\n    }\r\n\r\n    return sorted;\r\n  }\r\n\r\n  private async executeReloadTask(task: ReloadTask): Promise<void> {\r\n    const startTime = Date.now();\r\n    console.log(`⚡ Executing ${task.type}...`);\r\n\r\n    try {\r\n      switch (task.type) {\r\n        case \"type-generation\":\r\n          await this.executeTypeGeneration(task);\r\n          break;\r\n        case \"api-client-generation\":\r\n          await this.executeApiClientGeneration(task);\r\n          break;\r\n        case \"frontend-hmr\":\r\n          await this.executeFrontendHMR(task);\r\n          break;\r\n        case \"backend-reload\":\r\n          await this.executeBackendReload(task);\r\n          break;\r\n        case \"ai-model-reload\":\r\n          await this.executeAIModelReload(task);\r\n          break;\r\n        case \"database-schema-update\":\r\n          await this.executeDatabaseSchemaUpdate(task);\r\n          break;\r\n        case \"plugin-reload\":\r\n          await this.executePluginReload(task);\r\n          break;\r\n        default:\r\n          throw new Error(`Unknown reload task type: ${task.type}`);\r\n      }\r\n\r\n      const duration = Date.now() - startTime;\r\n      console.log(`✅ ${task.type} completed in ${duration}ms`);\r\n    } catch (error) {\r\n      console.error(`❌ ${task.type} failed:`, error.message);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async executeTypeGeneration(task: ReloadTask): Promise<void> {\r\n    // Generate TypeScript types from backend models\r\n    await this.typeGenerator.generateFromModels();\r\n\r\n    // Notify frontend about type updates\r\n    this.emit(\"types-updated\", {\r\n      timestamp: Date.now(),\r\n      reason: task.metadata.reason,\r\n    });\r\n  }\r\n\r\n  private async executeFrontendHMR(task: ReloadTask): Promise<void> {\r\n    // Trigger Vite HMR update\r\n    await this.notifyViteHMR({\r\n      type: \"full-reload\",\r\n      reason: task.metadata.reason,\r\n      timestamp: Date.now(),\r\n    });\r\n  }\r\n\r\n  private async executeBackendReload(task: ReloadTask): Promise<void> {\r\n    // FastAPI auto-reload should handle most cases\r\n    // For complex changes, we might need to restart specific modules\r\n    await this.notifyBackendReload({\r\n      reason: task.metadata.reason,\r\n      timestamp: Date.now(),\r\n    });\r\n  }\r\n\r\n  private async executeAIModelReload(task: ReloadTask): Promise<void> {\r\n    // Hot swap AI models without service restart\r\n    await this.reloadAIModels(task.metadata.configFile);\r\n  }\r\n\r\n  private async buildDependencyGraph(): Promise<void> {\r\n    // Build graph of file dependencies across the stack\r\n    await this.dependencyGraph.build({\r\n      frontendSrc: \"apps/web/src\",\r\n      backendSrc: \"apps/api/src\",\r\n      configFiles: [\"farm.config.ts\", \"vite.config.ts\"],\r\n      typesDir: \"apps/web/src/types\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n### 2. Intelligent File Watcher\r\n\r\n**Advanced File Watching with Change Detection:**\r\n\r\n```typescript\r\n// packages/core/src/hot-reload/file-watcher.ts\r\nimport chokidar from \"chokidar\";\r\nimport { EventEmitter } from \"events\";\r\nimport path from \"path\";\r\nimport fs from \"fs-extra\";\r\n\r\nexport class FileWatcher extends EventEmitter {\r\n  private watchers: Map<string, chokidar.FSWatcher> = new Map();\r\n  private watchPaths: WatchPath[];\r\n  private ignorePatterns: string[];\r\n  private fileHashes: Map<string, string> = new Map();\r\n\r\n  constructor(watchPaths: WatchPath[]) {\r\n    super();\r\n    this.watchPaths = watchPaths;\r\n    this.ignorePatterns = [\r\n      \"**/node_modules/**\",\r\n      \"**/.git/**\",\r\n      \"**/dist/**\",\r\n      \"**/build/**\",\r\n      \"**/__pycache__/**\",\r\n      \"**/.pytest_cache/**\",\r\n      \"**/.*\",\r\n      \"**/*.log\",\r\n      \"**/*.tmp\",\r\n    ];\r\n  }\r\n\r\n  async start(): Promise<void> {\r\n    console.log(\"👁️  Starting file watchers...\");\r\n\r\n    for (const watchPath of this.watchPaths) {\r\n      await this.createWatcher(watchPath);\r\n    }\r\n\r\n    console.log(`✅ Watching ${this.watchPaths.length} paths`);\r\n  }\r\n\r\n  private async createWatcher(watchPath: WatchPath): Promise<void> {\r\n    const watcher = chokidar.watch(watchPath.pattern, {\r\n      ignored: [...this.ignorePatterns, ...(watchPath.ignore || [])],\r\n      persistent: true,\r\n      ignoreInitial: true,\r\n      followSymlinks: false,\r\n      usePolling: watchPath.usePolling || false,\r\n      interval: watchPath.interval || 1000,\r\n      binaryInterval: watchPath.binaryInterval || 300,\r\n      awaitWriteFinish: {\r\n        stabilityThreshold: 100,\r\n        pollInterval: 50,\r\n      },\r\n    });\r\n\r\n    // Setup event handlers\r\n    watcher.on(\"change\", async (filePath) => {\r\n      if (await this.shouldProcessChange(filePath)) {\r\n        this.emit(\"change\", this.normalizePath(filePath));\r\n      }\r\n    });\r\n\r\n    watcher.on(\"add\", (filePath) => {\r\n      this.emit(\"add\", this.normalizePath(filePath));\r\n    });\r\n\r\n    watcher.on(\"unlink\", (filePath) => {\r\n      this.fileHashes.delete(filePath);\r\n      this.emit(\"unlink\", this.normalizePath(filePath));\r\n    });\r\n\r\n    watcher.on(\"addDir\", (dirPath) => {\r\n      this.emit(\"addDir\", this.normalizePath(dirPath));\r\n    });\r\n\r\n    watcher.on(\"unlinkDir\", (dirPath) => {\r\n      this.emit(\"unlinkDir\", this.normalizePath(dirPath));\r\n    });\r\n\r\n    watcher.on(\"error\", (error) => {\r\n      console.error(`❌ File watcher error for ${watchPath.pattern}:`, error);\r\n      this.emit(\"error\", error);\r\n    });\r\n\r\n    this.watchers.set(watchPath.pattern, watcher);\r\n  }\r\n\r\n  private async shouldProcessChange(filePath: string): Promise<boolean> {\r\n    try {\r\n      // Check if file still exists\r\n      if (!(await fs.pathExists(filePath))) {\r\n        return false;\r\n      }\r\n\r\n      // Calculate file hash to detect actual changes\r\n      const content = await fs.readFile(filePath);\r\n      const hash = this.calculateHash(content);\r\n\r\n      const previousHash = this.fileHashes.get(filePath);\r\n      this.fileHashes.set(filePath, hash);\r\n\r\n      // Only process if content actually changed\r\n      return hash !== previousHash;\r\n    } catch (error) {\r\n      // If we can't read the file, assume it changed\r\n      return true;\r\n    }\r\n  }\r\n\r\n  private calculateHash(content: Buffer): string {\r\n    const crypto = require(\"crypto\");\r\n    return crypto.createHash(\"md5\").update(content).digest(\"hex\");\r\n  }\r\n\r\n  private normalizePath(filePath: string): string {\r\n    return path.resolve(filePath);\r\n  }\r\n\r\n  async stop(): Promise<void> {\r\n    console.log(\"⏹️  Stopping file watchers...\");\r\n\r\n    for (const [pattern, watcher] of this.watchers) {\r\n      await watcher.close();\r\n      console.log(`Stopped watching: ${pattern}`);\r\n    }\r\n\r\n    this.watchers.clear();\r\n    this.fileHashes.clear();\r\n  }\r\n\r\n  addWatchPath(watchPath: WatchPath): void {\r\n    this.watchPaths.push(watchPath);\r\n    if (this.watchers.size > 0) {\r\n      // Already started, add watcher immediately\r\n      this.createWatcher(watchPath);\r\n    }\r\n  }\r\n\r\n  removeWatchPath(pattern: string): void {\r\n    const watcher = this.watchers.get(pattern);\r\n    if (watcher) {\r\n      watcher.close();\r\n      this.watchers.delete(pattern);\r\n    }\r\n\r\n    this.watchPaths = this.watchPaths.filter((wp) => wp.pattern !== pattern);\r\n  }\r\n}\r\n\r\nexport interface WatchPath {\r\n  pattern: string;\r\n  ignore?: string[];\r\n  usePolling?: boolean;\r\n  interval?: number;\r\n  binaryInterval?: number;\r\n  description?: string;\r\n}\r\n```\r\n\r\n### 3. Change Analyzer\r\n\r\n**Intelligent Analysis of File Changes:**\r\n\r\n```typescript\r\n// packages/core/src/hot-reload/change-analyzer.ts\r\nimport path from \"path\";\r\nimport fs from \"fs-extra\";\r\nimport { parse } from \"@babel/parser\";\r\nimport traverse from \"@babel/traverse\";\r\n\r\nexport class ChangeAnalyzer {\r\n  async analyzeFileChange(filePath: string): Promise<FileChange> {\r\n    const extension = path.extname(filePath);\r\n    const relativePath = path.relative(process.cwd(), filePath);\r\n\r\n    // Determine change type based on file path and content\r\n    const changeType = this.determineChangeType(relativePath, extension);\r\n\r\n    // Analyze specific changes based on type\r\n    const details = await this.analyzeSpecificChanges(filePath, changeType);\r\n\r\n    return {\r\n      filePath: relativePath,\r\n      type: changeType,\r\n      timestamp: Date.now(),\r\n      details,\r\n    };\r\n  }\r\n\r\n  private determineChangeType(\r\n    relativePath: string,\r\n    extension: string\r\n  ): ChangeType {\r\n    // Backend Python files\r\n    if (relativePath.includes(\"apps/api/src/models/\") && extension === \".py\") {\r\n      return \"backend-model\";\r\n    }\r\n\r\n    if (relativePath.includes(\"apps/api/src/routes/\") && extension === \".py\") {\r\n      return \"backend-route\";\r\n    }\r\n\r\n    if (relativePath.includes(\"apps/api/src/\") && extension === \".py\") {\r\n      return \"backend-source\";\r\n    }\r\n\r\n    // Frontend files\r\n    if (\r\n      relativePath.includes(\"apps/web/src/\") &&\r\n      [\".tsx\", \".ts\", \".jsx\", \".js\"].includes(extension)\r\n    ) {\r\n      if (relativePath.includes(\"/components/\")) {\r\n        return \"frontend-component\";\r\n      }\r\n      if (relativePath.includes(\"/pages/\")) {\r\n        return \"frontend-page\";\r\n      }\r\n      if (relativePath.includes(\"/hooks/\")) {\r\n        return \"frontend-hook\";\r\n      }\r\n      return \"frontend-source\";\r\n    }\r\n\r\n    // Configuration files\r\n    if (\r\n      relativePath === \"farm.config.ts\" ||\r\n      relativePath === \"farm.config.js\"\r\n    ) {\r\n      return \"farm-config\";\r\n    }\r\n\r\n    if (relativePath === \"apps/web/vite.config.ts\") {\r\n      return \"vite-config\";\r\n    }\r\n\r\n    // AI-related files\r\n    if (relativePath.includes(\"apps/api/src/ai/\") && extension === \".py\") {\r\n      return \"ai-config\";\r\n    }\r\n\r\n    // Database migration files\r\n    if (\r\n      relativePath.includes(\"apps/api/migrations/\") &&\r\n      extension === \".json\"\r\n    ) {\r\n      return \"database-migration\";\r\n    }\r\n\r\n    // Plugin files\r\n    if (\r\n      relativePath.includes(\"/plugins/\") ||\r\n      relativePath.includes(\"@farm/plugin-\")\r\n    ) {\r\n      return \"plugin-config\";\r\n    }\r\n\r\n    // Style files\r\n    if ([\".css\", \".scss\", \".sass\", \".less\"].includes(extension)) {\r\n      return \"style\";\r\n    }\r\n\r\n    // Asset files\r\n    if ([\".png\", \".jpg\", \".jpeg\", \".gif\", \".svg\", \".ico\"].includes(extension)) {\r\n      return \"asset\";\r\n    }\r\n\r\n    return \"unknown\";\r\n  }\r\n\r\n  private async analyzeSpecificChanges(\r\n    filePath: string,\r\n    changeType: ChangeType\r\n  ): Promise<ChangeDetails> {\r\n    const details: ChangeDetails = {\r\n      affectedExports: [],\r\n      affectedImports: [],\r\n      hasStructuralChanges: false,\r\n    };\r\n\r\n    try {\r\n      switch (changeType) {\r\n        case \"backend-model\":\r\n          return await this.analyzePythonModelChanges(filePath);\r\n        case \"backend-route\":\r\n          return await this.analyzePythonRouteChanges(filePath);\r\n        case \"frontend-component\":\r\n          return await this.analyzeReactComponentChanges(filePath);\r\n        case \"farm-config\":\r\n          return await this.analyzeFarmConfigChanges(filePath);\r\n        default:\r\n          return details;\r\n      }\r\n    } catch (error) {\r\n      console.warn(`Could not analyze changes in ${filePath}:`, error.message);\r\n      return details;\r\n    }\r\n  }\r\n\r\n  private async analyzePythonModelChanges(\r\n    filePath: string\r\n  ): Promise<ChangeDetails> {\r\n    const content = await fs.readFile(filePath, \"utf-8\");\r\n\r\n    // Parse Python AST to detect model changes\r\n    // For now, simplified detection based on content analysis\r\n    const details: ChangeDetails = {\r\n      affectedExports: [],\r\n      affectedImports: [],\r\n      hasStructuralChanges: false,\r\n    };\r\n\r\n    // Detect Pydantic model classes\r\n    const modelClassRegex = /class\\s+(\\w+)\\s*\\([^)]*Document[^)]*\\):/g;\r\n    let match;\r\n\r\n    while ((match = modelClassRegex.exec(content)) !== null) {\r\n      details.affectedExports.push({\r\n        name: match[1],\r\n        type: \"class\",\r\n        isModel: true,\r\n      });\r\n    }\r\n\r\n    // Detect field changes\r\n    if (\r\n      content.includes(\"Field(\") ||\r\n      content.includes(\": str\") ||\r\n      content.includes(\": int\")\r\n    ) {\r\n      details.hasStructuralChanges = true;\r\n    }\r\n\r\n    return details;\r\n  }\r\n\r\n  private async analyzeReactComponentChanges(\r\n    filePath: string\r\n  ): Promise<ChangeDetails> {\r\n    const content = await fs.readFile(filePath, \"utf-8\");\r\n\r\n    const details: ChangeDetails = {\r\n      affectedExports: [],\r\n      affectedImports: [],\r\n      hasStructuralChanges: false,\r\n    };\r\n\r\n    try {\r\n      // Parse JavaScript/TypeScript AST\r\n      const ast = parse(content, {\r\n        sourceType: \"module\",\r\n        plugins: [\"typescript\", \"jsx\"],\r\n      });\r\n\r\n      // Analyze exports and imports\r\n      traverse(ast, {\r\n        ExportDefaultDeclaration(path) {\r\n          details.affectedExports.push({\r\n            name: \"default\",\r\n            type: \"component\",\r\n          });\r\n        },\r\n\r\n        ExportNamedDeclaration(path) {\r\n          if (path.node.declaration?.id?.name) {\r\n            details.affectedExports.push({\r\n              name: path.node.declaration.id.name,\r\n              type: \"function\",\r\n            });\r\n          }\r\n        },\r\n\r\n        ImportDeclaration(path) {\r\n          details.affectedImports.push({\r\n            source: path.node.source.value,\r\n            specifiers: path.node.specifiers.map((spec) => spec.local.name),\r\n          });\r\n        },\r\n      });\r\n\r\n      // Detect structural changes (hooks, props, etc.)\r\n      if (\r\n        content.includes(\"useState\") ||\r\n        content.includes(\"useEffect\") ||\r\n        content.includes(\"interface \") ||\r\n        content.includes(\"type \")\r\n      ) {\r\n        details.hasStructuralChanges = true;\r\n      }\r\n    } catch (error) {\r\n      console.warn(`Could not parse ${filePath}:`, error.message);\r\n    }\r\n\r\n    return details;\r\n  }\r\n\r\n  private async analyzeFarmConfigChanges(\r\n    filePath: string\r\n  ): Promise<ChangeDetails> {\r\n    // Farm config changes affect the entire system\r\n    return {\r\n      affectedExports: [],\r\n      affectedImports: [],\r\n      hasStructuralChanges: true,\r\n      configSections: await this.detectConfigSections(filePath),\r\n    };\r\n  }\r\n\r\n  private async detectConfigSections(filePath: string): Promise<string[]> {\r\n    const content = await fs.readFile(filePath, \"utf-8\");\r\n    const sections: string[] = [];\r\n\r\n    // Detect which config sections changed\r\n    if (content.includes(\"database:\")) sections.push(\"database\");\r\n    if (content.includes(\"ai:\")) sections.push(\"ai\");\r\n    if (content.includes(\"auth:\")) sections.push(\"auth\");\r\n    if (content.includes(\"plugins:\")) sections.push(\"plugins\");\r\n    if (content.includes(\"development:\")) sections.push(\"development\");\r\n\r\n    return sections;\r\n  }\r\n}\r\n```\r\n\r\n### 4. Type Generation Hot Reload\r\n\r\n**Seamless Type Updates:**\r\n\r\n```typescript\r\n// packages/core/src/hot-reload/type-hot-reload.ts\r\nimport { TypeGenerator } from \"../codegen/type-generator\";\r\nimport { EventEmitter } from \"events\";\r\n\r\nexport class TypeHotReload extends EventEmitter {\r\n  private typeGenerator: TypeGenerator;\r\n  private lastGenerationTime = 0;\r\n  private pendingGeneration = false;\r\n\r\n  constructor(typeGenerator: TypeGenerator) {\r\n    super();\r\n    this.typeGenerator = typeGenerator;\r\n  }\r\n\r\n  async handleModelChange(filePath: string): Promise<void> {\r\n    console.log(`🔄 Model changed: ${filePath}, regenerating types...`);\r\n\r\n    // Prevent multiple simultaneous generations\r\n    if (this.pendingGeneration) {\r\n      console.log(\"⏭️  Type generation already in progress, skipping...\");\r\n      return;\r\n    }\r\n\r\n    this.pendingGeneration = true;\r\n\r\n    try {\r\n      const startTime = Date.now();\r\n\r\n      // Generate TypeScript types from updated models\r\n      await this.typeGenerator.generateFromModels();\r\n\r\n      // Generate API client updates\r\n      await this.typeGenerator.generateApiClient();\r\n\r\n      // Generate React hooks\r\n      await this.typeGenerator.generateHooks();\r\n\r\n      const duration = Date.now() - startTime;\r\n      this.lastGenerationTime = Date.now();\r\n\r\n      console.log(`✅ Types regenerated in ${duration}ms`);\r\n\r\n      // Notify frontend about updated types\r\n      this.emit(\"types-updated\", {\r\n        timestamp: this.lastGenerationTime,\r\n        duration,\r\n        affectedFiles: await this.getGeneratedFiles(),\r\n      });\r\n\r\n      // Trigger frontend HMR\r\n      await this.triggerFrontendHMR();\r\n    } catch (error) {\r\n      console.error(\"❌ Type generation failed:\", error.message);\r\n      this.emit(\"type-generation-error\", error);\r\n    } finally {\r\n      this.pendingGeneration = false;\r\n    }\r\n  }\r\n\r\n  private async getGeneratedFiles(): Promise<string[]> {\r\n    // Return list of generated TypeScript files\r\n    return [\r\n      \"apps/web/src/types/api.ts\",\r\n      \"apps/web/src/types/models/index.ts\",\r\n      \"apps/web/src/services/api.ts\",\r\n      \"apps/web/src/hooks/api.ts\",\r\n    ];\r\n  }\r\n\r\n  private async triggerFrontendHMR(): Promise<void> {\r\n    // Send HMR update to Vite dev server\r\n    try {\r\n      await fetch(\"http://localhost:3000/__vite_hmr\", {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify({\r\n          type: \"full-reload\",\r\n          reason: \"types-updated\",\r\n        }),\r\n      });\r\n    } catch (error) {\r\n      console.warn(\"Could not trigger frontend HMR:\", error.message);\r\n    }\r\n  }\r\n\r\n  async handleConfigChange(configPath: string): Promise<void> {\r\n    console.log(`⚙️ Configuration changed: ${configPath}`);\r\n\r\n    // Reload type generator configuration\r\n    await this.typeGenerator.reloadConfig();\r\n\r\n    // Regenerate all types with new configuration\r\n    await this.handleModelChange(configPath);\r\n  }\r\n}\r\n```\r\n\r\n### 5. AI Model Hot Swapping\r\n\r\n**Hot Reload AI Models Without Service Restart:**\r\n\r\n```typescript\r\n// packages/core/src/hot-reload/ai-hot-reload.ts\r\nexport class AIHotReload extends EventEmitter {\r\n  private aiRouter: any; // Reference to AI router\r\n  private modelCache: Map<string, any> = new Map();\r\n\r\n  constructor(aiRouter: any) {\r\n    super();\r\n    this.aiRouter = aiRouter;\r\n  }\r\n\r\n  async handleAIConfigChange(configPath: string): Promise<void> {\r\n    console.log(`🤖 AI configuration changed: ${configPath}`);\r\n\r\n    try {\r\n      // Reload FARM configuration\r\n      const newConfig = await this.loadFarmConfig();\r\n      const aiConfig = newConfig.ai || {};\r\n\r\n      // Compare with current configuration\r\n      const changes = await this.detectAIConfigChanges(aiConfig);\r\n\r\n      // Apply changes\r\n      for (const change of changes) {\r\n        await this.applyAIConfigChange(change);\r\n      }\r\n\r\n      console.log(\r\n        `✅ AI configuration updated: ${changes.length} changes applied`\r\n      );\r\n    } catch (error) {\r\n      console.error(\"❌ AI config hot reload failed:\", error.message);\r\n      this.emit(\"ai-reload-error\", error);\r\n    }\r\n  }\r\n\r\n  private async detectAIConfigChanges(\r\n    newConfig: any\r\n  ): Promise<AIConfigChange[]> {\r\n    const changes: AIConfigChange[] = [];\r\n\r\n    // Check for new or removed providers\r\n    const currentProviders = Object.keys(this.aiRouter.providers || {});\r\n    const newProviders = Object.keys(newConfig.providers || {});\r\n\r\n    for (const provider of newProviders) {\r\n      if (!currentProviders.includes(provider)) {\r\n        changes.push({\r\n          type: \"provider-added\",\r\n          provider,\r\n          config: newConfig.providers[provider],\r\n        });\r\n      } else {\r\n        // Check for provider config changes\r\n        const configChanged = await this.hasProviderConfigChanged(\r\n          provider,\r\n          newConfig.providers[provider]\r\n        );\r\n\r\n        if (configChanged) {\r\n          changes.push({\r\n            type: \"provider-updated\",\r\n            provider,\r\n            config: newConfig.providers[provider],\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const provider of currentProviders) {\r\n      if (!newProviders.includes(provider)) {\r\n        changes.push({\r\n          type: \"provider-removed\",\r\n          provider,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Check for model changes within providers\r\n    for (const provider of newProviders) {\r\n      const providerConfig = newConfig.providers[provider];\r\n      const modelChanges = await this.detectModelChanges(\r\n        provider,\r\n        providerConfig\r\n      );\r\n      changes.push(...modelChanges);\r\n    }\r\n\r\n    return changes;\r\n  }\r\n\r\n  private async applyAIConfigChange(change: AIConfigChange): Promise<void> {\r\n    switch (change.type) {\r\n      case \"provider-added\":\r\n        await this.addAIProvider(change.provider, change.config);\r\n        break;\r\n\r\n      case \"provider-updated\":\r\n        await this.updateAIProvider(change.provider, change.config);\r\n        break;\r\n\r\n      case \"provider-removed\":\r\n        await this.removeAIProvider(change.provider);\r\n        break;\r\n\r\n      case \"model-added\":\r\n        await this.addModel(change.provider, change.model, change.config);\r\n        break;\r\n\r\n      case \"model-removed\":\r\n        await this.removeModel(change.provider, change.model);\r\n        break;\r\n\r\n      case \"model-updated\":\r\n        await this.updateModel(change.provider, change.model, change.config);\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async addModel(\r\n    provider: string,\r\n    modelName: string,\r\n    config: any\r\n  ): Promise<void> {\r\n    console.log(`📥 Adding model: ${provider}/${modelName}`);\r\n\r\n    if (provider === \"ollama\") {\r\n      // Pull Ollama model in background\r\n      await this.pullOllamaModel(modelName);\r\n    }\r\n\r\n    // Register model with provider\r\n    await this.aiRouter.registerModel(provider, modelName, config);\r\n\r\n    console.log(`✅ Model ${modelName} added to ${provider}`);\r\n  }\r\n\r\n  private async updateModel(\r\n    provider: string,\r\n    modelName: string,\r\n    config: any\r\n  ): Promise<void> {\r\n    console.log(`🔄 Updating model: ${provider}/${modelName}`);\r\n\r\n    // Hot swap model configuration\r\n    await this.aiRouter.updateModelConfig(provider, modelName, config);\r\n\r\n    console.log(`✅ Model ${modelName} configuration updated`);\r\n  }\r\n\r\n  private async removeModel(\r\n    provider: string,\r\n    modelName: string\r\n  ): Promise<void> {\r\n    console.log(`🗑️ Removing model: ${provider}/${modelName}`);\r\n\r\n    // Unload model from memory\r\n    await this.aiRouter.unloadModel(provider, modelName);\r\n\r\n    console.log(`✅ Model ${modelName} removed from ${provider}`);\r\n  }\r\n\r\n  private async pullOllamaModel(modelName: string): Promise<void> {\r\n    try {\r\n      console.log(`📥 Pulling Ollama model: ${modelName}...`);\r\n\r\n      const response = await fetch(\"http://localhost:11434/api/pull\", {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify({ name: modelName }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to pull model: ${response.statusText}`);\r\n      }\r\n\r\n      // Stream progress\r\n      const reader = response.body?.getReader();\r\n      if (reader) {\r\n        while (true) {\r\n          const { done, value } = await reader.read();\r\n          if (done) break;\r\n\r\n          const chunk = new TextDecoder().decode(value);\r\n          const lines = chunk.split(\"\\n\").filter((line) => line.trim());\r\n\r\n          for (const line of lines) {\r\n            try {\r\n              const data = JSON.parse(line);\r\n              if (data.status) {\r\n                console.log(`📦 ${data.status}`);\r\n              }\r\n            } catch (e) {\r\n              // Ignore malformed JSON\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      console.log(`✅ Ollama model ${modelName} pulled successfully`);\r\n    } catch (error) {\r\n      console.error(\r\n        `❌ Failed to pull Ollama model ${modelName}:`,\r\n        error.message\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 6. Database Schema Hot Updates\r\n\r\n**Live Schema Updates:**\r\n\r\n```typescript\r\n// packages/core/src/hot-reload/database-hot-reload.ts\r\nexport class DatabaseHotReload extends EventEmitter {\r\n  private databaseManager: any;\r\n  private migrationManager: any;\r\n\r\n  constructor(databaseManager: any, migrationManager: any) {\r\n    super();\r\n    this.databaseManager = databaseManager;\r\n    this.migrationManager = migrationManager;\r\n  }\r\n\r\n  async handleModelChange(modelFilePath: string): Promise<void> {\r\n    console.log(`🗄️ Database model changed: ${modelFilePath}`);\r\n\r\n    try {\r\n      // Analyze model changes\r\n      const changes = await this.analyzeModelChanges(modelFilePath);\r\n\r\n      if (changes.length === 0) {\r\n        console.log(\"📝 No schema changes detected\");\r\n        return;\r\n      }\r\n\r\n      // Create automatic migration for development\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        await this.createAutoMigration(changes);\r\n      }\r\n\r\n      // Update in-memory model definitions\r\n      await this.updateModelDefinitions(modelFilePath);\r\n\r\n      // Recreate indexes if needed\r\n      await this.updateIndexes(changes);\r\n\r\n      console.log(`✅ Database schema updated for ${modelFilePath}`);\r\n\r\n      // Notify type generator about schema changes\r\n      this.emit(\"schema-updated\", {\r\n        modelFile: modelFilePath,\r\n        changes,\r\n      });\r\n    } catch (error) {\r\n      console.error(\"❌ Database schema hot reload failed:\", error.message);\r\n      this.emit(\"schema-error\", error);\r\n    }\r\n  }\r\n\r\n  private async analyzeModelChanges(\r\n    modelFilePath: string\r\n  ): Promise<SchemaChange[]> {\r\n    const changes: SchemaChange[] = [];\r\n\r\n    // Read and parse the model file\r\n    const content = await fs.readFile(modelFilePath, \"utf-8\");\r\n\r\n    // Extract model class and field definitions\r\n    const modelInfo = this.parseModelDefinition(content);\r\n\r\n    // Compare with existing schema\r\n    const existingSchema = await this.getExistingSchema(modelInfo.className);\r\n\r\n    if (!existingSchema) {\r\n      // New model\r\n      changes.push({\r\n        type: \"create-collection\",\r\n        collection: modelInfo.collectionName,\r\n        schema: modelInfo.schema,\r\n      });\r\n    } else {\r\n      // Compare schemas to detect changes\r\n      const fieldChanges = this.compareSchemas(\r\n        existingSchema,\r\n        modelInfo.schema\r\n      );\r\n      changes.push(...fieldChanges);\r\n    }\r\n\r\n    return changes;\r\n  }\r\n\r\n  private parseModelDefinition(content: string): ModelInfo {\r\n    // Parse Python model definition\r\n    // For now, simplified regex-based parsing\r\n\r\n    const classMatch = content.match(/class\\s+(\\w+)\\s*\\([^)]*Document[^)]*\\):/);\r\n    const className = classMatch?.[1] || \"Unknown\";\r\n\r\n    // Extract collection name\r\n    const collectionMatch = content.match(/collection\\s*=\\s*[\"']([^\"']+)[\"']/);\r\n    const collectionName = collectionMatch?.[1] || className.toLowerCase();\r\n\r\n    // Extract fields\r\n    const fields = this.extractFields(content);\r\n\r\n    return {\r\n      className,\r\n      collectionName,\r\n      schema: { fields },\r\n    };\r\n  }\r\n\r\n  private extractFields(content: string): FieldDefinition[] {\r\n    const fields: FieldDefinition[] = [];\r\n\r\n    // Match field definitions like: field_name: FieldType = Field(...)\r\n    const fieldRegex = /(\\w+):\\s*([^=\\n]+)(?:\\s*=\\s*Field\\(([^)]*)\\))?/g;\r\n    let match;\r\n\r\n    while ((match = fieldRegex.exec(content)) !== null) {\r\n      const [, fieldName, fieldType, fieldOptions] = match;\r\n\r\n      fields.push({\r\n        name: fieldName,\r\n        type: fieldType.trim(),\r\n        options: fieldOptions ? this.parseFieldOptions(fieldOptions) : {},\r\n      });\r\n    }\r\n\r\n    return fields;\r\n  }\r\n\r\n  private async createAutoMigration(changes: SchemaChange[]): Promise<void> {\r\n    console.log(\"🔄 Creating automatic migration for development...\");\r\n\r\n    // Create migration with timestamp\r\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\r\n    const migrationId = `auto_${timestamp}`;\r\n\r\n    // Apply changes directly in development\r\n    for (const change of changes) {\r\n      await this.applySchemaChange(change);\r\n    }\r\n\r\n    console.log(\"✅ Automatic migration applied\");\r\n  }\r\n\r\n  private async applySchemaChange(change: SchemaChange): Promise<void> {\r\n    switch (change.type) {\r\n      case \"create-collection\":\r\n        await this.createCollection(change.collection, change.schema);\r\n        break;\r\n\r\n      case \"add-field\":\r\n        await this.addField(\r\n          change.collection,\r\n          change.field,\r\n          change.defaultValue\r\n        );\r\n        break;\r\n\r\n      case \"remove-field\":\r\n        await this.removeField(change.collection, change.field);\r\n        break;\r\n\r\n      case \"rename-field\":\r\n        await this.renameField(\r\n          change.collection,\r\n          change.oldName,\r\n          change.newName\r\n        );\r\n        break;\r\n\r\n      case \"create-index\":\r\n        await this.createIndex(change.collection, change.index);\r\n        break;\r\n\r\n      case \"drop-index\":\r\n        await this.dropIndex(change.collection, change.index);\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async createCollection(name: string, schema: any): Promise<void> {\r\n    // MongoDB collections are created automatically\r\n    // Just ensure the model is registered\r\n    console.log(\r\n      `📂 Collection ${name} will be created on first document insert`\r\n    );\r\n  }\r\n\r\n  private async addField(\r\n    collection: string,\r\n    field: string,\r\n    defaultValue: any\r\n  ): Promise<void> {\r\n    // Add field with default value to existing documents\r\n    const db = this.databaseManager.getDatabase();\r\n    await db\r\n      .collection(collection)\r\n      .updateMany(\r\n        { [field]: { $exists: false } },\r\n        { $set: { [field]: defaultValue } }\r\n      );\r\n\r\n    console.log(`➕ Added field ${field} to ${collection}`);\r\n  }\r\n\r\n  private async updateModelDefinitions(modelFilePath: string): Promise<void> {\r\n    // Clear Python module cache to reload updated model\r\n    const moduleName = this.getModuleName(modelFilePath);\r\n\r\n    // This would need to integrate with the Python runtime\r\n    // For now, we rely on FastAPI's auto-reload functionality\r\n    console.log(`🔄 Model definitions updated for ${moduleName}`);\r\n  }\r\n}\r\n```\r\n\r\n### 7. Plugin Hot Reload\r\n\r\n**Dynamic Plugin System Updates:**\r\n\r\n```typescript\r\n// packages/core/src/hot-reload/plugin-hot-reload.ts\r\nexport class PluginHotReload extends EventEmitter {\r\n  private pluginManager: any;\r\n  private activePlugins: Map<string, any> = new Map();\r\n\r\n  constructor(pluginManager: any) {\r\n    super();\r\n    this.pluginManager = pluginManager;\r\n  }\r\n\r\n  async handlePluginChange(pluginPath: string): Promise<void> {\r\n    console.log(`🔌 Plugin changed: ${pluginPath}`);\r\n\r\n    try {\r\n      const pluginName = this.extractPluginName(pluginPath);\r\n\r\n      if (this.activePlugins.has(pluginName)) {\r\n        // Hot reload existing plugin\r\n        await this.hotReloadPlugin(pluginName, pluginPath);\r\n      } else {\r\n        // New plugin detected\r\n        await this.loadNewPlugin(pluginName, pluginPath);\r\n      }\r\n\r\n      console.log(`✅ Plugin ${pluginName} hot reloaded`);\r\n    } catch (error) {\r\n      console.error(\"❌ Plugin hot reload failed:\", error.message);\r\n      this.emit(\"plugin-error\", error);\r\n    }\r\n  }\r\n\r\n  private async hotReloadPlugin(\r\n    pluginName: string,\r\n    pluginPath: string\r\n  ): Promise<void> {\r\n    console.log(`🔄 Hot reloading plugin: ${pluginName}`);\r\n\r\n    // Deactivate current plugin\r\n    await this.pluginManager.deactivatePlugin(pluginName);\r\n\r\n    // Clear require cache for the plugin\r\n    this.clearPluginCache(pluginPath);\r\n\r\n    // Reload plugin manifest\r\n    const newManifest = await this.loadPluginManifest(pluginPath);\r\n\r\n    // Update plugin registration\r\n    await this.pluginManager.updatePlugin(pluginName, newManifest);\r\n\r\n    // Reactivate plugin\r\n    await this.pluginManager.activatePlugin(pluginName);\r\n\r\n    // Update frontend if plugin has frontend components\r\n    if (newManifest.frontend) {\r\n      await this.updateFrontendPlugin(pluginName, newManifest.frontend);\r\n    }\r\n\r\n    // Update backend if plugin has backend integration\r\n    if (newManifest.backend) {\r\n      await this.updateBackendPlugin(pluginName, newManifest.backend);\r\n    }\r\n  }\r\n\r\n  private async updateFrontendPlugin(\r\n    pluginName: string,\r\n    frontendConfig: any\r\n  ): Promise<void> {\r\n    // Regenerate plugin component index\r\n    await this.regeneratePluginComponents();\r\n\r\n    // Trigger frontend HMR\r\n    await this.triggerFrontendHMR({\r\n      type: \"plugin-updated\",\r\n      plugin: pluginName,\r\n    });\r\n  }\r\n\r\n  private async updateBackendPlugin(\r\n    pluginName: string,\r\n    backendConfig: any\r\n  ): Promise<void> {\r\n    // Regenerate FastAPI integration\r\n    await this.regenerateBackendIntegration();\r\n\r\n    // The FastAPI auto-reload should pick up the changes\r\n    console.log(`🔄 Backend plugin integration updated for ${pluginName}`);\r\n  }\r\n\r\n  private clearPluginCache(pluginPath: string): void {\r\n    // Clear Node.js require cache\r\n    const pluginDir = path.dirname(pluginPath);\r\n\r\n    Object.keys(require.cache).forEach((key) => {\r\n      if (key.startsWith(pluginDir)) {\r\n        delete require.cache[key];\r\n      }\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Error Recovery System\r\n\r\n### 1. Graceful Error Handling\r\n\r\n**Robust Error Recovery:**\r\n\r\n```typescript\r\n// packages/core/src/hot-reload/error-recovery.ts\r\nexport class HotReloadErrorRecovery {\r\n  private retryAttempts: Map<string, number> = new Map();\r\n  private maxRetries = 3;\r\n  private cooldownPeriod = 5000; // 5 seconds\r\n\r\n  async handleReloadError(error: HotReloadError): Promise<void> {\r\n    console.error(`❌ Hot reload error in ${error.component}:`, error.message);\r\n\r\n    const retryKey = `${error.component}-${error.type}`;\r\n    const currentAttempts = this.retryAttempts.get(retryKey) || 0;\r\n\r\n    if (currentAttempts < this.maxRetries) {\r\n      console.log(\r\n        `🔄 Retrying ${error.component} hot reload (attempt ${\r\n          currentAttempts + 1\r\n        }/${this.maxRetries})`\r\n      );\r\n\r\n      // Increment retry count\r\n      this.retryAttempts.set(retryKey, currentAttempts + 1);\r\n\r\n      // Wait for cooldown\r\n      await this.wait(this.cooldownPeriod);\r\n\r\n      // Retry the operation\r\n      await this.retryReloadOperation(error);\r\n    } else {\r\n      console.error(\r\n        `❌ Hot reload failed after ${this.maxRetries} attempts, falling back to full restart`\r\n      );\r\n\r\n      // Clear retry count\r\n      this.retryAttempts.delete(retryKey);\r\n\r\n      // Fallback to full service restart\r\n      await this.fallbackToFullRestart(error.component);\r\n    }\r\n  }\r\n\r\n  private async retryReloadOperation(error: HotReloadError): Promise<void> {\r\n    switch (error.component) {\r\n      case \"type-generation\":\r\n        await this.retryTypeGeneration(error);\r\n        break;\r\n      case \"frontend-hmr\":\r\n        await this.retryFrontendHMR(error);\r\n        break;\r\n      case \"backend-reload\":\r\n        await this.retryBackendReload(error);\r\n        break;\r\n      case \"ai-models\":\r\n        await this.retryAIModelReload(error);\r\n        break;\r\n      default:\r\n        throw new Error(`Unknown component for retry: ${error.component}`);\r\n    }\r\n  }\r\n\r\n  private async fallbackToFullRestart(component: string): Promise<void> {\r\n    console.log(`🔄 Initiating full restart for ${component}...`);\r\n\r\n    switch (component) {\r\n      case \"frontend-hmr\":\r\n        await this.restartFrontendServer();\r\n        break;\r\n      case \"backend-reload\":\r\n        await this.restartBackendServer();\r\n        break;\r\n      case \"ai-models\":\r\n        await this.restartAIService();\r\n        break;\r\n      case \"type-generation\":\r\n        // Full type regeneration\r\n        await this.fullTypeRegeneration();\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async wait(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Performance Optimization\r\n\r\n### 1. Reload Performance Monitor\r\n\r\n**Optimize Hot Reload Performance:**\r\n\r\n```typescript\r\n// packages/core/src/hot-reload/performance-monitor.ts\r\nexport class HotReloadPerformanceMonitor {\r\n  private metrics: HotReloadMetric[] = [];\r\n  private slowReloadThreshold = 5000; // 5 seconds\r\n\r\n  recordReloadMetric(type: string, duration: number, success: boolean): void {\r\n    const metric: HotReloadMetric = {\r\n      type,\r\n      duration,\r\n      success,\r\n      timestamp: Date.now(),\r\n    };\r\n\r\n    this.metrics.push(metric);\r\n\r\n    // Keep only last 100 metrics\r\n    if (this.metrics.length > 100) {\r\n      this.metrics = this.metrics.slice(-100);\r\n    }\r\n\r\n    // Log slow reloads\r\n    if (duration > this.slowReloadThreshold) {\r\n      console.warn(`⚠️ Slow hot reload detected: ${type} took ${duration}ms`);\r\n    }\r\n  }\r\n\r\n  getPerformanceReport(): HotReloadReport {\r\n    const last24h = this.metrics.filter(\r\n      (m) => Date.now() - m.timestamp < 24 * 60 * 60 * 1000\r\n    );\r\n\r\n    const successful = last24h.filter((m) => m.success);\r\n    const failed = last24h.filter((m) => !m.success);\r\n\r\n    const avgDuration =\r\n      successful.length > 0\r\n        ? successful.reduce((sum, m) => sum + m.duration, 0) / successful.length\r\n        : 0;\r\n\r\n    const slowReloads = successful.filter(\r\n      (m) => m.duration > this.slowReloadThreshold\r\n    );\r\n\r\n    return {\r\n      totalReloads: last24h.length,\r\n      successfulReloads: successful.length,\r\n      failedReloads: failed.length,\r\n      averageDuration: Math.round(avgDuration),\r\n      slowReloads: slowReloads.length,\r\n      successRate:\r\n        last24h.length > 0 ? (successful.length / last24h.length) * 100 : 0,\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Development Server Integration\r\n\r\n### 1. Hot Reload Service\r\n\r\n**Integration with Development Server:**\r\n\r\n```typescript\r\n// packages/core/src/hot-reload/service.ts\r\nexport class HotReloadService {\r\n  private coordinator: HotReloadCoordinator;\r\n  private performanceMonitor: HotReloadPerformanceMonitor;\r\n  private errorRecovery: HotReloadErrorRecovery;\r\n  private isEnabled = true;\r\n\r\n  constructor(config: HotReloadConfig) {\r\n    this.coordinator = new HotReloadCoordinator(config);\r\n    this.performanceMonitor = new HotReloadPerformanceMonitor();\r\n    this.errorRecovery = new HotReloadErrorRecovery();\r\n\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  async start(): Promise<void> {\r\n    if (!this.isEnabled) {\r\n      console.log(\"🔥 Hot reload is disabled\");\r\n      return;\r\n    }\r\n\r\n    console.log(\"🔥 Starting hot reload service...\");\r\n\r\n    await this.coordinator.initialize();\r\n\r\n    console.log(\"✅ Hot reload service started\");\r\n  }\r\n\r\n  async stop(): Promise<void> {\r\n    console.log(\"⏹️ Stopping hot reload service...\");\r\n\r\n    await this.coordinator.shutdown();\r\n\r\n    console.log(\"✅ Hot reload service stopped\");\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    this.coordinator.on(\"reload-complete\", (event) => {\r\n      this.performanceMonitor.recordReloadMetric(\r\n        event.type,\r\n        event.duration,\r\n        true\r\n      );\r\n    });\r\n\r\n    this.coordinator.on(\"reload-error\", async (error) => {\r\n      this.performanceMonitor.recordReloadMetric(\r\n        error.component,\r\n        error.duration || 0,\r\n        false\r\n      );\r\n\r\n      await this.errorRecovery.handleReloadError(error);\r\n    });\r\n  }\r\n\r\n  getStatus(): HotReloadStatus {\r\n    return {\r\n      enabled: this.isEnabled,\r\n      isProcessing: this.coordinator.isProcessing,\r\n      queueLength: this.coordinator.getQueueLength(),\r\n      performance: this.performanceMonitor.getPerformanceReport(),\r\n    };\r\n  }\r\n\r\n  enable(): void {\r\n    this.isEnabled = true;\r\n    console.log(\"🔥 Hot reload enabled\");\r\n  }\r\n\r\n  disable(): void {\r\n    this.isEnabled = false;\r\n    console.log(\"⏸️ Hot reload disabled\");\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Configuration Integration\r\n\r\n### 1. Hot Reload Configuration\r\n\r\n**TypeScript Configuration:**\r\n\r\n```typescript\r\n// farm.config.ts - Hot reload configuration\r\nexport default defineConfig({\r\n  development: {\r\n    hotReload: {\r\n      enabled: true,\r\n\r\n      // File watching configuration\r\n      watch: {\r\n        debounceMs: 100,\r\n        usePolling: false,\r\n        interval: 1000,\r\n        paths: [\r\n          {\r\n            pattern: \"apps/web/src/**/*\",\r\n            ignore: [\"**/*.test.*\", \"**/node_modules/**\"],\r\n          },\r\n          {\r\n            pattern: \"apps/api/src/**/*.py\",\r\n            ignore: [\"**/__pycache__/**\", \"**/test_*.py\"],\r\n          },\r\n          {\r\n            pattern: \"farm.config.ts\",\r\n          },\r\n        ],\r\n      },\r\n\r\n      // Type generation settings\r\n      typeGeneration: {\r\n        enabled: true,\r\n        debounceMs: 500,\r\n        generateOnModelChange: true,\r\n        generateOnRouteChange: true,\r\n      },\r\n\r\n      // AI model hot swapping\r\n      aiModels: {\r\n        enabled: true,\r\n        hotSwap: true,\r\n        preloadModels: true,\r\n      },\r\n\r\n      // Performance settings\r\n      performance: {\r\n        slowReloadThreshold: 5000,\r\n        maxRetries: 3,\r\n        cooldownPeriod: 5000,\r\n      },\r\n\r\n      // Error handling\r\n      errorRecovery: {\r\n        enabled: true,\r\n        fallbackToRestart: true,\r\n        logErrors: true,\r\n      },\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n---\r\n\r\n_Status: ✅ Completed - Ready for implementation_\r\n\r\nThis hot reload system provides:\r\n\r\n- **Intelligent cross-stack reloading** across React, FastAPI, database, and AI systems\r\n- **Dependency-aware updates** that minimize unnecessary reloads\r\n- **Type generation hot reload** for seamless frontend-backend synchronization\r\n- **AI model hot swapping** without service restarts\r\n- **Database schema live updates** for development workflow\r\n- **Plugin system hot reload** for dynamic plugin development\r\n- **Comprehensive error recovery** with retry mechanisms and fallbacks\r\n- **Performance monitoring** and optimization\r\n- **Development server integration** with the existing architecture\r\n",
      "excerpt": "The FARM hot reload system provides intelligent, cross-stack hot reloading that coordinates updates across React frontend, FastAPI backend, database schemas, AI...",
      "category": "architectural-sketches-detailed/phase2",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.781Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase2",
        "Hot_reload_system_design"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Hot Reload System Design",
          "id": "hot-reload-system-design"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "High-Level Hot Reload Architecture",
          "id": "high-level-hot-reload-architecture"
        },
        {
          "level": 2,
          "text": "Core Hot Reload Components",
          "id": "core-hot-reload-components"
        },
        {
          "level": 3,
          "text": "1. Hot Reload Coordinator",
          "id": "1-hot-reload-coordinator"
        },
        {
          "level": 3,
          "text": "2. Intelligent File Watcher",
          "id": "2-intelligent-file-watcher"
        },
        {
          "level": 3,
          "text": "3. Change Analyzer",
          "id": "3-change-analyzer"
        },
        {
          "level": 3,
          "text": "4. Type Generation Hot Reload",
          "id": "4-type-generation-hot-reload"
        },
        {
          "level": 3,
          "text": "5. AI Model Hot Swapping",
          "id": "5-ai-model-hot-swapping"
        },
        {
          "level": 3,
          "text": "6. Database Schema Hot Updates",
          "id": "6-database-schema-hot-updates"
        },
        {
          "level": 3,
          "text": "7. Plugin Hot Reload",
          "id": "7-plugin-hot-reload"
        },
        {
          "level": 2,
          "text": "Error Recovery System",
          "id": "error-recovery-system"
        },
        {
          "level": 3,
          "text": "1. Graceful Error Handling",
          "id": "1-graceful-error-handling"
        },
        {
          "level": 2,
          "text": "Performance Optimization",
          "id": "performance-optimization"
        },
        {
          "level": 3,
          "text": "1. Reload Performance Monitor",
          "id": "1-reload-performance-monitor"
        },
        {
          "level": 2,
          "text": "Development Server Integration",
          "id": "development-server-integration"
        },
        {
          "level": 3,
          "text": "1. Hot Reload Service",
          "id": "1-hot-reload-service"
        },
        {
          "level": 2,
          "text": "Configuration Integration",
          "id": "configuration-integration"
        },
        {
          "level": 3,
          "text": "1. Hot Reload Configuration",
          "id": "1-hot-reload-configuration"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase2-plugin_system_architecture",
      "title": "Plugin_system_architecture",
      "url": "/architectural-sketches-detailed/phase2/plugin_system_architecture",
      "content": "# Plugin System Architecture\r\n\r\n## Overview\r\n\r\nThe FARM plugin system provides a powerful, type-safe, and AI-aware extension mechanism that allows developers to extend framework functionality through declarative plugins. It supports both official and community plugins, with automatic dependency resolution, hot-reload capabilities, and seamless integration with the AI provider system.\r\n\r\n---\r\n\r\n## High-Level Plugin Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Plugin Ecosystem                       │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │   Plugin    │  │   Plugin    │  │ Community   │  │ Custom  │ │\r\n│  │ Registry    │  │ Manager     │  │   Store     │  │ Plugins │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Dependency  │  │   Hook      │  │    API      │  │ Config  │ │\r\n│  │ Resolution  │  │   System    │  │ Extension   │  │Injection│ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Frontend    │  │ Backend     │  │     AI      │  │Database │ │\r\n│  │Integration  │  │Integration  │  │ Integration │  │ Plugins │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Plugin Architecture\r\n\r\n### 1. Plugin Definition Interface\r\n\r\n**Type-Safe Plugin Contracts:**\r\n\r\n```typescript\r\n// packages/types/src/plugins.ts\r\nexport interface FarmPlugin {\r\n  // Plugin metadata\r\n  name: string;\r\n  version: string;\r\n  description: string;\r\n  author: string;\r\n  license: string;\r\n\r\n  // Framework compatibility\r\n  farmVersion: string;\r\n  nodeVersion?: string;\r\n  pythonVersion?: string;\r\n\r\n  // Plugin configuration\r\n  configSchema?: PluginConfigSchema;\r\n  defaultConfig?: Record<string, any>;\r\n\r\n  // Lifecycle hooks\r\n  onInstall?: (context: PluginContext) => Promise<void>;\r\n  onActivate?: (context: PluginContext) => Promise<void>;\r\n  onDeactivate?: (context: PluginContext) => Promise<void>;\r\n  onUninstall?: (context: PluginContext) => Promise<void>;\r\n\r\n  // Integration points\r\n  frontend?: FrontendIntegration;\r\n  backend?: BackendIntegration;\r\n  ai?: AIIntegration;\r\n  database?: DatabaseIntegration;\r\n\r\n  // Dependencies\r\n  dependencies?: PluginDependency[];\r\n  peerDependencies?: PluginDependency[];\r\n  conflicts?: string[];\r\n}\r\n\r\nexport interface PluginContext {\r\n  config: FarmConfig;\r\n  pluginConfig: Record<string, any>;\r\n  farmVersion: string;\r\n  environment: \"development\" | \"staging\" | \"production\";\r\n  logger: Logger;\r\n  services: ServiceRegistry;\r\n}\r\n\r\nexport interface PluginDependency {\r\n  name: string;\r\n  version: string;\r\n  optional?: boolean;\r\n  reason?: string;\r\n}\r\n```\r\n\r\n### 2. Plugin Integration Interfaces\r\n\r\n**Frontend Integration:**\r\n\r\n```typescript\r\nexport interface FrontendIntegration {\r\n  // React components to register\r\n  components?: {\r\n    [componentName: string]: {\r\n      path: string;\r\n      props?: ComponentPropsSchema;\r\n      async?: boolean;\r\n    };\r\n  };\r\n\r\n  // Custom hooks to provide\r\n  hooks?: {\r\n    [hookName: string]: {\r\n      path: string;\r\n      dependencies?: string[];\r\n    };\r\n  };\r\n\r\n  // Route definitions\r\n  routes?: RouteDefinition[];\r\n\r\n  // Global CSS/styling\r\n  styles?: string[];\r\n\r\n  // Vite plugin extensions\r\n  vitePlugins?: VitePluginConfig[];\r\n\r\n  // Package dependencies\r\n  dependencies?: PackageDependency[];\r\n}\r\n\r\nexport interface BackendIntegration {\r\n  // FastAPI router registration\r\n  routers?: {\r\n    [routerName: string]: {\r\n      path: string;\r\n      prefix: string;\r\n      tags?: string[];\r\n      middleware?: string[];\r\n    };\r\n  };\r\n\r\n  // Middleware registration\r\n  middleware?: {\r\n    [middlewareName: string]: {\r\n      path: string;\r\n      order: number;\r\n      conditions?: MiddlewareCondition[];\r\n    };\r\n  };\r\n\r\n  // Background tasks\r\n  tasks?: {\r\n    [taskName: string]: {\r\n      path: string;\r\n      schedule?: string;\r\n      queue?: string;\r\n    };\r\n  };\r\n\r\n  // Database models\r\n  models?: {\r\n    [modelName: string]: {\r\n      path: string;\r\n      collection?: string;\r\n      indexes?: IndexDefinition[];\r\n    };\r\n  };\r\n\r\n  // Python package dependencies\r\n  dependencies?: PythonDependency[];\r\n}\r\n\r\nexport interface AIIntegration {\r\n  // Custom AI providers\r\n  providers?: {\r\n    [providerName: string]: {\r\n      path: string;\r\n      models: string[];\r\n      capabilities: AICapability[];\r\n    };\r\n  };\r\n\r\n  // Model definitions\r\n  models?: {\r\n    [modelName: string]: {\r\n      provider: string;\r\n      config: ModelConfig;\r\n      requirements: ModelRequirements;\r\n    };\r\n  };\r\n\r\n  // Preprocessing pipelines\r\n  pipelines?: {\r\n    [pipelineName: string]: {\r\n      path: string;\r\n      inputTypes: string[];\r\n      outputTypes: string[];\r\n    };\r\n  };\r\n\r\n  // Custom inference endpoints\r\n  endpoints?: {\r\n    [endpointName: string]: {\r\n      path: string;\r\n      method: HTTPMethod;\r\n      streaming?: boolean;\r\n    };\r\n  };\r\n}\r\n```\r\n\r\n---\r\n\r\n## Plugin Management System\r\n\r\n### 1. Plugin Manager Core\r\n\r\n**Central Plugin Orchestration:**\r\n\r\n```typescript\r\n// packages/core/src/plugins/manager.ts\r\nexport class PluginManager {\r\n  private plugins = new Map<string, PluginInstance>();\r\n  private registry: PluginRegistry;\r\n  private dependencyResolver: DependencyResolver;\r\n  private configManager: ConfigManager;\r\n\r\n  constructor(farmConfig: FarmConfig) {\r\n    this.registry = new PluginRegistry();\r\n    this.dependencyResolver = new DependencyResolver();\r\n    this.configManager = new ConfigManager(farmConfig);\r\n  }\r\n\r\n  async initialize() {\r\n    await this.registry.initialize();\r\n    await this.loadConfiguredPlugins();\r\n    await this.resolveDependencies();\r\n    await this.activatePlugins();\r\n  }\r\n\r\n  async installPlugin(\r\n    pluginIdentifier: string,\r\n    options: InstallOptions = {}\r\n  ): Promise<PluginInstance> {\r\n    try {\r\n      // Resolve plugin source (npm, git, local)\r\n      const pluginSource = await this.resolvePluginSource(pluginIdentifier);\r\n\r\n      // Download and validate plugin\r\n      const pluginManifest = await this.downloadPlugin(pluginSource);\r\n      this.validatePlugin(pluginManifest);\r\n\r\n      // Check dependencies\r\n      await this.dependencyResolver.resolve(pluginManifest.dependencies);\r\n\r\n      // Install plugin\r\n      const plugin = await this.createPluginInstance(pluginManifest);\r\n      await plugin.install();\r\n\r\n      // Register plugin\r\n      this.plugins.set(plugin.name, plugin);\r\n\r\n      // Update configuration\r\n      await this.configManager.addPlugin(plugin.name, options.config);\r\n\r\n      // Activate if not disabled\r\n      if (!options.disabled) {\r\n        await plugin.activate();\r\n      }\r\n\r\n      this.logger.info(`✅ Plugin ${plugin.name} installed successfully`);\r\n      return plugin;\r\n    } catch (error) {\r\n      this.logger.error(\r\n        `❌ Failed to install plugin ${pluginIdentifier}:`,\r\n        error\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async uninstallPlugin(pluginName: string): Promise<void> {\r\n    const plugin = this.plugins.get(pluginName);\r\n    if (!plugin) {\r\n      throw new Error(`Plugin ${pluginName} not found`);\r\n    }\r\n\r\n    // Check for dependent plugins\r\n    const dependents = this.findDependentPlugins(pluginName);\r\n    if (dependents.length > 0) {\r\n      throw new Error(\r\n        `Cannot uninstall ${pluginName}. The following plugins depend on it: ${dependents.join(\r\n          \", \"\r\n        )}`\r\n      );\r\n    }\r\n\r\n    // Deactivate and uninstall\r\n    await plugin.deactivate();\r\n    await plugin.uninstall();\r\n\r\n    // Remove from registry\r\n    this.plugins.delete(pluginName);\r\n    await this.configManager.removePlugin(pluginName);\r\n\r\n    this.logger.info(`✅ Plugin ${pluginName} uninstalled successfully`);\r\n  }\r\n\r\n  async activatePlugin(pluginName: string): Promise<void> {\r\n    const plugin = this.plugins.get(pluginName);\r\n    if (!plugin) {\r\n      throw new Error(`Plugin ${pluginName} not found`);\r\n    }\r\n\r\n    await plugin.activate();\r\n    this.logger.info(`✅ Plugin ${pluginName} activated`);\r\n  }\r\n\r\n  async deactivatePlugin(pluginName: string): Promise<void> {\r\n    const plugin = this.plugins.get(pluginName);\r\n    if (!plugin) {\r\n      throw new Error(`Plugin ${pluginName} not found`);\r\n    }\r\n\r\n    await plugin.deactivate();\r\n    this.logger.info(`⏸️ Plugin ${pluginName} deactivated`);\r\n  }\r\n\r\n  async reloadPlugin(pluginName: string): Promise<void> {\r\n    const plugin = this.plugins.get(pluginName);\r\n    if (!plugin) {\r\n      throw new Error(`Plugin ${pluginName} not found`);\r\n    }\r\n\r\n    await plugin.deactivate();\r\n    await this.reloadPluginDefinition(plugin);\r\n    await plugin.activate();\r\n\r\n    this.logger.info(`🔄 Plugin ${pluginName} reloaded`);\r\n  }\r\n\r\n  getPlugin(pluginName: string): PluginInstance | undefined {\r\n    return this.plugins.get(pluginName);\r\n  }\r\n\r\n  getActivePlugins(): PluginInstance[] {\r\n    return Array.from(this.plugins.values()).filter((p) => p.isActive);\r\n  }\r\n\r\n  async getAvailablePlugins(): Promise<PluginListing[]> {\r\n    return await this.registry.search();\r\n  }\r\n}\r\n```\r\n\r\n### 2. Plugin Instance Implementation\r\n\r\n**Individual Plugin Lifecycle Management:**\r\n\r\n```typescript\r\n// packages/core/src/plugins/instance.ts\r\nexport class PluginInstance {\r\n  public readonly manifest: FarmPlugin;\r\n  public readonly config: Record<string, any>;\r\n  public isInstalled = false;\r\n  public isActive = false;\r\n\r\n  private frontendIntegrator?: FrontendIntegrator;\r\n  private backendIntegrator?: BackendIntegrator;\r\n  private aiIntegrator?: AIIntegrator;\r\n  private context: PluginContext;\r\n\r\n  constructor(manifest: FarmPlugin, config: Record<string, any>) {\r\n    this.manifest = manifest;\r\n    this.config = config;\r\n    this.context = this.createContext();\r\n  }\r\n\r\n  async install(): Promise<void> {\r\n    if (this.isInstalled) {\r\n      throw new Error(`Plugin ${this.manifest.name} is already installed`);\r\n    }\r\n\r\n    try {\r\n      // Install dependencies\r\n      await this.installDependencies();\r\n\r\n      // Run install hook\r\n      if (this.manifest.onInstall) {\r\n        await this.manifest.onInstall(this.context);\r\n      }\r\n\r\n      // Setup integrations\r\n      await this.setupIntegrations();\r\n\r\n      this.isInstalled = true;\r\n    } catch (error) {\r\n      await this.cleanup();\r\n      throw new Error(\r\n        `Failed to install plugin ${this.manifest.name}: ${error.message}`\r\n      );\r\n    }\r\n  }\r\n\r\n  async activate(): Promise<void> {\r\n    if (!this.isInstalled) {\r\n      throw new Error(\r\n        `Plugin ${this.manifest.name} must be installed before activation`\r\n      );\r\n    }\r\n\r\n    if (this.isActive) {\r\n      return; // Already active\r\n    }\r\n\r\n    try {\r\n      // Activate integrations\r\n      await this.activateIntegrations();\r\n\r\n      // Run activation hook\r\n      if (this.manifest.onActivate) {\r\n        await this.manifest.onActivate(this.context);\r\n      }\r\n\r\n      this.isActive = true;\r\n    } catch (error) {\r\n      await this.deactivateIntegrations();\r\n      throw new Error(\r\n        `Failed to activate plugin ${this.manifest.name}: ${error.message}`\r\n      );\r\n    }\r\n  }\r\n\r\n  async deactivate(): Promise<void> {\r\n    if (!this.isActive) {\r\n      return; // Already inactive\r\n    }\r\n\r\n    try {\r\n      // Run deactivation hook\r\n      if (this.manifest.onDeactivate) {\r\n        await this.manifest.onDeactivate(this.context);\r\n      }\r\n\r\n      // Deactivate integrations\r\n      await this.deactivateIntegrations();\r\n\r\n      this.isActive = false;\r\n    } catch (error) {\r\n      this.logger.error(\r\n        `Error during deactivation of ${this.manifest.name}:`,\r\n        error\r\n      );\r\n      // Continue anyway to ensure deactivation\r\n      this.isActive = false;\r\n    }\r\n  }\r\n\r\n  async uninstall(): Promise<void> {\r\n    if (this.isActive) {\r\n      await this.deactivate();\r\n    }\r\n\r\n    try {\r\n      // Run uninstall hook\r\n      if (this.manifest.onUninstall) {\r\n        await this.manifest.onUninstall(this.context);\r\n      }\r\n\r\n      // Cleanup integrations\r\n      await this.cleanupIntegrations();\r\n\r\n      // Uninstall dependencies\r\n      await this.uninstallDependencies();\r\n\r\n      this.isInstalled = false;\r\n    } catch (error) {\r\n      this.logger.error(\r\n        `Error during uninstallation of ${this.manifest.name}:`,\r\n        error\r\n      );\r\n      // Mark as uninstalled anyway\r\n      this.isInstalled = false;\r\n    }\r\n  }\r\n\r\n  private async setupIntegrations(): Promise<void> {\r\n    if (this.manifest.frontend) {\r\n      this.frontendIntegrator = new FrontendIntegrator(\r\n        this.manifest.frontend,\r\n        this.context\r\n      );\r\n      await this.frontendIntegrator.setup();\r\n    }\r\n\r\n    if (this.manifest.backend) {\r\n      this.backendIntegrator = new BackendIntegrator(\r\n        this.manifest.backend,\r\n        this.context\r\n      );\r\n      await this.backendIntegrator.setup();\r\n    }\r\n\r\n    if (this.manifest.ai) {\r\n      this.aiIntegrator = new AIIntegrator(this.manifest.ai, this.context);\r\n      await this.aiIntegrator.setup();\r\n    }\r\n  }\r\n\r\n  private async activateIntegrations(): Promise<void> {\r\n    const activations = [];\r\n\r\n    if (this.frontendIntegrator) {\r\n      activations.push(this.frontendIntegrator.activate());\r\n    }\r\n\r\n    if (this.backendIntegrator) {\r\n      activations.push(this.backendIntegrator.activate());\r\n    }\r\n\r\n    if (this.aiIntegrator) {\r\n      activations.push(this.aiIntegrator.activate());\r\n    }\r\n\r\n    await Promise.all(activations);\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Frontend Integration System\r\n\r\n### 1. Frontend Integrator\r\n\r\n**React Component and Hook Registration:**\r\n\r\n```typescript\r\n// packages/core/src/plugins/integrators/frontend.ts\r\nexport class FrontendIntegrator {\r\n  private integration: FrontendIntegration;\r\n  private context: PluginContext;\r\n  private registeredComponents = new Map<string, ComponentRegistration>();\r\n  private registeredHooks = new Map<string, HookRegistration>();\r\n\r\n  constructor(integration: FrontendIntegration, context: PluginContext) {\r\n    this.integration = integration;\r\n    this.context = context;\r\n  }\r\n\r\n  async setup(): Promise<void> {\r\n    // Validate component exports\r\n    await this.validateComponents();\r\n\r\n    // Validate hook exports\r\n    await this.validateHooks();\r\n\r\n    // Install npm dependencies\r\n    await this.installFrontendDependencies();\r\n\r\n    // Setup Vite plugins\r\n    await this.setupVitePlugins();\r\n  }\r\n\r\n  async activate(): Promise<void> {\r\n    // Register components\r\n    await this.registerComponents();\r\n\r\n    // Register hooks\r\n    await this.registerHooks();\r\n\r\n    // Setup routes\r\n    await this.setupRoutes();\r\n\r\n    // Apply styles\r\n    await this.applyStyles();\r\n\r\n    // Trigger frontend rebuild\r\n    await this.triggerFrontendRebuild();\r\n  }\r\n\r\n  async deactivate(): Promise<void> {\r\n    // Unregister components\r\n    this.unregisterComponents();\r\n\r\n    // Unregister hooks\r\n    this.unregisterHooks();\r\n\r\n    // Remove routes\r\n    this.removeRoutes();\r\n\r\n    // Remove styles\r\n    this.removeStyles();\r\n\r\n    // Trigger frontend rebuild\r\n    await this.triggerFrontendRebuild();\r\n  }\r\n\r\n  private async registerComponents(): Promise<void> {\r\n    if (!this.integration.components) return;\r\n\r\n    for (const [name, component] of Object.entries(\r\n      this.integration.components\r\n    )) {\r\n      const registration: ComponentRegistration = {\r\n        name,\r\n        path: component.path,\r\n        props: component.props,\r\n        async: component.async || false,\r\n        plugin: this.context.plugin.name,\r\n      };\r\n\r\n      // Validate component exists and exports correctly\r\n      await this.validateComponentExport(registration);\r\n\r\n      // Register with component registry\r\n      ComponentRegistry.register(registration);\r\n\r\n      this.registeredComponents.set(name, registration);\r\n    }\r\n  }\r\n\r\n  private async registerHooks(): Promise<void> {\r\n    if (!this.integration.hooks) return;\r\n\r\n    for (const [name, hook] of Object.entries(this.integration.hooks)) {\r\n      const registration: HookRegistration = {\r\n        name,\r\n        path: hook.path,\r\n        dependencies: hook.dependencies || [],\r\n        plugin: this.context.plugin.name,\r\n      };\r\n\r\n      // Validate hook exists and exports correctly\r\n      await this.validateHookExport(registration);\r\n\r\n      // Register with hook registry\r\n      HookRegistry.register(registration);\r\n\r\n      this.registeredHooks.set(name, registration);\r\n    }\r\n  }\r\n\r\n  private async triggerFrontendRebuild(): Promise<void> {\r\n    // Generate component index file\r\n    await this.generateComponentIndex();\r\n\r\n    // Generate hook index file\r\n    await this.generateHookIndex();\r\n\r\n    // Generate route definitions\r\n    await this.generateRoutes();\r\n\r\n    // Trigger Vite HMR update\r\n    await this.triggerViteHMR();\r\n  }\r\n\r\n  private async generateComponentIndex(): Promise<void> {\r\n    const components = ComponentRegistry.getAll();\r\n\r\n    const indexContent = `\r\n// Auto-generated plugin component index\r\n// Do not edit this file manually\r\n\r\n${components\r\n  .map(\r\n    (comp) => `\r\nexport { default as ${comp.name} } from '${comp.path}';\r\n`\r\n  )\r\n  .join(\"\")}\r\n\r\nexport const PluginComponents = {\r\n${components.map((comp) => `  ${comp.name},`).join(\"\\n\")}\r\n};\r\n`;\r\n\r\n    await fs.writeFile(\r\n      path.join(this.context.paths.frontend, \"src/plugins/components/index.ts\"),\r\n      indexContent\r\n    );\r\n  }\r\n\r\n  private async generateHookIndex(): Promise<void> {\r\n    const hooks = HookRegistry.getAll();\r\n\r\n    const indexContent = `\r\n// Auto-generated plugin hook index\r\n// Do not edit this file manually\r\n\r\n${hooks\r\n  .map(\r\n    (hook) => `\r\nexport { ${hook.name} } from '${hook.path}';\r\n`\r\n  )\r\n  .join(\"\")}\r\n\r\nexport const PluginHooks = {\r\n${hooks.map((hook) => `  ${hook.name},`).join(\"\\n\")}\r\n};\r\n`;\r\n\r\n    await fs.writeFile(\r\n      path.join(this.context.paths.frontend, \"src/plugins/hooks/index.ts\"),\r\n      indexContent\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Backend Integration System\r\n\r\n### 1. Backend Integrator\r\n\r\n**FastAPI Router and Middleware Registration:**\r\n\r\n```typescript\r\n// packages/core/src/plugins/integrators/backend.ts\r\nexport class BackendIntegrator {\r\n  private integration: BackendIntegration;\r\n  private context: PluginContext;\r\n  private registeredRouters = new Map<string, RouterRegistration>();\r\n  private registeredMiddleware = new Map<string, MiddlewareRegistration>();\r\n\r\n  constructor(integration: BackendIntegration, context: PluginContext) {\r\n    this.integration = integration;\r\n    this.context = context;\r\n  }\r\n\r\n  async setup(): Promise<void> {\r\n    // Install Python dependencies\r\n    await this.installPythonDependencies();\r\n\r\n    // Validate Python modules\r\n    await this.validatePythonModules();\r\n\r\n    // Setup database models\r\n    await this.setupDatabaseModels();\r\n  }\r\n\r\n  async activate(): Promise<void> {\r\n    // Register routers\r\n    await this.registerRouters();\r\n\r\n    // Register middleware\r\n    await this.registerMiddleware();\r\n\r\n    // Register background tasks\r\n    await this.registerBackgroundTasks();\r\n\r\n    // Generate FastAPI integration\r\n    await this.generateFastAPIIntegration();\r\n\r\n    // Trigger backend reload\r\n    await this.triggerBackendReload();\r\n  }\r\n\r\n  private async registerRouters(): Promise<void> {\r\n    if (!this.integration.routers) return;\r\n\r\n    for (const [name, router] of Object.entries(this.integration.routers)) {\r\n      const registration: RouterRegistration = {\r\n        name,\r\n        path: router.path,\r\n        prefix: router.prefix,\r\n        tags: router.tags || [],\r\n        middleware: router.middleware || [],\r\n        plugin: this.context.plugin.name,\r\n      };\r\n\r\n      // Validate router module\r\n      await this.validateRouterModule(registration);\r\n\r\n      // Register with router registry\r\n      RouterRegistry.register(registration);\r\n\r\n      this.registeredRouters.set(name, registration);\r\n    }\r\n  }\r\n\r\n  private async generateFastAPIIntegration(): Promise<void> {\r\n    const routers = RouterRegistry.getAll();\r\n    const middleware = MiddlewareRegistry.getAll();\r\n\r\n    const integrationContent = `\r\n# Auto-generated plugin integration\r\n# Do not edit this file manually\r\n\r\nfrom fastapi import FastAPI\r\nfrom fastapi.middleware.base import BaseHTTPMiddleware\r\n\r\n# Router imports\r\n${routers\r\n  .map(\r\n    (router) => `\r\nfrom ${router.path} import ${router.name}\r\n`\r\n  )\r\n  .join(\"\")}\r\n\r\n# Middleware imports\r\n${middleware\r\n  .map(\r\n    (mw) => `\r\nfrom ${mw.path} import ${mw.name}\r\n`\r\n  )\r\n  .join(\"\")}\r\n\r\ndef setup_plugin_integrations(app: FastAPI):\r\n    \"\"\"Setup all plugin integrations\"\"\"\r\n    \r\n    # Register middleware (in reverse order for proper layering)\r\n    ${middleware\r\n      .sort((a, b) => b.order - a.order)\r\n      .map(\r\n        (mw) => `\r\n    app.add_middleware(${mw.name})\r\n    `\r\n      )\r\n      .join(\"\")}\r\n    \r\n    # Register routers\r\n    ${routers\r\n      .map(\r\n        (router) => `\r\n    app.include_router(\r\n        ${router.name},\r\n        prefix=\"${router.prefix}\",\r\n        tags=${JSON.stringify(router.tags)}\r\n    )\r\n    `\r\n      )\r\n      .join(\"\")}\r\n`;\r\n\r\n    await fs.writeFile(\r\n      path.join(this.context.paths.backend, \"src/plugins/integration.py\"),\r\n      integrationContent\r\n    );\r\n  }\r\n\r\n  private async installPythonDependencies(): Promise<void> {\r\n    if (!this.integration.dependencies?.length) return;\r\n\r\n    const requirements = this.integration.dependencies\r\n      .map((dep) => `${dep.name}${dep.version ? `==${dep.version}` : \"\"}`)\r\n      .join(\"\\n\");\r\n\r\n    // Add to plugin requirements file\r\n    const requirementsPath = path.join(\r\n      this.context.paths.backend,\r\n      \"plugins\",\r\n      this.context.plugin.name,\r\n      \"requirements.txt\"\r\n    );\r\n\r\n    await fs.ensureDir(path.dirname(requirementsPath));\r\n    await fs.writeFile(requirementsPath, requirements);\r\n\r\n    // Install using pip\r\n    await this.runPipInstall(requirementsPath);\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## AI Integration System\r\n\r\n### 1. AI Provider Plugin Integration\r\n\r\n**Custom AI Provider Registration:**\r\n\r\n```typescript\r\n// packages/core/src/plugins/integrators/ai.ts\r\nexport class AIIntegrator {\r\n  private integration: AIIntegration;\r\n  private context: PluginContext;\r\n  private registeredProviders = new Map<string, AIProviderRegistration>();\r\n  private registeredModels = new Map<string, AIModelRegistration>();\r\n\r\n  constructor(integration: AIIntegration, context: PluginContext) {\r\n    this.integration = integration;\r\n    this.context = context;\r\n  }\r\n\r\n  async activate(): Promise<void> {\r\n    // Register AI providers\r\n    await this.registerAIProviders();\r\n\r\n    // Register models\r\n    await this.registerAIModels();\r\n\r\n    // Register pipelines\r\n    await this.registerAIPipelines();\r\n\r\n    // Register endpoints\r\n    await this.registerAIEndpoints();\r\n\r\n    // Update AI router configuration\r\n    await this.updateAIRouterConfig();\r\n  }\r\n\r\n  private async registerAIProviders(): Promise<void> {\r\n    if (!this.integration.providers) return;\r\n\r\n    for (const [name, provider] of Object.entries(this.integration.providers)) {\r\n      const registration: AIProviderRegistration = {\r\n        name,\r\n        path: provider.path,\r\n        models: provider.models,\r\n        capabilities: provider.capabilities,\r\n        plugin: this.context.plugin.name,\r\n      };\r\n\r\n      // Validate provider implementation\r\n      await this.validateAIProvider(registration);\r\n\r\n      // Register with AI router\r\n      AIProviderRegistry.register(registration);\r\n\r\n      this.registeredProviders.set(name, registration);\r\n    }\r\n  }\r\n\r\n  private async validateAIProvider(\r\n    registration: AIProviderRegistration\r\n  ): Promise<void> {\r\n    try {\r\n      // Dynamically import provider module\r\n      const module = await import(registration.path);\r\n      const providerClass = module.default || module[registration.name];\r\n\r\n      if (!providerClass) {\r\n        throw new Error(`Provider class not found in ${registration.path}`);\r\n      }\r\n\r\n      // Check if it implements required interface\r\n      const requiredMethods = [\"generate\", \"chat\", \"embed\", \"health_check\"];\r\n      const instance = new providerClass({});\r\n\r\n      for (const method of requiredMethods) {\r\n        if (typeof instance[method] !== \"function\") {\r\n          throw new Error(\r\n            `Provider ${registration.name} missing required method: ${method}`\r\n          );\r\n        }\r\n      }\r\n    } catch (error) {\r\n      throw new Error(\r\n        `AI provider validation failed for ${registration.name}: ${error.message}`\r\n      );\r\n    }\r\n  }\r\n\r\n  private async updateAIRouterConfig(): Promise<void> {\r\n    const providers = AIProviderRegistry.getAll();\r\n    const models = AIModelRegistry.getAll();\r\n\r\n    const configContent = `\r\n# Auto-generated AI configuration\r\n# Do not edit this file manually\r\n\r\nfrom typing import Dict, Any\r\nfrom farm.ai.router import AIRouter\r\n\r\n# Provider imports\r\n${providers\r\n  .map(\r\n    (provider) => `\r\nfrom ${provider.path} import ${provider.name}\r\n`\r\n  )\r\n  .join(\"\")}\r\n\r\ndef setup_ai_providers(router: AIRouter):\r\n    \"\"\"Setup plugin AI providers\"\"\"\r\n    \r\n    # Register providers\r\n    ${providers\r\n      .map(\r\n        (provider) => `\r\n    router.register_provider('${provider.name}', ${provider.name})\r\n    `\r\n      )\r\n      .join(\"\")}\r\n    \r\n    # Register models\r\n    ${models\r\n      .map(\r\n        (model) => `\r\n    router.register_model('${model.name}', {\r\n        'provider': '${model.provider}',\r\n        'config': ${JSON.stringify(model.config)},\r\n        'requirements': ${JSON.stringify(model.requirements)}\r\n    })\r\n    `\r\n      )\r\n      .join(\"\")}\r\n`;\r\n\r\n    await fs.writeFile(\r\n      path.join(this.context.paths.backend, \"src/plugins/ai_config.py\"),\r\n      configContent\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Plugin Configuration System\r\n\r\n### 1. Configuration Schema Validation\r\n\r\n**Type-Safe Plugin Configuration:**\r\n\r\n```typescript\r\n// packages/core/src/plugins/config.ts\r\nexport interface PluginConfigSchema {\r\n  type: \"object\";\r\n  properties: Record<string, ConfigPropertySchema>;\r\n  required?: string[];\r\n  additionalProperties?: boolean;\r\n}\r\n\r\nexport interface ConfigPropertySchema {\r\n  type: \"string\" | \"number\" | \"boolean\" | \"array\" | \"object\";\r\n  description?: string;\r\n  default?: any;\r\n  enum?: any[];\r\n  format?: string;\r\n  items?: ConfigPropertySchema;\r\n  properties?: Record<string, ConfigPropertySchema>;\r\n}\r\n\r\nexport class PluginConfigValidator {\r\n  static validate(config: any, schema: PluginConfigSchema): ValidationResult {\r\n    try {\r\n      const validator = new JSONSchemaValidator();\r\n      const result = validator.validate(config, schema);\r\n\r\n      return {\r\n        valid: result.errors.length === 0,\r\n        errors: result.errors,\r\n        warnings: [],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        valid: false,\r\n        errors: [error.message],\r\n        warnings: [],\r\n      };\r\n    }\r\n  }\r\n\r\n  static applyDefaults(config: any, schema: PluginConfigSchema): any {\r\n    const result = { ...config };\r\n\r\n    for (const [key, propertySchema] of Object.entries(\r\n      schema.properties || {}\r\n    )) {\r\n      if (result[key] === undefined && propertySchema.default !== undefined) {\r\n        result[key] = propertySchema.default;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  static generateTypeScript(schema: PluginConfigSchema): string {\r\n    return this.generateTSInterface(\"PluginConfig\", schema);\r\n  }\r\n\r\n  private static generateTSInterface(\r\n    name: string,\r\n    schema: PluginConfigSchema\r\n  ): string {\r\n    const properties = Object.entries(schema.properties || {})\r\n      .map(([key, prop]) => {\r\n        const optional = !schema.required?.includes(key) ? \"?\" : \"\";\r\n        const type = this.getTSType(prop);\r\n        const comment = prop.description\r\n          ? `\\n  /** ${prop.description} */`\r\n          : \"\";\r\n        return `${comment}\\n  ${key}${optional}: ${type};`;\r\n      })\r\n      .join(\"\\n\");\r\n\r\n    return `export interface ${name} {\\n${properties}\\n}`;\r\n  }\r\n\r\n  private static getTSType(schema: ConfigPropertySchema): string {\r\n    switch (schema.type) {\r\n      case \"string\":\r\n        return schema.enum\r\n          ? schema.enum.map((v) => `'${v}'`).join(\" | \")\r\n          : \"string\";\r\n      case \"number\":\r\n        return \"number\";\r\n      case \"boolean\":\r\n        return \"boolean\";\r\n      case \"array\":\r\n        return `Array<${schema.items ? this.getTSType(schema.items) : \"any\"}>`;\r\n      case \"object\":\r\n        return schema.properties\r\n          ? `{\\n${Object.entries(schema.properties)\r\n              .map(([k, v]) => `    ${k}: ${this.getTSType(v)};`)\r\n              .join(\"\\n\")}\\n  }`\r\n          : \"Record<string, any>\";\r\n      default:\r\n        return \"any\";\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Plugin CLI Commands\r\n\r\n### 1. Plugin Management Commands\r\n\r\n**CLI Integration for Plugin Operations:**\r\n\r\n```bash\r\n# Plugin installation\r\nfarm plugin install @farm/auth\r\nfarm plugin install @farm/auth@1.2.0\r\nfarm plugin install https://github.com/user/farm-plugin.git\r\nfarm plugin install ./local-plugin\r\n\r\n# Plugin management\r\nfarm plugin list                    # List installed plugins\r\nfarm plugin list --available        # List available plugins\r\nfarm plugin activate auth           # Activate plugin\r\nfarm plugin deactivate auth         # Deactivate plugin\r\nfarm plugin uninstall auth          # Uninstall plugin\r\nfarm plugin update auth             # Update to latest version\r\nfarm plugin update                  # Update all plugins\r\n\r\n# Plugin development\r\nfarm plugin create my-plugin        # Create new plugin\r\nfarm plugin validate                # Validate plugin configuration\r\nfarm plugin build                   # Build plugin for distribution\r\nfarm plugin publish                 # Publish to registry\r\n\r\n# Plugin information\r\nfarm plugin info auth               # Show plugin details\r\nfarm plugin deps auth               # Show plugin dependencies\r\nfarm plugin search authentication   # Search for plugins\r\n```\r\n\r\n### 2. Plugin Development Workflow\r\n\r\n**Plugin Development Commands:**\r\n\r\n```typescript\r\n// packages/cli/src/commands/plugin/create.ts\r\nexport async function createPlugin(name: string, options: CreatePluginOptions) {\r\n  const pluginPath = path.join(process.cwd(), name);\r\n\r\n  // Create plugin directory structure\r\n  await fs.ensureDir(pluginPath);\r\n\r\n  // Generate plugin manifest\r\n  const manifest: FarmPlugin = {\r\n    name,\r\n    version: \"1.0.0\",\r\n    description: options.description || \"A FARM plugin\",\r\n    author: options.author || \"Anonymous\",\r\n    license: \"MIT\",\r\n    farmVersion: \"^1.0.0\",\r\n    configSchema: {\r\n      type: \"object\",\r\n      properties: {\r\n        enabled: {\r\n          type: \"boolean\",\r\n          default: true,\r\n          description: \"Enable the plugin\",\r\n        },\r\n      },\r\n    },\r\n  };\r\n\r\n  await fs.writeJSON(path.join(pluginPath, \"plugin.json\"), manifest, {\r\n    spaces: 2,\r\n  });\r\n\r\n  // Generate package.json\r\n  const packageJson = {\r\n    name: `@farm/plugin-${name}`,\r\n    version: \"1.0.0\",\r\n    description: manifest.description,\r\n    main: \"dist/index.js\",\r\n    types: \"dist/index.d.ts\",\r\n    files: [\"dist\", \"plugin.json\"],\r\n    peerDependencies: {\r\n      \"@farm/core\": \"^1.0.0\",\r\n    },\r\n    devDependencies: {\r\n      \"@farm/plugin-sdk\": \"^1.0.0\",\r\n      typescript: \"^5.0.0\",\r\n    },\r\n    scripts: {\r\n      build: \"tsc\",\r\n      dev: \"tsc --watch\",\r\n      test: \"jest\",\r\n    },\r\n  };\r\n\r\n  await fs.writeJSON(path.join(pluginPath, \"package.json\"), packageJson, {\r\n    spaces: 2,\r\n  });\r\n\r\n  // Generate TypeScript configuration\r\n  await generatePluginTSConfig(pluginPath);\r\n\r\n  // Generate example plugin code\r\n  await generatePluginTemplate(pluginPath, options);\r\n\r\n  console.log(`✅ Plugin ${name} created successfully!`);\r\n  console.log(`📁 Location: ${pluginPath}`);\r\n  console.log(\"\\n📚 Next steps:\");\r\n  console.log(`   cd ${name}`);\r\n  console.log(\"   npm install\");\r\n  console.log(\"   npm run dev\");\r\n}\r\n```\r\n\r\n---\r\n\r\n## Official Plugin Examples\r\n\r\n### 1. Authentication Plugin\r\n\r\n**Complete Auth Plugin Implementation:**\r\n\r\n```json\r\n// plugins/auth/plugin.json\r\n{\r\n  \"name\": \"@farm/auth\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"Authentication and authorization plugin\",\r\n  \"author\": \"FARM Team\",\r\n  \"license\": \"MIT\",\r\n  \"farmVersion\": \"^1.0.0\",\r\n  \"configSchema\": {\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n      \"providers\": {\r\n        \"type\": \"array\",\r\n        \"description\": \"Authentication providers to enable\",\r\n        \"items\": {\r\n          \"type\": \"string\",\r\n          \"enum\": [\"jwt\", \"oauth\", \"saml\"]\r\n        },\r\n        \"default\": [\"jwt\"]\r\n      },\r\n      \"jwt\": {\r\n        \"type\": \"object\",\r\n        \"description\": \"JWT configuration\",\r\n        \"properties\": {\r\n          \"secret\": {\r\n            \"type\": \"string\",\r\n            \"description\": \"JWT secret key\"\r\n          },\r\n          \"expiration\": {\r\n            \"type\": \"string\",\r\n            \"description\": \"Token expiration time\",\r\n            \"default\": \"24h\"\r\n          }\r\n        }\r\n      },\r\n      \"oauth\": {\r\n        \"type\": \"object\",\r\n        \"description\": \"OAuth providers configuration\",\r\n        \"properties\": {\r\n          \"google\": {\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n              \"clientId\": { \"type\": \"string\" },\r\n              \"clientSecret\": { \"type\": \"string\" }\r\n            }\r\n          },\r\n          \"github\": {\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n              \"clientId\": { \"type\": \"string\" },\r\n              \"clientSecret\": { \"type\": \"string\" }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n  \"frontend\": {\r\n    \"components\": {\r\n      \"LoginForm\": {\r\n        \"path\": \"./components/LoginForm.tsx\",\r\n        \"props\": {\r\n          \"type\": \"object\",\r\n          \"properties\": {\r\n            \"onSuccess\": { \"type\": \"function\" },\r\n            \"providers\": { \"type\": \"array\" }\r\n          }\r\n        }\r\n      },\r\n      \"ProtectedRoute\": {\r\n        \"path\": \"./components/ProtectedRoute.tsx\",\r\n        \"props\": {\r\n          \"type\": \"object\",\r\n          \"properties\": {\r\n            \"children\": { \"type\": \"ReactNode\" },\r\n            \"roles\": { \"type\": \"array\" }\r\n          }\r\n        }\r\n      }\r\n    },\r\n    \"hooks\": {\r\n      \"useAuth\": {\r\n        \"path\": \"./hooks/useAuth.ts\"\r\n      },\r\n      \"useUser\": {\r\n        \"path\": \"./hooks/useUser.ts\",\r\n        \"dependencies\": [\"useAuth\"]\r\n      }\r\n    },\r\n    \"routes\": [\r\n      {\r\n        \"path\": \"/login\",\r\n        \"component\": \"LoginPage\"\r\n      },\r\n      {\r\n        \"path\": \"/register\",\r\n        \"component\": \"RegisterPage\"\r\n      }\r\n    ],\r\n    \"dependencies\": [\r\n      {\r\n        \"name\": \"jsonwebtoken\",\r\n        \"version\": \"^9.0.0\"\r\n      }\r\n    ]\r\n  },\r\n  \"backend\": {\r\n    \"routers\": {\r\n      \"auth_router\": {\r\n        \"path\": \"./routers/auth.py\",\r\n        \"prefix\": \"/auth\",\r\n        \"tags\": [\"authentication\"]\r\n      },\r\n      \"user_router\": {\r\n        \"path\": \"./routers/users.py\",\r\n        \"prefix\": \"/users\",\r\n        \"tags\": [\"users\"]\r\n      }\r\n    },\r\n    \"middleware\": {\r\n      \"auth_middleware\": {\r\n        \"path\": \"./middleware/auth.py\",\r\n        \"order\": 100\r\n      }\r\n    },\r\n    \"models\": {\r\n      \"User\": {\r\n        \"path\": \"./models/user.py\",\r\n        \"collection\": \"users\",\r\n        \"indexes\": [\"email\", \"username\"]\r\n      },\r\n      \"Session\": {\r\n        \"path\": \"./models/session.py\",\r\n        \"collection\": \"sessions\"\r\n      }\r\n    },\r\n    \"dependencies\": [\r\n      {\r\n        \"name\": \"python-jose\",\r\n        \"version\": \"3.3.0\"\r\n      },\r\n      {\r\n        \"name\": \"passlib\",\r\n        \"version\": \"1.7.4\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n### 2. AI Chat Plugin\r\n\r\n**AI-Enhanced Plugin Example:**\r\n\r\n```json\r\n// plugins/ai-chat/plugin.json\r\n{\r\n  \"name\": \"@farm/ai-chat\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"AI-powered chat interface with Ollama integration\",\r\n  \"author\": \"FARM Team\",\r\n  \"license\": \"MIT\",\r\n  \"farmVersion\": \"^1.0.0\",\r\n  \"configSchema\": {\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n      \"defaultProvider\": {\r\n        \"type\": \"string\",\r\n        \"enum\": [\"ollama\", \"openai\", \"huggingface\"],\r\n        \"default\": \"ollama\",\r\n        \"description\": \"Default AI provider\"\r\n      },\r\n      \"enableStreaming\": {\r\n        \"type\": \"boolean\",\r\n        \"default\": true,\r\n        \"description\": \"Enable streaming responses\"\r\n      },\r\n      \"maxTokens\": {\r\n        \"type\": \"number\",\r\n        \"default\": 1000,\r\n        \"description\": \"Maximum tokens per response\"\r\n      },\r\n      \"systemPrompt\": {\r\n        \"type\": \"string\",\r\n        \"default\": \"You are a helpful AI assistant.\",\r\n        \"description\": \"Default system prompt\"\r\n      }\r\n    }\r\n  },\r\n  \"frontend\": {\r\n    \"components\": {\r\n      \"ChatWindow\": {\r\n        \"path\": \"./components/ChatWindow.tsx\"\r\n      },\r\n      \"MessageList\": {\r\n        \"path\": \"./components/MessageList.tsx\"\r\n      },\r\n      \"MessageInput\": {\r\n        \"path\": \"./components/MessageInput.tsx\"\r\n      },\r\n      \"ModelSelector\": {\r\n        \"path\": \"./components/ModelSelector.tsx\"\r\n      }\r\n    },\r\n    \"hooks\": {\r\n      \"useStreamingChat\": {\r\n        \"path\": \"./hooks/useStreamingChat.ts\"\r\n      },\r\n      \"useAIModels\": {\r\n        \"path\": \"./hooks/useAIModels.ts\"\r\n      }\r\n    }\r\n  },\r\n  \"backend\": {\r\n    \"routers\": {\r\n      \"chat_router\": {\r\n        \"path\": \"./routers/chat.py\",\r\n        \"prefix\": \"/chat\",\r\n        \"tags\": [\"chat\", \"ai\"]\r\n      }\r\n    },\r\n    \"models\": {\r\n      \"Conversation\": {\r\n        \"path\": \"./models/conversation.py\",\r\n        \"collection\": \"conversations\"\r\n      },\r\n      \"Message\": {\r\n        \"path\": \"./models/message.py\",\r\n        \"collection\": \"messages\"\r\n      }\r\n    }\r\n  },\r\n  \"ai\": {\r\n    \"providers\": {\r\n      \"custom_ollama\": {\r\n        \"path\": \"./providers/enhanced_ollama.py\",\r\n        \"models\": [\"llama3.1\", \"codestral\"],\r\n        \"capabilities\": [\"chat\", \"completion\", \"embedding\"]\r\n      }\r\n    },\r\n    \"endpoints\": {\r\n      \"chat_stream\": {\r\n        \"path\": \"./endpoints/chat_stream.py\",\r\n        \"method\": \"POST\",\r\n        \"streaming\": true\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Plugin Security & Validation\r\n\r\n### 1. Security Model\r\n\r\n**Plugin Security Framework:**\r\n\r\n```typescript\r\nexport interface PluginSecurityPolicy {\r\n  // Permission requirements\r\n  permissions: {\r\n    filesystem?: FileSystemPermissions;\r\n    network?: NetworkPermissions;\r\n    database?: DatabasePermissions;\r\n    ai?: AIPermissions;\r\n  };\r\n\r\n  // Resource limits\r\n  limits: {\r\n    memory?: number;\r\n    cpu?: number;\r\n    storage?: number;\r\n    networkCalls?: number;\r\n  };\r\n\r\n  // Sandbox configuration\r\n  sandbox: {\r\n    enabled: boolean;\r\n    isolateFilesystem?: boolean;\r\n    isolateNetwork?: boolean;\r\n    allowedDomains?: string[];\r\n  };\r\n}\r\n\r\nexport class PluginSecurityValidator {\r\n  static validatePermissions(\r\n    plugin: FarmPlugin,\r\n    policy: PluginSecurityPolicy\r\n  ): SecurityResult {\r\n    const violations: SecurityViolation[] = [];\r\n\r\n    // Check filesystem access\r\n    if (plugin.backend?.models && !policy.permissions.database?.write) {\r\n      violations.push({\r\n        type: \"permission\",\r\n        message: \"Plugin requires database write access but policy denies it\",\r\n      });\r\n    }\r\n\r\n    // Check network access\r\n    if (plugin.ai?.providers && !policy.permissions.network?.external) {\r\n      violations.push({\r\n        type: \"permission\",\r\n        message: \"Plugin requires external network access for AI providers\",\r\n      });\r\n    }\r\n\r\n    return {\r\n      valid: violations.length === 0,\r\n      violations,\r\n    };\r\n  }\r\n\r\n  static analyzeCodeSafety(pluginPath: string): Promise<CodeSafetyResult> {\r\n    // Static analysis of plugin code\r\n    // Check for dangerous patterns, imports, etc.\r\n    return this.runStaticAnalysis(pluginPath);\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Plugin Hot Reload & Development\r\n\r\n### 1. Hot Reload System\r\n\r\n**Plugin Development Hot Reload:**\r\n\r\n```typescript\r\nexport class PluginHotReloader {\r\n  private watchers = new Map<string, FSWatcher>();\r\n  private pluginManager: PluginManager;\r\n\r\n  constructor(pluginManager: PluginManager) {\r\n    this.pluginManager = pluginManager;\r\n  }\r\n\r\n  startWatching(pluginName: string): void {\r\n    const plugin = this.pluginManager.getPlugin(pluginName);\r\n    if (!plugin) return;\r\n\r\n    const pluginPath = plugin.getPath();\r\n\r\n    const watcher = chokidar.watch(\r\n      [\r\n        path.join(pluginPath, \"**/*.ts\"),\r\n        path.join(pluginPath, \"**/*.tsx\"),\r\n        path.join(pluginPath, \"**/*.py\"),\r\n        path.join(pluginPath, \"plugin.json\"),\r\n      ],\r\n      {\r\n        ignoreInitial: true,\r\n        ignored: [\"node_modules\", \"dist\", \"__pycache__\"],\r\n      }\r\n    );\r\n\r\n    watcher.on(\"change\", async (changedPath) => {\r\n      console.log(`🔄 Plugin ${pluginName} file changed: ${changedPath}`);\r\n\r\n      try {\r\n        if (changedPath.endsWith(\"plugin.json\")) {\r\n          // Reload plugin manifest\r\n          await this.reloadPluginManifest(pluginName);\r\n        } else if (changedPath.endsWith(\".py\")) {\r\n          // Reload backend integration\r\n          await this.reloadBackendIntegration(pluginName);\r\n        } else if (\r\n          changedPath.endsWith(\".ts\") ||\r\n          changedPath.endsWith(\".tsx\")\r\n        ) {\r\n          // Reload frontend integration\r\n          await this.reloadFrontendIntegration(pluginName);\r\n        }\r\n\r\n        console.log(`✅ Plugin ${pluginName} hot-reloaded successfully`);\r\n      } catch (error) {\r\n        console.error(`❌ Failed to hot-reload plugin ${pluginName}:`, error);\r\n      }\r\n    });\r\n\r\n    this.watchers.set(pluginName, watcher);\r\n  }\r\n\r\n  stopWatching(pluginName: string): void {\r\n    const watcher = this.watchers.get(pluginName);\r\n    if (watcher) {\r\n      watcher.close();\r\n      this.watchers.delete(pluginName);\r\n    }\r\n  }\r\n\r\n  private async reloadPluginManifest(pluginName: string): Promise<void> {\r\n    // Deactivate plugin\r\n    await this.pluginManager.deactivatePlugin(pluginName);\r\n\r\n    // Reload manifest\r\n    const plugin = this.pluginManager.getPlugin(pluginName);\r\n    await plugin?.reloadManifest();\r\n\r\n    // Reactivate plugin\r\n    await this.pluginManager.activatePlugin(pluginName);\r\n  }\r\n\r\n  private async reloadFrontendIntegration(pluginName: string): Promise<void> {\r\n    const plugin = this.pluginManager.getPlugin(pluginName);\r\n    if (!plugin?.frontendIntegrator) return;\r\n\r\n    // Rebuild frontend integration\r\n    await plugin.frontendIntegrator.deactivate();\r\n    await plugin.frontendIntegrator.activate();\r\n\r\n    // Trigger Vite HMR\r\n    await this.triggerViteHMR();\r\n  }\r\n\r\n  private async reloadBackendIntegration(pluginName: string): Promise<void> {\r\n    const plugin = this.pluginManager.getPlugin(pluginName);\r\n    if (!plugin?.backendIntegrator) return;\r\n\r\n    // Clear Python module cache\r\n    this.clearPythonModuleCache(plugin.getPath());\r\n\r\n    // Rebuild backend integration\r\n    await plugin.backendIntegrator.deactivate();\r\n    await plugin.backendIntegrator.activate();\r\n\r\n    // Restart FastAPI if needed\r\n    await this.restartFastAPIServer();\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Plugin Registry & Marketplace\r\n\r\n### 1. Plugin Registry\r\n\r\n**Community Plugin Discovery:**\r\n\r\n```typescript\r\nexport interface PluginRegistry {\r\n  search(query: string, filters?: PluginFilters): Promise<PluginListing[]>;\r\n  getPlugin(name: string): Promise<PluginDetails>;\r\n  getVersions(name: string): Promise<PluginVersion[]>;\r\n  download(name: string, version?: string): Promise<PluginPackage>;\r\n  publish(plugin: PluginPackage): Promise<PublishResult>;\r\n}\r\n\r\nexport interface PluginListing {\r\n  name: string;\r\n  description: string;\r\n  version: string;\r\n  author: string;\r\n  tags: string[];\r\n  downloads: number;\r\n  rating: number;\r\n  verified: boolean;\r\n  farmVersions: string[];\r\n  lastUpdated: Date;\r\n}\r\n\r\nexport class NPMPluginRegistry implements PluginRegistry {\r\n  async search(\r\n    query: string,\r\n    filters?: PluginFilters\r\n  ): Promise<PluginListing[]> {\r\n    const searchQuery = `@farm/plugin-${query} OR farm-plugin-${query}`;\r\n\r\n    const response = await fetch(\r\n      `https://registry.npmjs.org/-/v1/search?text=${searchQuery}`\r\n    );\r\n    const data = await response.json();\r\n\r\n    return data.objects\r\n      .filter((pkg: any) => this.isValidFarmPlugin(pkg))\r\n      .map((pkg: any) => this.mapToPluginListing(pkg));\r\n  }\r\n\r\n  private isValidFarmPlugin(pkg: any): boolean {\r\n    return (\r\n      pkg.package.name.startsWith(\"@farm/plugin-\") ||\r\n      pkg.package.name.startsWith(\"farm-plugin-\") ||\r\n      pkg.package.keywords?.includes(\"farm-plugin\")\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n_Status: ✅ Completed - Ready for implementation_\r\n\r\nThis plugin system architecture provides:\r\n\r\n- **Type-safe plugin development** with comprehensive interfaces\r\n- **Multi-domain integration** (frontend, backend, AI, database)\r\n- **Hot reload support** for rapid plugin development\r\n- **Security model** with permissions and sandboxing\r\n- **CLI integration** for plugin management\r\n- **Community ecosystem** with registry and marketplace\r\n- **AI-aware architecture** with provider integration\r\n",
      "excerpt": "The FARM plugin system provides a powerful, type-safe, and AI-aware extension mechanism that allows developers to extend framework functionality through declara...",
      "category": "architectural-sketches-detailed/phase2",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "farm",
        "typescript",
        "python"
      ],
      "lastModified": "2025-06-12T21:57:32.782Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase2",
        "Plugin_system_architecture"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Plugin System Architecture",
          "id": "plugin-system-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "High-Level Plugin Architecture",
          "id": "high-level-plugin-architecture"
        },
        {
          "level": 2,
          "text": "Core Plugin Architecture",
          "id": "core-plugin-architecture"
        },
        {
          "level": 3,
          "text": "1. Plugin Definition Interface",
          "id": "1-plugin-definition-interface"
        },
        {
          "level": 3,
          "text": "2. Plugin Integration Interfaces",
          "id": "2-plugin-integration-interfaces"
        },
        {
          "level": 2,
          "text": "Plugin Management System",
          "id": "plugin-management-system"
        },
        {
          "level": 3,
          "text": "1. Plugin Manager Core",
          "id": "1-plugin-manager-core"
        },
        {
          "level": 3,
          "text": "2. Plugin Instance Implementation",
          "id": "2-plugin-instance-implementation"
        },
        {
          "level": 2,
          "text": "Frontend Integration System",
          "id": "frontend-integration-system"
        },
        {
          "level": 3,
          "text": "1. Frontend Integrator",
          "id": "1-frontend-integrator"
        },
        {
          "level": 2,
          "text": "Backend Integration System",
          "id": "backend-integration-system"
        },
        {
          "level": 3,
          "text": "1. Backend Integrator",
          "id": "1-backend-integrator"
        },
        {
          "level": 1,
          "text": "Auto-generated plugin integration",
          "id": "auto-generated-plugin-integration"
        },
        {
          "level": 1,
          "text": "Do not edit this file manually",
          "id": "do-not-edit-this-file-manually"
        },
        {
          "level": 1,
          "text": "Router imports",
          "id": "router-imports"
        },
        {
          "level": 1,
          "text": "Middleware imports",
          "id": "middleware-imports"
        },
        {
          "level": 2,
          "text": "AI Integration System",
          "id": "ai-integration-system"
        },
        {
          "level": 3,
          "text": "1. AI Provider Plugin Integration",
          "id": "1-ai-provider-plugin-integration"
        },
        {
          "level": 1,
          "text": "Auto-generated AI configuration",
          "id": "auto-generated-ai-configuration"
        },
        {
          "level": 1,
          "text": "Do not edit this file manually",
          "id": "do-not-edit-this-file-manually"
        },
        {
          "level": 1,
          "text": "Provider imports",
          "id": "provider-imports"
        },
        {
          "level": 2,
          "text": "Plugin Configuration System",
          "id": "plugin-configuration-system"
        },
        {
          "level": 3,
          "text": "1. Configuration Schema Validation",
          "id": "1-configuration-schema-validation"
        },
        {
          "level": 2,
          "text": "Plugin CLI Commands",
          "id": "plugin-cli-commands"
        },
        {
          "level": 3,
          "text": "1. Plugin Management Commands",
          "id": "1-plugin-management-commands"
        },
        {
          "level": 1,
          "text": "Plugin installation",
          "id": "plugin-installation"
        },
        {
          "level": 1,
          "text": "Plugin management",
          "id": "plugin-management"
        },
        {
          "level": 1,
          "text": "Plugin development",
          "id": "plugin-development"
        },
        {
          "level": 1,
          "text": "Plugin information",
          "id": "plugin-information"
        },
        {
          "level": 3,
          "text": "2. Plugin Development Workflow",
          "id": "2-plugin-development-workflow"
        },
        {
          "level": 2,
          "text": "Official Plugin Examples",
          "id": "official-plugin-examples"
        },
        {
          "level": 3,
          "text": "1. Authentication Plugin",
          "id": "1-authentication-plugin"
        },
        {
          "level": 3,
          "text": "2. AI Chat Plugin",
          "id": "2-ai-chat-plugin"
        },
        {
          "level": 2,
          "text": "Plugin Security & Validation",
          "id": "plugin-security-validation"
        },
        {
          "level": 3,
          "text": "1. Security Model",
          "id": "1-security-model"
        },
        {
          "level": 2,
          "text": "Plugin Hot Reload & Development",
          "id": "plugin-hot-reload-development"
        },
        {
          "level": 3,
          "text": "1. Hot Reload System",
          "id": "1-hot-reload-system"
        },
        {
          "level": 2,
          "text": "Plugin Registry & Marketplace",
          "id": "plugin-registry-marketplace"
        },
        {
          "level": 3,
          "text": "1. Plugin Registry",
          "id": "1-plugin-registry"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase3-deployment_pipeline_architecture",
      "title": "Deployment_pipeline_architecture",
      "url": "/architectural-sketches-detailed/phase3/deployment_pipeline_architecture",
      "content": "# Deployment Pipeline Structure\r\n\r\n## Overview\r\n\r\nThe FARM deployment pipeline provides intelligent, multi-platform deployment strategies that automatically adapt based on application requirements, AI provider configuration, and target environment. It seamlessly transitions from local Ollama development to cloud AI providers while optimizing for performance, cost, and developer experience.\r\n\r\n---\r\n\r\n## High-Level Deployment Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Deployment Pipeline                     │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │   Build     │  │   Analysis  │  │   Platform  │  │  Deploy │ │\r\n│  │ Optimizer   │  │   Engine    │  │  Adapter    │  │ Manager │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │    AI       │  │  Database   │  │   Static    │  │   CDN   │ │\r\n│  │ Migration   │  │ Deployment  │  │   Assets    │  │Optimization│ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Environment │  │ Monitoring  │  │   Rollback  │  │Security │ │\r\n│  │ Validation  │  │   Setup     │  │  Strategy   │ │ Hardening│ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Deployment Components\r\n\r\n### 1. Deployment Analysis Engine\r\n\r\n**Purpose:** Analyze application requirements and recommend optimal deployment strategy\r\n\r\n**Implementation:**\r\n\r\n```typescript\r\n// tools/deployment/analyzer.ts\r\nexport interface DeploymentRequirements {\r\n  // Application analysis\r\n  hasAI: boolean;\r\n  aiProviders: (\"ollama\" | \"openai\" | \"huggingface\")[];\r\n  hasRealtime: boolean;\r\n  hasDatabase: boolean;\r\n  hasFileStorage: boolean;\r\n\r\n  // Performance requirements\r\n  expectedTraffic: \"low\" | \"medium\" | \"high\" | \"enterprise\";\r\n  latencyRequirements: \"standard\" | \"low\" | \"realtime\";\r\n  scalingNeeds: \"static\" | \"dynamic\" | \"auto\";\r\n\r\n  // Geographic requirements\r\n  regions: string[];\r\n  globalCDN: boolean;\r\n\r\n  // Budget constraints\r\n  budgetTier: \"startup\" | \"growth\" | \"enterprise\";\r\n  costOptimization: boolean;\r\n}\r\n\r\nexport interface DeploymentRecommendation {\r\n  platform: DeploymentPlatform;\r\n  architecture: DeploymentArchitecture;\r\n  confidence: number;\r\n  reasoning: string[];\r\n  alternatives: AlternativeDeployment[];\r\n  estimatedCost: CostEstimate;\r\n}\r\n\r\nexport class DeploymentAnalyzer {\r\n  private platformStrategies = new Map<string, PlatformStrategy>();\r\n\r\n  constructor() {\r\n    this.initializePlatformStrategies();\r\n  }\r\n\r\n  async analyzeProject(projectPath: string): Promise<DeploymentRequirements> {\r\n    const config = await this.loadFarmConfig(projectPath);\r\n    const packageJson = await this.loadPackageJson(projectPath);\r\n    const codeAnalysis = await this.analyzeCodebase(projectPath);\r\n\r\n    return {\r\n      hasAI: config.features?.includes(\"ai\") || false,\r\n      aiProviders: this.extractAIProviders(config),\r\n      hasRealtime:\r\n        config.features?.includes(\"realtime\") || codeAnalysis.hasWebSockets,\r\n      hasDatabase: !!config.database,\r\n      hasFileStorage:\r\n        config.features?.includes(\"storage\") || codeAnalysis.hasFileUploads,\r\n\r\n      expectedTraffic: this.estimateTraffic(codeAnalysis),\r\n      latencyRequirements: this.determineLatencyNeeds(config),\r\n      scalingNeeds: this.determineScalingNeeds(codeAnalysis),\r\n\r\n      regions: config.deployment?.regions || [\"us-east-1\"],\r\n      globalCDN: codeAnalysis.hasStaticAssets || codeAnalysis.hasMediaContent,\r\n\r\n      budgetTier: this.determineBudgetTier(config.deployment),\r\n      costOptimization: config.deployment?.costOptimization !== false,\r\n    };\r\n  }\r\n\r\n  async recommendDeployment(\r\n    requirements: DeploymentRequirements\r\n  ): Promise<DeploymentRecommendation> {\r\n    const platformScores = new Map<string, PlatformScore>();\r\n\r\n    // Score each platform based on requirements\r\n    for (const [platform, strategy] of this.platformStrategies) {\r\n      const score = await strategy.calculateScore(requirements);\r\n      platformScores.set(platform, score);\r\n    }\r\n\r\n    // Get best platform\r\n    const bestPlatform = this.findBestPlatform(platformScores);\r\n    const platformStrategy = this.platformStrategies.get(bestPlatform)!;\r\n\r\n    // Generate architecture recommendation\r\n    const architecture = await platformStrategy.generateArchitecture(\r\n      requirements\r\n    );\r\n\r\n    // Calculate alternatives\r\n    const alternatives = await this.generateAlternatives(\r\n      platformScores,\r\n      requirements\r\n    );\r\n\r\n    // Estimate costs\r\n    const estimatedCost = await platformStrategy.estimateCost(\r\n      architecture,\r\n      requirements\r\n    );\r\n\r\n    return {\r\n      platform: bestPlatform as DeploymentPlatform,\r\n      architecture,\r\n      confidence: platformScores.get(bestPlatform)!.confidence,\r\n      reasoning: platformScores.get(bestPlatform)!.reasoning,\r\n      alternatives,\r\n      estimatedCost,\r\n    };\r\n  }\r\n\r\n  private extractAIProviders(\r\n    config: FarmConfig\r\n  ): (\"ollama\" | \"openai\" | \"huggingface\")[] {\r\n    const providers: (\"ollama\" | \"openai\" | \"huggingface\")[] = [];\r\n\r\n    if (config.ai?.providers?.ollama?.enabled) providers.push(\"ollama\");\r\n    if (config.ai?.providers?.openai?.enabled) providers.push(\"openai\");\r\n    if (config.ai?.providers?.huggingface?.enabled)\r\n      providers.push(\"huggingface\");\r\n\r\n    return providers;\r\n  }\r\n\r\n  private async analyzeCodebase(\r\n    projectPath: string\r\n  ): Promise<CodebaseAnalysis> {\r\n    // Static analysis of codebase to understand requirements\r\n    return {\r\n      hasWebSockets: await this.scanForWebSockets(projectPath),\r\n      hasFileUploads: await this.scanForFileUploads(projectPath),\r\n      hasStaticAssets: await this.scanForStaticAssets(projectPath),\r\n      hasMediaContent: await this.scanForMediaContent(projectPath),\r\n      complexityScore: await this.calculateComplexity(projectPath),\r\n      performanceCritical: await this.identifyPerformancePaths(projectPath),\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n### 2. Platform Adapter System\r\n\r\n**Multi-Platform Deployment Abstraction:**\r\n\r\n```typescript\r\n// tools/deployment/platforms/base.ts\r\nexport abstract class PlatformStrategy {\r\n  abstract name: string;\r\n  abstract capabilities: PlatformCapabilities;\r\n\r\n  abstract calculateScore(\r\n    requirements: DeploymentRequirements\r\n  ): Promise<PlatformScore>;\r\n  abstract generateArchitecture(\r\n    requirements: DeploymentRequirements\r\n  ): Promise<DeploymentArchitecture>;\r\n  abstract deploy(\r\n    architecture: DeploymentArchitecture,\r\n    options: DeployOptions\r\n  ): Promise<DeploymentResult>;\r\n  abstract estimateCost(\r\n    architecture: DeploymentArchitecture,\r\n    requirements: DeploymentRequirements\r\n  ): Promise<CostEstimate>;\r\n\r\n  protected validateRequirements(\r\n    requirements: DeploymentRequirements\r\n  ): ValidationResult {\r\n    const issues: string[] = [];\r\n\r\n    // Check AI provider compatibility\r\n    if (requirements.hasAI && requirements.aiProviders.includes(\"ollama\")) {\r\n      if (!this.capabilities.supportsContainers) {\r\n        issues.push(\r\n          \"Platform does not support containers required for Ollama deployment\"\r\n        );\r\n      }\r\n    }\r\n\r\n    // Check realtime requirements\r\n    if (requirements.hasRealtime && !this.capabilities.supportsWebSockets) {\r\n      issues.push(\"Platform does not support WebSockets for realtime features\");\r\n    }\r\n\r\n    // Check database requirements\r\n    if (\r\n      requirements.hasDatabase &&\r\n      !this.capabilities.supportsDatabases.includes(\"mongodb\")\r\n    ) {\r\n      issues.push(\"Platform does not support MongoDB\");\r\n    }\r\n\r\n    return {\r\n      valid: issues.length === 0,\r\n      issues,\r\n    };\r\n  }\r\n\r\n  protected generateEnvironmentConfig(\r\n    requirements: DeploymentRequirements\r\n  ): EnvironmentConfig {\r\n    const config: EnvironmentConfig = {\r\n      NODE_ENV: \"production\",\r\n      API_URL: this.generateAPIUrl(),\r\n    };\r\n\r\n    // AI provider configuration\r\n    if (requirements.hasAI) {\r\n      // Disable Ollama in production, enable cloud providers\r\n      config.AI_PROVIDER = this.getPreferredAIProvider(\r\n        requirements.aiProviders\r\n      );\r\n\r\n      if (requirements.aiProviders.includes(\"openai\")) {\r\n        config.OPENAI_API_KEY = \"${OPENAI_API_KEY}\"; // Template for secrets\r\n      }\r\n    }\r\n\r\n    // Database configuration\r\n    if (requirements.hasDatabase) {\r\n      config.DATABASE_URL = this.generateDatabaseUrl();\r\n    }\r\n\r\n    return config;\r\n  }\r\n\r\n  private getPreferredAIProvider(providers: string[]): string {\r\n    // Prefer cloud providers in production\r\n    if (providers.includes(\"openai\")) return \"openai\";\r\n    if (providers.includes(\"huggingface\")) return \"huggingface\";\r\n    return providers[0]; // Fallback\r\n  }\r\n}\r\n```\r\n\r\n### 3. Vercel Platform Strategy\r\n\r\n**Optimized for JAMstack and Edge Functions:**\r\n\r\n```typescript\r\n// tools/deployment/platforms/vercel.ts\r\nexport class VercelStrategy extends PlatformStrategy {\r\n  name = \"vercel\";\r\n  capabilities: PlatformCapabilities = {\r\n    supportsContainers: false,\r\n    supportsWebSockets: true,\r\n    supportsEdgeFunctions: true,\r\n    supportsDatabases: [\"mongodb-atlas\", \"planetscale\", \"neon\"],\r\n    supportsStaticSites: true,\r\n    globalCDN: true,\r\n    autoScaling: true,\r\n    freeTeir: true,\r\n  };\r\n\r\n  async calculateScore(\r\n    requirements: DeploymentRequirements\r\n  ): Promise<PlatformScore> {\r\n    let score = 0;\r\n    const reasoning: string[] = [];\r\n\r\n    // Excellent for static sites and serverless\r\n    if (!requirements.hasAI || !requirements.aiProviders.includes(\"ollama\")) {\r\n      score += 30;\r\n      reasoning.push(\r\n        \"Excellent fit for serverless AI applications (OpenAI/HuggingFace)\"\r\n      );\r\n    } else {\r\n      score -= 20;\r\n      reasoning.push(\"Cannot run Ollama locally - requires cloud AI providers\");\r\n    }\r\n\r\n    // Great for frontend-heavy applications\r\n    score += 25;\r\n    reasoning.push(\"Exceptional frontend performance with global CDN\");\r\n\r\n    // Good for low-medium traffic\r\n    if (requirements.expectedTraffic !== \"enterprise\") {\r\n      score += 20;\r\n      reasoning.push(\"Cost-effective for startup/growth stage applications\");\r\n    }\r\n\r\n    // Perfect for global distribution\r\n    if (requirements.globalCDN) {\r\n      score += 15;\r\n      reasoning.push(\"Built-in global CDN and edge optimization\");\r\n    }\r\n\r\n    // Database limitations\r\n    if (requirements.hasDatabase) {\r\n      score += 10; // Can use Atlas\r\n      reasoning.push(\"Integrates well with MongoDB Atlas\");\r\n    }\r\n\r\n    return {\r\n      score,\r\n      confidence: score > 70 ? 0.9 : 0.7,\r\n      reasoning,\r\n    };\r\n  }\r\n\r\n  async generateArchitecture(\r\n    requirements: DeploymentRequirements\r\n  ): Promise<DeploymentArchitecture> {\r\n    return {\r\n      platform: \"vercel\",\r\n      components: {\r\n        frontend: {\r\n          type: \"static-site\",\r\n          framework: \"nextjs\",\r\n          buildCommand: \"npm run build\",\r\n          outputDirectory: \"apps/web/dist\",\r\n          environmentVariables: this.generateFrontendEnv(requirements),\r\n        },\r\n        backend: {\r\n          type: \"serverless-functions\",\r\n          runtime: \"python3.9\",\r\n          functions: await this.generateServerlessFunctions(requirements),\r\n          environmentVariables: this.generateBackendEnv(requirements),\r\n        },\r\n        database: requirements.hasDatabase\r\n          ? {\r\n              type: \"mongodb-atlas\",\r\n              tier: this.selectAtlasTier(requirements),\r\n              region: requirements.regions[0],\r\n            }\r\n          : undefined,\r\n        ai: requirements.hasAI\r\n          ? {\r\n              type: \"cloud-api\",\r\n              providers: requirements.aiProviders.filter((p) => p !== \"ollama\"),\r\n              edgeFunctions: true,\r\n            }\r\n          : undefined,\r\n      },\r\n      routing: {\r\n        rules: [\r\n          {\r\n            source: \"/api/(.*)\",\r\n            destination: \"/api/$1\",\r\n            headers: { \"Cache-Control\": \"no-cache\" },\r\n          },\r\n          {\r\n            source: \"/(.*)\",\r\n            destination: \"/index.html\",\r\n            headers: { \"Cache-Control\": \"public, max-age=31536000\" },\r\n          },\r\n        ],\r\n      },\r\n    };\r\n  }\r\n\r\n  async deploy(\r\n    architecture: DeploymentArchitecture,\r\n    options: DeployOptions\r\n  ): Promise<DeploymentResult> {\r\n    try {\r\n      // Generate Vercel configuration\r\n      await this.generateVercelConfig(architecture);\r\n\r\n      // Setup database if needed\r\n      if (architecture.components.database) {\r\n        await this.setupMongoDBAtlas(architecture.components.database);\r\n      }\r\n\r\n      // Deploy via Vercel CLI\r\n      const deployResult = await this.runVercelDeploy(options);\r\n\r\n      // Setup custom domain if specified\r\n      if (options.customDomain) {\r\n        await this.setupCustomDomain(options.customDomain);\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        url: deployResult.url,\r\n        deploymentId: deployResult.deploymentId,\r\n        buildLogs: deployResult.logs,\r\n        postDeployment: {\r\n          databaseUrl: architecture.components.database?.connectionString,\r\n          cdnEndpoints: deployResult.cdnEndpoints,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        buildLogs: error.logs,\r\n      };\r\n    }\r\n  }\r\n\r\n  private async generateServerlessFunctions(\r\n    requirements: DeploymentRequirements\r\n  ): Promise<ServerlessFunction[]> {\r\n    const functions: ServerlessFunction[] = [];\r\n\r\n    // Main API function\r\n    functions.push({\r\n      name: \"api\",\r\n      path: \"/api\",\r\n      handler: \"apps/api/src/main.py\",\r\n      runtime: \"python3.9\",\r\n      memory: 1024,\r\n      timeout: 30,\r\n      environment: this.generateBackendEnv(requirements),\r\n    });\r\n\r\n    // AI-specific functions if needed\r\n    if (requirements.hasAI) {\r\n      functions.push({\r\n        name: \"ai-chat\",\r\n        path: \"/api/ai/chat\",\r\n        handler: \"apps/api/src/ai/chat_handler.py\",\r\n        runtime: \"python3.9\",\r\n        memory: 2048,\r\n        timeout: 60, // Longer timeout for AI responses\r\n        environment: {\r\n          ...this.generateBackendEnv(requirements),\r\n          AI_OPTIMIZED: \"true\",\r\n        },\r\n      });\r\n    }\r\n\r\n    return functions;\r\n  }\r\n\r\n  private async generateVercelConfig(\r\n    architecture: DeploymentArchitecture\r\n  ): Promise<void> {\r\n    const config = {\r\n      version: 2,\r\n      name: \"farm-app\",\r\n      builds: [\r\n        {\r\n          src: \"apps/web/package.json\",\r\n          use: \"@vercel/next\",\r\n        },\r\n        {\r\n          src: \"apps/api/src/**/*.py\",\r\n          use: \"@vercel/python\",\r\n        },\r\n      ],\r\n      routes: architecture.routing.rules,\r\n      env: {\r\n        ...architecture.components.frontend.environmentVariables,\r\n        ...architecture.components.backend.environmentVariables,\r\n      },\r\n      functions: {\r\n        \"apps/api/src/main.py\": {\r\n          memory: 1024,\r\n          maxDuration: 30,\r\n        },\r\n      },\r\n    };\r\n\r\n    await fs.writeJSON(path.join(process.cwd(), \"vercel.json\"), config, {\r\n      spaces: 2,\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n### 4. AWS Platform Strategy\r\n\r\n**Full-Scale Cloud Infrastructure:**\r\n\r\n```typescript\r\n// tools/deployment/platforms/aws.ts\r\nexport class AWSStrategy extends PlatformStrategy {\r\n  name = \"aws\";\r\n  capabilities: PlatformCapabilities = {\r\n    supportsContainers: true,\r\n    supportsWebSockets: true,\r\n    supportsEdgeFunctions: true,\r\n    supportsDatabases: [\"mongodb-atlas\", \"documentdb\", \"rds\"],\r\n    supportsStaticSites: true,\r\n    globalCDN: true,\r\n    autoScaling: true,\r\n    freeTeir: true,\r\n    customInfrastructure: true,\r\n    gpuSupport: true,\r\n  };\r\n\r\n  async generateArchitecture(\r\n    requirements: DeploymentRequirements\r\n  ): Promise<DeploymentArchitecture> {\r\n    const useContainers =\r\n      requirements.hasAI && requirements.aiProviders.includes(\"ollama\");\r\n\r\n    return {\r\n      platform: \"aws\",\r\n      components: {\r\n        frontend: {\r\n          type: \"static-site\",\r\n          service: \"s3-cloudfront\",\r\n          buildCommand: \"npm run build\",\r\n          outputDirectory: \"apps/web/dist\",\r\n          cdn: {\r\n            enabled: true,\r\n            cachingRules: this.generateCachingRules(),\r\n            gzipCompression: true,\r\n          },\r\n        },\r\n        backend: useContainers\r\n          ? {\r\n              type: \"container\",\r\n              service: \"ecs-fargate\",\r\n              dockerfile: \"Dockerfile.production\",\r\n              scaling: {\r\n                min: 1,\r\n                max: 10,\r\n                targetCPU: 70,\r\n              },\r\n              loadBalancer: {\r\n                type: \"application\",\r\n                healthCheck: \"/health\",\r\n              },\r\n            }\r\n          : {\r\n              type: \"serverless\",\r\n              service: \"lambda\",\r\n              runtime: \"python3.9\",\r\n              functions: await this.generateLambdaFunctions(requirements),\r\n            },\r\n        database: this.selectDatabaseStrategy(requirements),\r\n        ai: requirements.hasAI\r\n          ? this.generateAIArchitecture(requirements)\r\n          : undefined,\r\n      },\r\n      infrastructure: {\r\n        vpc: {\r\n          cidr: \"10.0.0.0/16\",\r\n          subnets: {\r\n            public: [\"10.0.1.0/24\", \"10.0.2.0/24\"],\r\n            private: [\"10.0.10.0/24\", \"10.0.20.0/24\"],\r\n          },\r\n        },\r\n        security: {\r\n          securityGroups: this.generateSecurityGroups(),\r\n          iamRoles: this.generateIAMRoles(requirements),\r\n        },\r\n      },\r\n    };\r\n  }\r\n\r\n  private generateAIArchitecture(\r\n    requirements: DeploymentRequirements\r\n  ): AIArchitecture {\r\n    if (requirements.aiProviders.includes(\"ollama\")) {\r\n      // Container-based deployment for Ollama\r\n      return {\r\n        type: \"hybrid\",\r\n        local: {\r\n          service: \"ecs-fargate\",\r\n          instanceType: \"g4dn.xlarge\", // GPU instance\r\n          scaling: {\r\n            min: 1,\r\n            max: 3,\r\n          },\r\n          models: this.getOllamaModels(requirements),\r\n        },\r\n        cloud: {\r\n          providers: requirements.aiProviders.filter((p) => p !== \"ollama\"),\r\n          routing: {\r\n            development: \"local\",\r\n            production: \"cloud\",\r\n          },\r\n        },\r\n      };\r\n    } else {\r\n      // Pure cloud AI\r\n      return {\r\n        type: \"cloud-only\",\r\n        providers: requirements.aiProviders,\r\n        optimization: {\r\n          caching: true,\r\n          edgeLocations: true,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  async deploy(\r\n    architecture: DeploymentArchitecture,\r\n    options: DeployOptions\r\n  ): Promise<DeploymentResult> {\r\n    try {\r\n      // Generate CloudFormation/CDK templates\r\n      const infrastructureTemplate = await this.generateInfrastructureTemplate(\r\n        architecture\r\n      );\r\n\r\n      // Deploy infrastructure\r\n      const infraResult = await this.deployInfrastructure(\r\n        infrastructureTemplate,\r\n        options\r\n      );\r\n\r\n      // Deploy application\r\n      const appResult = await this.deployApplication(\r\n        architecture,\r\n        infraResult,\r\n        options\r\n      );\r\n\r\n      // Setup monitoring and logging\r\n      await this.setupMonitoring(architecture, appResult);\r\n\r\n      return {\r\n        success: true,\r\n        url: appResult.applicationUrl,\r\n        deploymentId: appResult.deploymentId,\r\n        infrastructure: {\r\n          vpcId: infraResult.vpcId,\r\n          loadBalancerArn: infraResult.loadBalancerArn,\r\n          databaseEndpoint: infraResult.databaseEndpoint,\r\n        },\r\n        monitoring: {\r\n          dashboardUrl: appResult.monitoring.dashboardUrl,\r\n          logsGroup: appResult.monitoring.logsGroup,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        rollback: await this.performRollback(error.context),\r\n      };\r\n    }\r\n  }\r\n\r\n  private async generateInfrastructureTemplate(\r\n    architecture: DeploymentArchitecture\r\n  ): Promise<CloudFormationTemplate> {\r\n    // Generate comprehensive AWS infrastructure as code\r\n    return {\r\n      AWSTemplateFormatVersion: \"2010-09-09\",\r\n      Description: \"FARM Stack Infrastructure\",\r\n      Resources: {\r\n        // VPC and networking\r\n        ...this.generateNetworkingResources(architecture.infrastructure.vpc),\r\n\r\n        // Security groups and IAM roles\r\n        ...this.generateSecurityResources(architecture.infrastructure.security),\r\n\r\n        // Application infrastructure\r\n        ...this.generateApplicationResources(architecture.components),\r\n\r\n        // Database resources\r\n        ...this.generateDatabaseResources(architecture.components.database),\r\n\r\n        // AI/ML resources\r\n        ...this.generateAIResources(architecture.components.ai),\r\n      },\r\n      Outputs: this.generateOutputs(),\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n### 5. Railway Platform Strategy\r\n\r\n**Developer-Friendly Container Platform:**\r\n\r\n```typescript\r\n// tools/deployment/platforms/railway.ts\r\nexport class RailwayStrategy extends PlatformStrategy {\r\n  name = \"railway\";\r\n  capabilities: PlatformCapabilities = {\r\n    supportsContainers: true,\r\n    supportsWebSockets: true,\r\n    supportsEdgeFunctions: false,\r\n    supportsDatabases: [\"postgresql\", \"mongodb\", \"redis\"],\r\n    supportsStaticSites: true,\r\n    globalCDN: false,\r\n    autoScaling: true,\r\n    freeTeir: true,\r\n    easySetup: true,\r\n  };\r\n\r\n  async calculateScore(\r\n    requirements: DeploymentRequirements\r\n  ): Promise<PlatformScore> {\r\n    let score = 0;\r\n    const reasoning: string[] = [];\r\n\r\n    // Excellent for Ollama deployment\r\n    if (requirements.hasAI && requirements.aiProviders.includes(\"ollama\")) {\r\n      score += 35;\r\n      reasoning.push(\"Perfect for Ollama deployment with container support\");\r\n    }\r\n\r\n    // Great for development/staging\r\n    if (requirements.budgetTier === \"startup\") {\r\n      score += 25;\r\n      reasoning.push(\"Cost-effective for early-stage applications\");\r\n    }\r\n\r\n    // Good for simple architectures\r\n    if (\r\n      !requirements.hasRealtime ||\r\n      requirements.expectedTraffic !== \"enterprise\"\r\n    ) {\r\n      score += 20;\r\n      reasoning.push(\"Simple deployment model for standard applications\");\r\n    }\r\n\r\n    // Built-in database support\r\n    if (requirements.hasDatabase) {\r\n      score += 15;\r\n      reasoning.push(\"Integrated database services\");\r\n    }\r\n\r\n    // Limited global reach\r\n    if (requirements.regions.length > 1) {\r\n      score -= 10;\r\n      reasoning.push(\"Limited multi-region deployment options\");\r\n    }\r\n\r\n    return {\r\n      score,\r\n      confidence: score > 60 ? 0.8 : 0.6,\r\n      reasoning,\r\n    };\r\n  }\r\n\r\n  async generateArchitecture(\r\n    requirements: DeploymentRequirements\r\n  ): Promise<DeploymentArchitecture> {\r\n    return {\r\n      platform: \"railway\",\r\n      components: {\r\n        frontend: {\r\n          type: \"static-site\",\r\n          buildCommand: \"npm run build\",\r\n          outputDirectory: \"apps/web/dist\",\r\n          environmentVariables: this.generateFrontendEnv(requirements),\r\n        },\r\n        backend: {\r\n          type: \"container\",\r\n          dockerfile: \"Dockerfile\",\r\n          port: 8000,\r\n          scaling: {\r\n            replicas: requirements.expectedTraffic === \"high\" ? 3 : 1,\r\n            memory: \"1GB\",\r\n            cpu: \"1vCPU\",\r\n          },\r\n          environmentVariables: this.generateBackendEnv(requirements),\r\n        },\r\n        database: requirements.hasDatabase\r\n          ? {\r\n              type: \"railway-mongodb\",\r\n              plan: this.selectDatabasePlan(requirements),\r\n            }\r\n          : undefined,\r\n        ai:\r\n          requirements.hasAI && requirements.aiProviders.includes(\"ollama\")\r\n            ? {\r\n                type: \"container\",\r\n                service: \"ollama\",\r\n                dockerfile: \"Dockerfile.ollama\",\r\n                scaling: {\r\n                  replicas: 1,\r\n                  memory: \"4GB\",\r\n                  cpu: \"2vCPU\",\r\n                },\r\n                volumes: [\"/root/.ollama\"],\r\n              }\r\n            : undefined,\r\n      },\r\n      services: this.generateRailwayServices(requirements),\r\n    };\r\n  }\r\n\r\n  async deploy(\r\n    architecture: DeploymentArchitecture,\r\n    options: DeployOptions\r\n  ): Promise<DeploymentResult> {\r\n    try {\r\n      // Generate railway.json configuration\r\n      await this.generateRailwayConfig(architecture);\r\n\r\n      // Create Railway project\r\n      const project = await this.createRailwayProject(options.projectName);\r\n\r\n      // Deploy services in order\r\n      const deployResults = await this.deployServices(architecture, project);\r\n\r\n      // Setup environment variables\r\n      await this.setupEnvironmentVariables(architecture, deployResults);\r\n\r\n      // Configure networking\r\n      await this.configureNetworking(architecture, deployResults);\r\n\r\n      return {\r\n        success: true,\r\n        url: deployResults.frontend.url,\r\n        services: deployResults,\r\n        projectId: project.id,\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        cleanup: await this.cleanupFailedDeployment(error.context),\r\n      };\r\n    }\r\n  }\r\n\r\n  private generateRailwayServices(\r\n    requirements: DeploymentRequirements\r\n  ): RailwayService[] {\r\n    const services: RailwayService[] = [];\r\n\r\n    // Frontend service\r\n    services.push({\r\n      name: \"frontend\",\r\n      type: \"static\",\r\n      buildCommand: \"cd apps/web && npm run build\",\r\n      outputDirectory: \"apps/web/dist\",\r\n    });\r\n\r\n    // Backend service\r\n    services.push({\r\n      name: \"backend\",\r\n      type: \"web\",\r\n      dockerfile: \"apps/api/Dockerfile\",\r\n      port: 8000,\r\n      variables: this.generateBackendEnv(requirements),\r\n    });\r\n\r\n    // Database service\r\n    if (requirements.hasDatabase) {\r\n      services.push({\r\n        name: \"database\",\r\n        type: \"database\",\r\n        engine: \"mongodb\",\r\n        version: \"6.0\",\r\n      });\r\n    }\r\n\r\n    // Ollama service for AI\r\n    if (requirements.hasAI && requirements.aiProviders.includes(\"ollama\")) {\r\n      services.push({\r\n        name: \"ollama\",\r\n        type: \"web\",\r\n        dockerfile: \"Dockerfile.ollama\",\r\n        port: 11434,\r\n        variables: {\r\n          OLLAMA_HOST: \"0.0.0.0:11434\",\r\n          OLLAMA_KEEP_ALIVE: \"-1\",\r\n        },\r\n      });\r\n    }\r\n\r\n    return services;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## AI-Aware Deployment Strategies\r\n\r\n### 1. AI Provider Migration System\r\n\r\n**Seamless AI Provider Transition:**\r\n\r\n```typescript\r\n// tools/deployment/ai-migration.ts\r\nexport class AIProviderMigration {\r\n  async migrateAIConfiguration(\r\n    sourceConfig: AIConfig,\r\n    targetPlatform: DeploymentPlatform\r\n  ): Promise<MigrationPlan> {\r\n    const plan: MigrationPlan = {\r\n      provider: this.selectOptimalProvider(sourceConfig, targetPlatform),\r\n      configuration: {},\r\n      environmentVariables: {},\r\n      warnings: [],\r\n      actions: [],\r\n    };\r\n\r\n    // Handle Ollama to cloud migration\r\n    if (\r\n      sourceConfig.providers?.ollama?.enabled &&\r\n      !this.platformSupportsOllama(targetPlatform)\r\n    ) {\r\n      plan.warnings.push(\r\n        \"Ollama not supported on target platform - migrating to cloud provider\"\r\n      );\r\n\r\n      // Recommend cloud alternative\r\n      if (sourceConfig.providers?.openai?.enabled) {\r\n        plan.provider = \"openai\";\r\n        plan.configuration = sourceConfig.providers.openai;\r\n        plan.environmentVariables.OPENAI_API_KEY = \"${OPENAI_API_KEY}\";\r\n        plan.actions.push(\"Configure OpenAI API key in deployment environment\");\r\n      } else if (sourceConfig.providers?.huggingface?.enabled) {\r\n        plan.provider = \"huggingface\";\r\n        plan.configuration = sourceConfig.providers.huggingface;\r\n        plan.environmentVariables.HUGGINGFACE_TOKEN = \"${HUGGINGFACE_TOKEN}\";\r\n        plan.actions.push(\r\n          \"Configure HuggingFace token in deployment environment\"\r\n        );\r\n      } else {\r\n        // Suggest adding cloud provider\r\n        plan.warnings.push(\r\n          \"No cloud AI provider configured - please add OpenAI or HuggingFace configuration\"\r\n        );\r\n        plan.actions.push(\"Add cloud AI provider to farm.config.ts\");\r\n        plan.actions.push(\"Configure API keys in deployment environment\");\r\n      }\r\n    }\r\n\r\n    // Handle cloud to container migration\r\n    if (\r\n      !sourceConfig.providers?.ollama?.enabled &&\r\n      this.platformSupportsOllama(targetPlatform)\r\n    ) {\r\n      plan.actions.push(\r\n        \"Consider enabling Ollama for cost-effective AI inference\"\r\n      );\r\n      plan.configuration = {\r\n        ...plan.configuration,\r\n        ollama: {\r\n          enabled: true,\r\n          url: \"http://ollama:11434\",\r\n          models: [\"llama3.1\"],\r\n          defaultModel: \"llama3.1\",\r\n        },\r\n      };\r\n    }\r\n\r\n    return plan;\r\n  }\r\n\r\n  async generateAIDeploymentInstructions(\r\n    migrationPlan: MigrationPlan,\r\n    platform: DeploymentPlatform\r\n  ): Promise<string[]> {\r\n    const instructions: string[] = [];\r\n\r\n    instructions.push(\"# AI Provider Deployment Configuration\");\r\n    instructions.push(\"\");\r\n\r\n    if (migrationPlan.provider === \"ollama\") {\r\n      instructions.push(\"## Ollama Container Deployment\");\r\n      instructions.push(\"1. Ensure your platform supports Docker containers\");\r\n      instructions.push(\r\n        \"2. Configure GPU instance if available for better performance\"\r\n      );\r\n      instructions.push(\"3. Set up persistent storage for model caching\");\r\n      instructions.push(\"4. Configure auto-scaling based on inference load\");\r\n    } else {\r\n      instructions.push(\r\n        `## ${migrationPlan.provider.toUpperCase()} Cloud Deployment`\r\n      );\r\n      instructions.push(\"1. Obtain API credentials from provider\");\r\n      instructions.push(\"2. Configure environment variables securely\");\r\n      instructions.push(\"3. Set up request rate limiting and monitoring\");\r\n      instructions.push(\"4. Configure cost alerts and usage tracking\");\r\n    }\r\n\r\n    instructions.push(\"\");\r\n    instructions.push(\"## Environment Variables\");\r\n    for (const [key, value] of Object.entries(\r\n      migrationPlan.environmentVariables\r\n    )) {\r\n      instructions.push(`${key}=${value}`);\r\n    }\r\n\r\n    if (migrationPlan.warnings.length > 0) {\r\n      instructions.push(\"\");\r\n      instructions.push(\"## Warnings\");\r\n      migrationPlan.warnings.forEach((warning) => {\r\n        instructions.push(`⚠️ ${warning}`);\r\n      });\r\n    }\r\n\r\n    return instructions;\r\n  }\r\n}\r\n```\r\n\r\n### 2. Model Deployment Optimizer\r\n\r\n**Intelligent AI Model Selection and Deployment:**\r\n\r\n```typescript\r\n// tools/deployment/ai-optimizer.ts\r\nexport class AIModelOptimizer {\r\n  async optimizeModelSelection(\r\n    requirements: DeploymentRequirements,\r\n    platform: DeploymentPlatform\r\n  ): Promise<ModelOptimizationPlan> {\r\n    const plan: ModelOptimizationPlan = {\r\n      recommendedModels: [],\r\n      deployment: {},\r\n      performance: {},\r\n      cost: {},\r\n    };\r\n\r\n    if (platform === \"aws\" || platform === \"gcp\") {\r\n      // Use GPU instances for Ollama\r\n      plan.recommendedModels = [\r\n        {\r\n          name: \"llama3.1\",\r\n          size: \"8B\",\r\n          provider: \"ollama\",\r\n          hardware: \"gpu\",\r\n          memory: \"8GB\",\r\n          estimatedLatency: \"100ms\",\r\n        },\r\n      ];\r\n\r\n      plan.deployment.instanceType = \"g4dn.xlarge\";\r\n      plan.deployment.scaling = {\r\n        min: 1,\r\n        max: 3,\r\n        targetLatency: \"200ms\",\r\n      };\r\n    } else if (platform === \"vercel\" || platform === \"netlify\") {\r\n      // Use cloud APIs for serverless\r\n      plan.recommendedModels = [\r\n        {\r\n          name: \"gpt-3.5-turbo\",\r\n          provider: \"openai\",\r\n          hardware: \"cloud\",\r\n          estimatedLatency: \"500ms\",\r\n          costPerRequest: \"$0.001\",\r\n        },\r\n      ];\r\n\r\n      plan.deployment.type = \"edge-function\";\r\n      plan.deployment.regions = [\"global\"];\r\n    } else if (platform === \"railway\") {\r\n      // Balance cost and performance\r\n      plan.recommendedModels = [\r\n        {\r\n          name: \"phi3\",\r\n          size: \"3.8B\",\r\n          provider: \"ollama\",\r\n          hardware: \"cpu\",\r\n          memory: \"4GB\",\r\n          estimatedLatency: \"300ms\",\r\n        },\r\n      ];\r\n\r\n      plan.deployment.instanceType = \"shared-cpu-4gb\";\r\n      plan.deployment.scaling = { replicas: 1 };\r\n    }\r\n\r\n    return plan;\r\n  }\r\n\r\n  async generateModelDeploymentConfig(\r\n    plan: ModelOptimizationPlan\r\n  ): Promise<ModelDeploymentConfig> {\r\n    return {\r\n      containers: plan.recommendedModels\r\n        .filter((model) => model.provider === \"ollama\")\r\n        .map((model) => ({\r\n          name: `ollama-${model.name}`,\r\n          image: \"ollama/ollama:latest\",\r\n          environment: {\r\n            OLLAMA_HOST: \"0.0.0.0:11434\",\r\n            OLLAMA_KEEP_ALIVE: \"-1\",\r\n          },\r\n          resources: {\r\n            memory: model.memory,\r\n            cpu: model.hardware === \"gpu\" ? \"4000m\" : \"2000m\",\r\n          },\r\n          volumes: [\"/root/.ollama\"],\r\n          initCommands: [`ollama pull ${model.name}`],\r\n        })),\r\n\r\n      cloudProviders: plan.recommendedModels\r\n        .filter((model) => model.provider !== \"ollama\")\r\n        .map((model) => ({\r\n          provider: model.provider,\r\n          model: model.name,\r\n          configuration: {\r\n            maxTokens: 1000,\r\n            temperature: 0.7,\r\n            timeout: 30000,\r\n          },\r\n        })),\r\n\r\n      loadBalancing: plan.deployment.scaling\r\n        ? {\r\n            strategy: \"round-robin\",\r\n            healthCheck: \"/api/ai/health\",\r\n            failover: true,\r\n          }\r\n        : undefined,\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Build Optimization Pipeline\r\n\r\n### 1. Multi-Stage Build System\r\n\r\n**Optimized Production Builds:**\r\n\r\n```typescript\r\n// tools/deployment/build-optimizer.ts\r\nexport class BuildOptimizer {\r\n  async generateOptimizedBuild(\r\n    requirements: DeploymentRequirements,\r\n    platform: DeploymentPlatform\r\n  ): Promise<BuildConfiguration> {\r\n    const config: BuildConfiguration = {\r\n      frontend: await this.optimizeFrontendBuild(requirements, platform),\r\n      backend: await this.optimizeBackendBuild(requirements, platform),\r\n      assets: await this.optimizeAssets(requirements),\r\n      docker:\r\n        platform !== \"vercel\"\r\n          ? await this.generateDockerfiles(requirements)\r\n          : undefined,\r\n    };\r\n\r\n    return config;\r\n  }\r\n\r\n  private async optimizeFrontendBuild(\r\n    requirements: DeploymentRequirements,\r\n    platform: DeploymentPlatform\r\n  ): Promise<FrontendBuildConfig> {\r\n    const config: FrontendBuildConfig = {\r\n      framework: \"vite\",\r\n      target: \"es2020\",\r\n      sourcemap: false,\r\n      minify: true,\r\n      treeshaking: true,\r\n      codesplitting: true,\r\n      bundleAnalysis: true,\r\n    };\r\n\r\n    // Platform-specific optimizations\r\n    if (platform === \"vercel\") {\r\n      config.output = \"static\";\r\n      config.prerender = true;\r\n      config.edgeOptimization = true;\r\n    } else if (platform === \"aws\") {\r\n      config.output = \"static\";\r\n      config.gzipCompression = true;\r\n      config.brotliCompression = true;\r\n    }\r\n\r\n    // AI-specific optimizations\r\n    if (requirements.hasAI) {\r\n      config.chunks = {\r\n        ai: [\"src/services/ai\", \"src/hooks/ai\"],\r\n        vendor: [\"react\", \"react-dom\"],\r\n        app: [\"src/main\"],\r\n      };\r\n\r\n      config.preload = [\"ai-provider\", \"streaming-utils\"];\r\n    }\r\n\r\n    return config;\r\n  }\r\n\r\n  private async optimizeBackendBuild(\r\n    requirements: DeploymentRequirements,\r\n    platform: DeploymentPlatform\r\n  ): Promise<BackendBuildConfig> {\r\n    const config: BackendBuildConfig = {\r\n      runtime: \"python3.9\",\r\n      dependencies: \"requirements.txt\",\r\n      optimization: \"production\",\r\n      excludeDevDependencies: true,\r\n    };\r\n\r\n    // Container-based platforms\r\n    if (platform === \"aws\" || platform === \"railway\") {\r\n      config.containerOptimization = {\r\n        multiStage: true,\r\n        baseImage: \"python:3.9-slim\",\r\n        alpineVariant: true,\r\n        layerCaching: true,\r\n      };\r\n    }\r\n\r\n    // Serverless platforms\r\n    if (platform === \"vercel\") {\r\n      config.bundling = {\r\n        excludeFiles: [\"tests/\", \"*.pyc\", \"__pycache__/\"],\r\n        minifyPython: true,\r\n        treeshaking: true,\r\n      };\r\n    }\r\n\r\n    // AI-specific optimizations\r\n    if (requirements.hasAI) {\r\n      config.aiOptimization = {\r\n        excludeOllamaInProduction: platform !== \"aws\" && platform !== \"railway\",\r\n        precompileAIModules: true,\r\n        optimizeImports: true,\r\n      };\r\n\r\n      if (requirements.aiProviders.includes(\"ollama\")) {\r\n        config.additionalDependencies = [\r\n          \"torch==2.0.0+cpu\",\r\n          \"transformers\",\r\n          \"accelerate\",\r\n        ];\r\n      }\r\n    }\r\n\r\n    return config;\r\n  }\r\n\r\n  private async generateDockerfiles(\r\n    requirements: DeploymentRequirements\r\n  ): Promise<DockerConfiguration> {\r\n    const dockerfiles: DockerConfiguration = {};\r\n\r\n    // Main application Dockerfile\r\n    dockerfiles.main = this.generateMainDockerfile(requirements);\r\n\r\n    // Ollama Dockerfile if needed\r\n    if (requirements.hasAI && requirements.aiProviders.includes(\"ollama\")) {\r\n      dockerfiles.ollama = this.generateOllamaDockerfile(requirements);\r\n    }\r\n\r\n    // Docker Compose for local development\r\n    dockerfiles.compose = this.generateDockerCompose(requirements);\r\n\r\n    // Production Docker Compose\r\n    dockerfiles.production = this.generateProductionCompose(requirements);\r\n\r\n    return dockerfiles;\r\n  }\r\n\r\n  private generateMainDockerfile(requirements: DeploymentRequirements): string {\r\n    return `\r\n# Multi-stage Dockerfile for FARM application\r\nFROM node:18-alpine AS frontend-builder\r\n\r\nWORKDIR /app\r\nCOPY apps/web/package*.json ./apps/web/\r\nRUN cd apps/web && npm ci --only=production\r\n\r\nCOPY apps/web ./apps/web/\r\nRUN cd apps/web && npm run build\r\n\r\n# Python backend stage\r\nFROM python:3.9-slim AS backend\r\n\r\nWORKDIR /app\r\n\r\n# Install system dependencies\r\nRUN apt-get update && apt-get install -y \\\\\r\n    gcc \\\\\r\n    && rm -rf /var/lib/apt/lists/*\r\n\r\n# Install Python dependencies\r\nCOPY apps/api/requirements.txt ./\r\nRUN pip install --no-cache-dir -r requirements.txt\r\n\r\n# Copy application code\r\nCOPY apps/api ./\r\nCOPY --from=frontend-builder /app/apps/web/dist ./static\r\n\r\n# Create non-root user\r\nRUN useradd --create-home --shell /bin/bash app \\\\\r\n    && chown -R app:app /app\r\nUSER app\r\n\r\n# Health check\r\nHEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\\\r\n    CMD curl -f http://localhost:8000/health || exit 1\r\n\r\nEXPOSE 8000\r\n\r\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\r\n`;\r\n  }\r\n\r\n  private generateOllamaDockerfile(\r\n    requirements: DeploymentRequirements\r\n  ): string {\r\n    const models = requirements.aiProviders.includes(\"ollama\")\r\n      ? [\"llama3.1\", \"codestral\"]\r\n      : [\"llama3.1\"];\r\n\r\n    return `\r\n# Ollama container with pre-loaded models\r\nFROM ollama/ollama:latest\r\n\r\n# Pre-pull models during build\r\n${models.map((model) => `RUN ollama pull ${model}`).join(\"\\n\")}\r\n\r\n# Configure Ollama\r\nENV OLLAMA_HOST=0.0.0.0:11434\r\nENV OLLAMA_KEEP_ALIVE=-1\r\n\r\nEXPOSE 11434\r\n\r\n# Health check\r\nHEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \\\\\r\n    CMD curl -f http://localhost:11434/api/tags || exit 1\r\n\r\nCMD [\"ollama\", \"serve\"]\r\n`;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Environment Configuration Management\r\n\r\n### 1. Environment Variable Management\r\n\r\n**Secure Configuration Deployment:**\r\n\r\n```typescript\r\n// tools/deployment/env-manager.ts\r\nexport class EnvironmentManager {\r\n  async generateEnvironmentConfig(\r\n    architecture: DeploymentArchitecture,\r\n    platform: DeploymentPlatform,\r\n    stage: \"development\" | \"staging\" | \"production\"\r\n  ): Promise<EnvironmentConfiguration> {\r\n    const config: EnvironmentConfiguration = {\r\n      platform,\r\n      stage,\r\n      variables: {},\r\n      secrets: {},\r\n      validation: {},\r\n    };\r\n\r\n    // Base configuration\r\n    config.variables = {\r\n      NODE_ENV: stage,\r\n      API_URL: this.generateAPIUrl(architecture, platform),\r\n      FRONTEND_URL: this.generateFrontendUrl(architecture, platform),\r\n    };\r\n\r\n    // Database configuration\r\n    if (architecture.components.database) {\r\n      const dbConfig = this.generateDatabaseConfig(\r\n        architecture.components.database,\r\n        platform,\r\n        stage\r\n      );\r\n      config.variables = { ...config.variables, ...dbConfig.variables };\r\n      config.secrets = { ...config.secrets, ...dbConfig.secrets };\r\n    }\r\n\r\n    // AI configuration\r\n    if (architecture.components.ai) {\r\n      const aiConfig = this.generateAIConfig(\r\n        architecture.components.ai,\r\n        platform,\r\n        stage\r\n      );\r\n      config.variables = { ...config.variables, ...aiConfig.variables };\r\n      config.secrets = { ...config.secrets, ...aiConfig.secrets };\r\n    }\r\n\r\n    // Platform-specific configuration\r\n    config.variables = {\r\n      ...config.variables,\r\n      ...this.generatePlatformSpecificConfig(platform, stage),\r\n    };\r\n\r\n    // Generate validation rules\r\n    config.validation = this.generateValidationRules(config);\r\n\r\n    return config;\r\n  }\r\n\r\n  private generateAIConfig(\r\n    aiComponent: AIArchitecture,\r\n    platform: DeploymentPlatform,\r\n    stage: string\r\n  ): { variables: Record<string, string>; secrets: Record<string, string> } {\r\n    const variables: Record<string, string> = {};\r\n    const secrets: Record<string, string> = {};\r\n\r\n    if (aiComponent.type === \"hybrid\" && stage === \"production\") {\r\n      // Use cloud providers in production\r\n      variables.AI_PROVIDER = \"openai\";\r\n      secrets.OPENAI_API_KEY = \"${OPENAI_API_KEY}\";\r\n    } else if (aiComponent.type === \"hybrid\" && stage === \"development\") {\r\n      // Use Ollama in development\r\n      variables.AI_PROVIDER = \"ollama\";\r\n      variables.OLLAMA_URL = \"http://ollama:11434\";\r\n    } else if (aiComponent.type === \"cloud-only\") {\r\n      // Cloud-only configuration\r\n      if (aiComponent.providers?.includes(\"openai\")) {\r\n        variables.AI_PROVIDER = \"openai\";\r\n        secrets.OPENAI_API_KEY = \"${OPENAI_API_KEY}\";\r\n      }\r\n\r\n      if (aiComponent.providers?.includes(\"huggingface\")) {\r\n        variables.AI_FALLBACK_PROVIDER = \"huggingface\";\r\n        secrets.HUGGINGFACE_TOKEN = \"${HUGGINGFACE_TOKEN}\";\r\n      }\r\n    }\r\n\r\n    // AI optimization settings\r\n    variables.AI_MAX_TOKENS = \"1000\";\r\n    variables.AI_TEMPERATURE = \"0.7\";\r\n    variables.AI_TIMEOUT = \"30000\";\r\n\r\n    if (stage === \"production\") {\r\n      variables.AI_CACHE_ENABLED = \"true\";\r\n      variables.AI_RATE_LIMITING = \"true\";\r\n    }\r\n\r\n    return { variables, secrets };\r\n  }\r\n\r\n  async deployEnvironmentConfig(\r\n    config: EnvironmentConfiguration,\r\n    platform: DeploymentPlatform,\r\n    deploymentId: string\r\n  ): Promise<void> {\r\n    switch (platform) {\r\n      case \"vercel\":\r\n        await this.deployVercelEnvironment(config, deploymentId);\r\n        break;\r\n      case \"aws\":\r\n        await this.deployAWSEnvironment(config, deploymentId);\r\n        break;\r\n      case \"railway\":\r\n        await this.deployRailwayEnvironment(config, deploymentId);\r\n        break;\r\n      default:\r\n        throw new Error(\r\n          `Environment deployment not supported for platform: ${platform}`\r\n        );\r\n    }\r\n  }\r\n\r\n  private async deployVercelEnvironment(\r\n    config: EnvironmentConfiguration,\r\n    deploymentId: string\r\n  ): Promise<void> {\r\n    const vercelClient = new VercelAPI();\r\n\r\n    // Set environment variables\r\n    for (const [key, value] of Object.entries(config.variables)) {\r\n      await vercelClient.setEnvironmentVariable(\r\n        deploymentId,\r\n        key,\r\n        value,\r\n        \"production\"\r\n      );\r\n    }\r\n\r\n    // Set secrets (requires manual setup instructions)\r\n    if (Object.keys(config.secrets).length > 0) {\r\n      console.log(\"\\n🔒 Please set the following secrets in Vercel dashboard:\");\r\n      for (const [key, placeholder] of Object.entries(config.secrets)) {\r\n        console.log(\r\n          `   ${key}: ${placeholder.replace(\"${\", \"\").replace(\"}\", \"\")}`\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private async deployAWSEnvironment(\r\n    config: EnvironmentConfiguration,\r\n    deploymentId: string\r\n  ): Promise<void> {\r\n    // Use AWS Systems Manager Parameter Store for configuration\r\n    const ssmClient = new AWS.SSM();\r\n\r\n    // Store variables as parameters\r\n    for (const [key, value] of Object.entries(config.variables)) {\r\n      await ssmClient\r\n        .putParameter({\r\n          Name: `/farm/${deploymentId}/${key}`,\r\n          Value: value,\r\n          Type: \"String\",\r\n          Overwrite: true,\r\n        })\r\n        .promise();\r\n    }\r\n\r\n    // Store secrets in AWS Secrets Manager\r\n    const secretsClient = new AWS.SecretsManager();\r\n\r\n    if (Object.keys(config.secrets).length > 0) {\r\n      await secretsClient\r\n        .createSecret({\r\n          Name: `farm/${deploymentId}/secrets`,\r\n          SecretString: JSON.stringify(config.secrets),\r\n        })\r\n        .promise();\r\n    }\r\n  }\r\n\r\n  async validateEnvironment(\r\n    config: EnvironmentConfiguration\r\n  ): Promise<ValidationResult> {\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n\r\n    // Validate required variables\r\n    for (const [key, rule] of Object.entries(config.validation)) {\r\n      const value = config.variables[key] || config.secrets[key];\r\n\r\n      if (rule.required && !value) {\r\n        errors.push(`Required environment variable ${key} is missing`);\r\n      }\r\n\r\n      if (value && rule.pattern && !new RegExp(rule.pattern).test(value)) {\r\n        errors.push(\r\n          `Environment variable ${key} does not match required pattern`\r\n        );\r\n      }\r\n\r\n      if (value && rule.type === \"url\" && !this.isValidUrl(value)) {\r\n        errors.push(`Environment variable ${key} is not a valid URL`);\r\n      }\r\n    }\r\n\r\n    // AI-specific validations\r\n    if (\r\n      config.variables.AI_PROVIDER === \"openai\" &&\r\n      !config.secrets.OPENAI_API_KEY\r\n    ) {\r\n      errors.push(\"OpenAI API key is required when using OpenAI provider\");\r\n    }\r\n\r\n    if (\r\n      config.variables.AI_PROVIDER === \"ollama\" &&\r\n      !config.variables.OLLAMA_URL\r\n    ) {\r\n      warnings.push(\r\n        \"Ollama URL not specified - using default http://localhost:11434\"\r\n      );\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Deployment CLI Integration\r\n\r\n### 1. Unified Deployment Commands\r\n\r\n**CLI Commands for Deployment:**\r\n\r\n```bash\r\n# Deployment analysis and recommendations\r\nfarm deploy analyze                    # Analyze project and recommend deployment strategy\r\nfarm deploy recommend --budget startup # Get deployment recommendations for budget tier\r\n\r\n# Platform-specific deployment\r\nfarm deploy --platform vercel         # Deploy to Vercel with optimal configuration\r\nfarm deploy --platform aws            # Deploy to AWS with full infrastructure\r\nfarm deploy --platform railway        # Deploy to Railway with containers\r\nfarm deploy --platform docker         # Generate Docker configuration\r\n\r\n# Deployment with specific options\r\nfarm deploy --platform vercel --stage staging --ai-provider openai\r\nfarm deploy --platform aws --regions us-east-1,eu-west-1 --auto-scale\r\n\r\n# Environment management\r\nfarm deploy env list                   # List environment configurations\r\nfarm deploy env validate              # Validate environment configuration\r\nfarm deploy env migrate --from dev --to prod  # Migrate environment settings\r\n\r\n# Deployment monitoring\r\nfarm deploy status                     # Check deployment status\r\nfarm deploy logs --follow              # Stream deployment logs\r\nfarm deploy rollback                   # Rollback to previous deployment\r\n\r\n# AI-specific deployment commands\r\nfarm deploy ai analyze                 # Analyze AI requirements and costs\r\nfarm deploy ai migrate --from ollama --to openai  # Migrate AI providers\r\nfarm deploy ai optimize                # Optimize AI model deployment\r\n```\r\n\r\n### 2. Deployment Command Implementation\r\n\r\n**CLI Deployment Integration:**\r\n\r\n```typescript\r\n// packages/cli/src/commands/deploy.ts\r\nexport async function deployCommand(options: DeployOptions) {\r\n  const deployer = new FarmDeployer();\r\n\r\n  try {\r\n    console.log(\"🚀 Starting FARM application deployment...\\n\");\r\n\r\n    // Step 1: Analyze project\r\n    console.log(\"📊 Analyzing project requirements...\");\r\n    const analyzer = new DeploymentAnalyzer();\r\n    const requirements = await analyzer.analyzeProject(process.cwd());\r\n\r\n    // Step 2: Get deployment recommendation or use specified platform\r\n    let recommendation: DeploymentRecommendation;\r\n\r\n    if (options.platform) {\r\n      console.log(`🎯 Using specified platform: ${options.platform}`);\r\n      recommendation = await analyzer.getRecommendationForPlatform(\r\n        options.platform,\r\n        requirements\r\n      );\r\n    } else {\r\n      console.log(\"🤔 Getting deployment recommendations...\");\r\n      recommendation = await analyzer.recommendDeployment(requirements);\r\n\r\n      // Show recommendation to user\r\n      console.log(`\\n💡 Recommended platform: ${recommendation.platform}`);\r\n      console.log(\r\n        `   Confidence: ${(recommendation.confidence * 100).toFixed(0)}%`\r\n      );\r\n      console.log(\"   Reasoning:\");\r\n      recommendation.reasoning.forEach((reason) => {\r\n        console.log(`   • ${reason}`);\r\n      });\r\n\r\n      if (!options.autoConfirm) {\r\n        const confirmed = await prompts({\r\n          type: \"confirm\",\r\n          name: \"proceed\",\r\n          message: `Proceed with ${recommendation.platform} deployment?`,\r\n          initial: true,\r\n        });\r\n\r\n        if (!confirmed.proceed) {\r\n          console.log(\"Deployment cancelled\");\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Step 3: Handle AI provider migration if needed\r\n    if (requirements.hasAI) {\r\n      console.log(\"🤖 Configuring AI deployment...\");\r\n      const aiMigration = new AIProviderMigration();\r\n      const migrationPlan = await aiMigration.migrateAIConfiguration(\r\n        requirements.aiConfig,\r\n        recommendation.platform\r\n      );\r\n\r\n      if (migrationPlan.warnings.length > 0) {\r\n        console.log(\"\\n⚠️  AI Configuration Warnings:\");\r\n        migrationPlan.warnings.forEach((warning) => {\r\n          console.log(`   ${warning}`);\r\n        });\r\n      }\r\n\r\n      if (migrationPlan.actions.length > 0) {\r\n        console.log(\"\\n📋 Required Actions:\");\r\n        migrationPlan.actions.forEach((action) => {\r\n          console.log(`   • ${action}`);\r\n        });\r\n      }\r\n    }\r\n\r\n    // Step 4: Generate optimized build\r\n    console.log(\"🔧 Optimizing build configuration...\");\r\n    const buildOptimizer = new BuildOptimizer();\r\n    const buildConfig = await buildOptimizer.generateOptimizedBuild(\r\n      requirements,\r\n      recommendation.platform\r\n    );\r\n\r\n    // Step 5: Deploy to platform\r\n    console.log(`🚀 Deploying to ${recommendation.platform}...`);\r\n    const platformStrategy = deployer.getPlatformStrategy(\r\n      recommendation.platform\r\n    );\r\n\r\n    const deployResult = await platformStrategy.deploy(\r\n      recommendation.architecture,\r\n      {\r\n        projectName: options.projectName || path.basename(process.cwd()),\r\n        stage: options.stage || \"production\",\r\n        customDomain: options.domain,\r\n        autoConfirm: options.autoConfirm,\r\n      }\r\n    );\r\n\r\n    // Step 6: Handle deployment result\r\n    if (deployResult.success) {\r\n      console.log(\"\\n🎉 Deployment successful!\\n\");\r\n      console.log(`🌐 Application URL: ${deployResult.url}`);\r\n\r\n      if (deployResult.infrastructure) {\r\n        console.log(\"🏗️  Infrastructure:\");\r\n        Object.entries(deployResult.infrastructure).forEach(([key, value]) => {\r\n          console.log(`   ${key}: ${value}`);\r\n        });\r\n      }\r\n\r\n      if (deployResult.monitoring) {\r\n        console.log(\"📊 Monitoring:\");\r\n        Object.entries(deployResult.monitoring).forEach(([key, value]) => {\r\n          console.log(`   ${key}: ${value}`);\r\n        });\r\n      }\r\n\r\n      // Show post-deployment actions\r\n      await showPostDeploymentActions(\r\n        requirements,\r\n        recommendation.platform,\r\n        deployResult\r\n      );\r\n    } else {\r\n      console.error(\"❌ Deployment failed:\", deployResult.error);\r\n\r\n      if (deployResult.buildLogs) {\r\n        console.log(\"\\n📝 Build logs:\");\r\n        console.log(deployResult.buildLogs);\r\n      }\r\n\r\n      if (deployResult.rollback) {\r\n        console.log(\"\\n🔄 Rollback initiated\");\r\n      }\r\n\r\n      process.exit(1);\r\n    }\r\n  } catch (error) {\r\n    console.error(\"💥 Deployment error:\", error.message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nasync function showPostDeploymentActions(\r\n  requirements: DeploymentRequirements,\r\n  platform: DeploymentPlatform,\r\n  deployResult: DeploymentResult\r\n): Promise<void> {\r\n  console.log(\"\\n📋 Next Steps:\");\r\n\r\n  // AI-specific actions\r\n  if (requirements.hasAI) {\r\n    if (requirements.aiProviders.includes(\"openai\")) {\r\n      console.log(\"   🤖 Configure OpenAI API key in deployment environment\");\r\n    }\r\n\r\n    if (platform === \"aws\" && requirements.aiProviders.includes(\"ollama\")) {\r\n      console.log(\r\n        \"   🐳 Ollama container will auto-pull models on first start\"\r\n      );\r\n      console.log(\"   📈 Monitor GPU usage and scale instances as needed\");\r\n    }\r\n  }\r\n\r\n  // Database actions\r\n  if (requirements.hasDatabase) {\r\n    console.log(\"   🗄️  Database connection string available in environment\");\r\n    console.log(\"   📊 Set up database monitoring and backups\");\r\n  }\r\n\r\n  // Security actions\r\n  console.log(\"   🔒 Review and configure security settings\");\r\n  console.log(\"   📊 Set up monitoring and alerts\");\r\n\r\n  // Custom domain\r\n  if (!deployResult.url.includes(platform)) {\r\n    console.log(\"   🌐 Configure custom domain and SSL certificate\");\r\n  }\r\n\r\n  console.log(\"\\n📚 Documentation: https://farm-framework.dev/deployment\");\r\n}\r\n```\r\n\r\n---\r\n\r\n## Monitoring and Rollback Strategies\r\n\r\n### 1. Deployment Health Monitoring\r\n\r\n**Automated Health Checks and Monitoring:**\r\n\r\n```typescript\r\n// tools/deployment/monitoring.ts\r\nexport class DeploymentMonitor {\r\n  async setupMonitoring(\r\n    architecture: DeploymentArchitecture,\r\n    platform: DeploymentPlatform,\r\n    deploymentId: string\r\n  ): Promise<MonitoringConfiguration> {\r\n    const config: MonitoringConfiguration = {\r\n      healthChecks: this.generateHealthChecks(architecture),\r\n      metrics: this.generateMetrics(architecture),\r\n      alerts: this.generateAlerts(architecture),\r\n      dashboards: await this.generateDashboards(architecture, platform),\r\n    };\r\n\r\n    // Deploy monitoring configuration\r\n    await this.deployMonitoring(config, platform, deploymentId);\r\n\r\n    return config;\r\n  }\r\n\r\n  private generateHealthChecks(\r\n    architecture: DeploymentArchitecture\r\n  ): HealthCheck[] {\r\n    const checks: HealthCheck[] = [];\r\n\r\n    // Frontend health check\r\n    checks.push({\r\n      name: \"frontend\",\r\n      url: \"/health\",\r\n      interval: 30,\r\n      timeout: 10,\r\n      retries: 3,\r\n      expected: { status: 200 },\r\n    });\r\n\r\n    // Backend health check\r\n    checks.push({\r\n      name: \"backend\",\r\n      url: \"/api/health\",\r\n      interval: 30,\r\n      timeout: 10,\r\n      retries: 3,\r\n      expected: {\r\n        status: 200,\r\n        body: { status: \"healthy\" },\r\n      },\r\n    });\r\n\r\n    // Database health check\r\n    if (architecture.components.database) {\r\n      checks.push({\r\n        name: \"database\",\r\n        url: \"/api/health/database\",\r\n        interval: 60,\r\n        timeout: 15,\r\n        retries: 3,\r\n        expected: {\r\n          status: 200,\r\n          body: { database: \"connected\" },\r\n        },\r\n      });\r\n    }\r\n\r\n    // AI health check\r\n    if (architecture.components.ai) {\r\n      checks.push({\r\n        name: \"ai-service\",\r\n        url: \"/api/ai/health\",\r\n        interval: 60,\r\n        timeout: 30, // AI can be slower\r\n        retries: 2,\r\n        expected: {\r\n          status: 200,\r\n          body: { ai: \"available\" },\r\n        },\r\n      });\r\n    }\r\n\r\n    return checks;\r\n  }\r\n\r\n  private generateMetrics(\r\n    architecture: DeploymentArchitecture\r\n  ): MetricConfiguration[] {\r\n    const metrics: MetricConfiguration[] = [\r\n      // Application metrics\r\n      {\r\n        name: \"response_time\",\r\n        type: \"histogram\",\r\n        description: \"Response time for API requests\",\r\n        labels: [\"method\", \"endpoint\", \"status_code\"],\r\n      },\r\n      {\r\n        name: \"request_count\",\r\n        type: \"counter\",\r\n        description: \"Total number of requests\",\r\n        labels: [\"method\", \"endpoint\", \"status_code\"],\r\n      },\r\n      {\r\n        name: \"active_connections\",\r\n        type: \"gauge\",\r\n        description: \"Number of active connections\",\r\n      },\r\n    ];\r\n\r\n    // AI-specific metrics\r\n    if (architecture.components.ai) {\r\n      metrics.push(\r\n        {\r\n          name: \"ai_inference_time\",\r\n          type: \"histogram\",\r\n          description: \"Time taken for AI inference\",\r\n          labels: [\"provider\", \"model\"],\r\n        },\r\n        {\r\n          name: \"ai_token_usage\",\r\n          type: \"counter\",\r\n          description: \"Number of tokens used\",\r\n          labels: [\"provider\", \"model\", \"type\"],\r\n        },\r\n        {\r\n          name: \"ai_model_memory\",\r\n          type: \"gauge\",\r\n          description: \"Memory usage by AI models\",\r\n          labels: [\"model\"],\r\n        }\r\n      );\r\n    }\r\n\r\n    // Database metrics\r\n    if (architecture.components.database) {\r\n      metrics.push(\r\n        {\r\n          name: \"db_connection_pool\",\r\n          type: \"gauge\",\r\n          description: \"Database connection pool usage\",\r\n        },\r\n        {\r\n          name: \"db_query_time\",\r\n          type: \"histogram\",\r\n          description: \"Database query execution time\",\r\n          labels: [\"collection\", \"operation\"],\r\n        }\r\n      );\r\n    }\r\n\r\n    return metrics;\r\n  }\r\n\r\n  private generateAlerts(\r\n    architecture: DeploymentArchitecture\r\n  ): AlertConfiguration[] {\r\n    const alerts: AlertConfiguration[] = [\r\n      // Critical alerts\r\n      {\r\n        name: \"service_down\",\r\n        condition: \"up == 0\",\r\n        severity: \"critical\",\r\n        duration: \"1m\",\r\n        message: \"Service {{$labels.service}} is down\",\r\n      },\r\n      {\r\n        name: \"high_error_rate\",\r\n        condition: 'rate(request_count{status_code=~\"5..\"}[5m]) > 0.1',\r\n        severity: \"warning\",\r\n        duration: \"5m\",\r\n        message: \"High error rate detected: {{$value}} errors/sec\",\r\n      },\r\n      {\r\n        name: \"high_response_time\",\r\n        condition: \"histogram_quantile(0.95, response_time) > 2\",\r\n        severity: \"warning\",\r\n        duration: \"10m\",\r\n        message: \"95th percentile response time is {{$value}}s\",\r\n      },\r\n    ];\r\n\r\n    // AI-specific alerts\r\n    if (architecture.components.ai) {\r\n      alerts.push(\r\n        {\r\n          name: \"ai_service_unavailable\",\r\n          condition: 'up{service=\"ai\"} == 0',\r\n          severity: \"critical\",\r\n          duration: \"2m\",\r\n          message: \"AI service is unavailable\",\r\n        },\r\n        {\r\n          name: \"ai_high_latency\",\r\n          condition: \"histogram_quantile(0.95, ai_inference_time) > 30\",\r\n          severity: \"warning\",\r\n          duration: \"5m\",\r\n          message: \"AI inference latency is high: {{$value}}s\",\r\n        },\r\n        {\r\n          name: \"ai_model_memory_high\",\r\n          condition: \"ai_model_memory > 8000000000\", // 8GB\r\n          severity: \"warning\",\r\n          duration: \"5m\",\r\n          message: \"AI model memory usage is high: {{$value}} bytes\",\r\n        }\r\n      );\r\n    }\r\n\r\n    return alerts;\r\n  }\r\n}\r\n```\r\n\r\n### 2. Automated Rollback System\r\n\r\n**Intelligent Rollback and Recovery:**\r\n\r\n```typescript\r\n// tools/deployment/rollback.ts\r\nexport class RollbackManager {\r\n  async setupRollbackStrategy(\r\n    architecture: DeploymentArchitecture,\r\n    platform: DeploymentPlatform\r\n  ): Promise<RollbackConfiguration> {\r\n    return {\r\n      strategy: this.selectRollbackStrategy(platform),\r\n      triggers: this.generateRollbackTriggers(architecture),\r\n      validation: this.generateRollbackValidation(architecture),\r\n      recovery: this.generateRecoveryPlan(architecture),\r\n    };\r\n  }\r\n\r\n  async performRollback(\r\n    deploymentId: string,\r\n    reason: string,\r\n    platform: DeploymentPlatform\r\n  ): Promise<RollbackResult> {\r\n    console.log(`🔄 Initiating rollback for deployment ${deploymentId}`);\r\n    console.log(`   Reason: ${reason}`);\r\n\r\n    try {\r\n      // Step 1: Validate rollback feasibility\r\n      const validation = await this.validateRollback(deploymentId, platform);\r\n      if (!validation.canRollback) {\r\n        throw new Error(`Cannot rollback: ${validation.reason}`);\r\n      }\r\n\r\n      // Step 2: Get previous stable deployment\r\n      const previousDeployment = await this.getPreviousStableDeployment(\r\n        deploymentId,\r\n        platform\r\n      );\r\n      if (!previousDeployment) {\r\n        throw new Error(\"No previous stable deployment found\");\r\n      }\r\n\r\n      // Step 3: Perform platform-specific rollback\r\n      const rollbackResult = await this.performPlatformRollback(\r\n        deploymentId,\r\n        previousDeployment.id,\r\n        platform\r\n      );\r\n\r\n      // Step 4: Verify rollback success\r\n      const verification = await this.verifyRollback(\r\n        previousDeployment.id,\r\n        platform\r\n      );\r\n\r\n      if (verification.success) {\r\n        console.log(\"✅ Rollback completed successfully\");\r\n\r\n        // Step 5: Update deployment status\r\n        await this.updateDeploymentStatus(deploymentId, \"rolled_back\", reason);\r\n\r\n        return {\r\n          success: true,\r\n          rolledBackTo: previousDeployment.id,\r\n          verificationResults: verification.checks,\r\n        };\r\n      } else {\r\n        throw new Error(\"Rollback verification failed\");\r\n      }\r\n    } catch (error) {\r\n      console.error(\"❌ Rollback failed:\", error.message);\r\n\r\n      // Attempt emergency recovery\r\n      const recovery = await this.attemptEmergencyRecovery(\r\n        deploymentId,\r\n        platform\r\n      );\r\n\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        emergencyRecovery: recovery,\r\n      };\r\n    }\r\n  }\r\n\r\n  private async performPlatformRollback(\r\n    currentDeploymentId: string,\r\n    targetDeploymentId: string,\r\n    platform: DeploymentPlatform\r\n  ): Promise<void> {\r\n    switch (platform) {\r\n      case \"vercel\":\r\n        await this.rollbackVercelDeployment(\r\n          currentDeploymentId,\r\n          targetDeploymentId\r\n        );\r\n        break;\r\n      case \"aws\":\r\n        await this.rollbackAWSDeployment(\r\n          currentDeploymentId,\r\n          targetDeploymentId\r\n        );\r\n        break;\r\n      case \"railway\":\r\n        await this.rollbackRailwayDeployment(\r\n          currentDeploymentId,\r\n          targetDeploymentId\r\n        );\r\n        break;\r\n      default:\r\n        throw new Error(`Rollback not supported for platform: ${platform}`);\r\n    }\r\n  }\r\n\r\n  private async rollbackVercelDeployment(\r\n    currentId: string,\r\n    targetId: string\r\n  ): Promise<void> {\r\n    const vercelClient = new VercelAPI();\r\n\r\n    // Promote previous deployment to production\r\n    await vercelClient.promoteDeployment(targetId);\r\n\r\n    // Update aliases\r\n    await vercelClient.updateAlias(targetId);\r\n\r\n    // Wait for propagation\r\n    await this.waitForDeploymentPropagation(targetId, \"vercel\");\r\n  }\r\n\r\n  private async rollbackAWSDeployment(\r\n    currentId: string,\r\n    targetId: string\r\n  ): Promise<void> {\r\n    // AWS rollback using CodeDeploy or ECS service update\r\n    const ecs = new AWS.ECS();\r\n\r\n    // Get previous task definition\r\n    const previousTaskDef = await this.getPreviousTaskDefinition(targetId);\r\n\r\n    // Update service to use previous task definition\r\n    await ecs\r\n      .updateService({\r\n        serviceName: \"farm-backend\",\r\n        taskDefinition: previousTaskDef.taskDefinitionArn,\r\n        forceNewDeployment: true,\r\n      })\r\n      .promise();\r\n\r\n    // Wait for deployment to complete\r\n    await this.waitForECSDeployment(\"farm-backend\");\r\n\r\n    // Rollback CloudFront distribution if needed\r\n    await this.rollbackCloudFrontDistribution(targetId);\r\n  }\r\n\r\n  private async verifyRollback(\r\n    deploymentId: string,\r\n    platform: DeploymentPlatform\r\n  ): Promise<VerificationResult> {\r\n    const checks: VerificationCheck[] = [];\r\n\r\n    // Health check verification\r\n    const healthResult = await this.performHealthChecks(deploymentId);\r\n    checks.push({\r\n      name: \"health_checks\",\r\n      passed: healthResult.allPassed,\r\n      details: healthResult.results,\r\n    });\r\n\r\n    // Performance verification\r\n    const perfResult = await this.performPerformanceChecks(deploymentId);\r\n    checks.push({\r\n      name: \"performance\",\r\n      passed: perfResult.acceptable,\r\n      details: perfResult.metrics,\r\n    });\r\n\r\n    // AI service verification (if applicable)\r\n    if (await this.hasAIComponents(deploymentId)) {\r\n      const aiResult = await this.performAIServiceChecks(deploymentId);\r\n      checks.push({\r\n        name: \"ai_services\",\r\n        passed: aiResult.functional,\r\n        details: aiResult.providerStatus,\r\n      });\r\n    }\r\n\r\n    const allPassed = checks.every((check) => check.passed);\r\n\r\n    return {\r\n      success: allPassed,\r\n      checks,\r\n      timestamp: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  private generateRollbackTriggers(\r\n    architecture: DeploymentArchitecture\r\n  ): RollbackTrigger[] {\r\n    const triggers: RollbackTrigger[] = [\r\n      // Health check failures\r\n      {\r\n        name: \"health_check_failure\",\r\n        condition: \"health_check_failures >= 3\",\r\n        timeout: \"5m\",\r\n        autoRollback: true,\r\n      },\r\n\r\n      // High error rate\r\n      {\r\n        name: \"high_error_rate\",\r\n        condition: \"error_rate > 0.1 for 5m\",\r\n        timeout: \"10m\",\r\n        autoRollback: true,\r\n      },\r\n\r\n      // Performance degradation\r\n      {\r\n        name: \"performance_degradation\",\r\n        condition: \"response_time_p95 > 5s for 10m\",\r\n        timeout: \"15m\",\r\n        autoRollback: false, // Manual approval required\r\n      },\r\n    ];\r\n\r\n    // AI-specific triggers\r\n    if (architecture.components.ai) {\r\n      triggers.push(\r\n        {\r\n          name: \"ai_service_failure\",\r\n          condition: \"ai_service_availability < 0.9 for 5m\",\r\n          timeout: \"10m\",\r\n          autoRollback: true,\r\n        },\r\n        {\r\n          name: \"ai_inference_timeout\",\r\n          condition: \"ai_inference_timeout_rate > 0.2 for 5m\",\r\n          timeout: \"10m\",\r\n          autoRollback: false,\r\n        }\r\n      );\r\n    }\r\n\r\n    return triggers;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n_Status: ✅ Completed - Ready for implementation_\r\n\r\nThis comprehensive deployment pipeline architecture provides:\r\n\r\n- **Multi-platform deployment strategies** with intelligent platform selection\r\n- **AI-aware deployment** handling Ollama-to-cloud transitions seamlessly\r\n- **Build optimization** with platform-specific optimizations\r\n- **Environment management** with secure configuration deployment\r\n- **Monitoring and alerting** with AI-specific metrics\r\n- **Automated rollback** with verification and recovery strategies\r\n- **CLI integration** for streamlined deployment workflows\r\n",
      "excerpt": "The FARM deployment pipeline provides intelligent, multi-platform deployment strategies that automatically adapt based on application requirements, AI provider ...",
      "category": "architectural-sketches-detailed/phase3",
      "type": "reference",
      "tags": [
        "react",
        "mongodb",
        "farm",
        "typescript",
        "python"
      ],
      "lastModified": "2025-06-12T21:57:32.783Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase3",
        "Deployment_pipeline_architecture"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Deployment Pipeline Structure",
          "id": "deployment-pipeline-structure"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "High-Level Deployment Architecture",
          "id": "high-level-deployment-architecture"
        },
        {
          "level": 2,
          "text": "Core Deployment Components",
          "id": "core-deployment-components"
        },
        {
          "level": 3,
          "text": "1. Deployment Analysis Engine",
          "id": "1-deployment-analysis-engine"
        },
        {
          "level": 3,
          "text": "2. Platform Adapter System",
          "id": "2-platform-adapter-system"
        },
        {
          "level": 3,
          "text": "3. Vercel Platform Strategy",
          "id": "3-vercel-platform-strategy"
        },
        {
          "level": 3,
          "text": "4. AWS Platform Strategy",
          "id": "4-aws-platform-strategy"
        },
        {
          "level": 3,
          "text": "5. Railway Platform Strategy",
          "id": "5-railway-platform-strategy"
        },
        {
          "level": 2,
          "text": "AI-Aware Deployment Strategies",
          "id": "ai-aware-deployment-strategies"
        },
        {
          "level": 3,
          "text": "1. AI Provider Migration System",
          "id": "1-ai-provider-migration-system"
        },
        {
          "level": 3,
          "text": "2. Model Deployment Optimizer",
          "id": "2-model-deployment-optimizer"
        },
        {
          "level": 2,
          "text": "Build Optimization Pipeline",
          "id": "build-optimization-pipeline"
        },
        {
          "level": 3,
          "text": "1. Multi-Stage Build System",
          "id": "1-multi-stage-build-system"
        },
        {
          "level": 1,
          "text": "Multi-stage Dockerfile for FARM application",
          "id": "multi-stage-dockerfile-for-farm-application"
        },
        {
          "level": 1,
          "text": "Python backend stage",
          "id": "python-backend-stage"
        },
        {
          "level": 1,
          "text": "Install system dependencies",
          "id": "install-system-dependencies"
        },
        {
          "level": 1,
          "text": "Install Python dependencies",
          "id": "install-python-dependencies"
        },
        {
          "level": 1,
          "text": "Copy application code",
          "id": "copy-application-code"
        },
        {
          "level": 1,
          "text": "Create non-root user",
          "id": "create-non-root-user"
        },
        {
          "level": 1,
          "text": "Health check",
          "id": "health-check"
        },
        {
          "level": 1,
          "text": "Ollama container with pre-loaded models",
          "id": "ollama-container-with-pre-loaded-models"
        },
        {
          "level": 1,
          "text": "Pre-pull models during build",
          "id": "pre-pull-models-during-build"
        },
        {
          "level": 1,
          "text": "Configure Ollama",
          "id": "configure-ollama"
        },
        {
          "level": 1,
          "text": "Health check",
          "id": "health-check"
        },
        {
          "level": 2,
          "text": "Environment Configuration Management",
          "id": "environment-configuration-management"
        },
        {
          "level": 3,
          "text": "1. Environment Variable Management",
          "id": "1-environment-variable-management"
        },
        {
          "level": 2,
          "text": "Deployment CLI Integration",
          "id": "deployment-cli-integration"
        },
        {
          "level": 3,
          "text": "1. Unified Deployment Commands",
          "id": "1-unified-deployment-commands"
        },
        {
          "level": 1,
          "text": "Deployment analysis and recommendations",
          "id": "deployment-analysis-and-recommendations"
        },
        {
          "level": 1,
          "text": "Platform-specific deployment",
          "id": "platform-specific-deployment"
        },
        {
          "level": 1,
          "text": "Deployment with specific options",
          "id": "deployment-with-specific-options"
        },
        {
          "level": 1,
          "text": "Environment management",
          "id": "environment-management"
        },
        {
          "level": 1,
          "text": "Deployment monitoring",
          "id": "deployment-monitoring"
        },
        {
          "level": 1,
          "text": "AI-specific deployment commands",
          "id": "ai-specific-deployment-commands"
        },
        {
          "level": 3,
          "text": "2. Deployment Command Implementation",
          "id": "2-deployment-command-implementation"
        },
        {
          "level": 2,
          "text": "Monitoring and Rollback Strategies",
          "id": "monitoring-and-rollback-strategies"
        },
        {
          "level": 3,
          "text": "1. Deployment Health Monitoring",
          "id": "1-deployment-health-monitoring"
        },
        {
          "level": 3,
          "text": "2. Automated Rollback System",
          "id": "2-automated-rollback-system"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase3-performance_monitoring_design",
      "title": "Performance_monitoring_design",
      "url": "/architectural-sketches-detailed/phase3/performance_monitoring_design",
      "content": "# Performance & Monitoring Design\r\n\r\n## Overview\r\n\r\nFARM's performance and monitoring system provides comprehensive observability across the entire AI-first full-stack architecture. It monitors development workflows, AI provider performance, GPU utilization, cross-stack type generation, and production application metrics while optimizing for speed through pnpm package management and intelligent caching strategies.\r\n\r\n---\r\n\r\n## Multi-Layer Performance Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                 FARM Performance & Monitoring                   │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │Development  │  │   AI/ML     │  │Production   │  │Framework│ │\r\n│  │Performance  │  │Performance  │  │Monitoring   │  │Metrics  │ │\r\n│  │(Dev Server) │  │(GPU/Models) │  │(Apps)       │  │(Core)   │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │   pnpm      │  │ Hot Reload  │  │   Build     │  │  Type   │ │\r\n│  │Performance  │  │Performance  │  │Performance  │  │ GenPerf │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Metrics     │  │ Alerting    │  │ Dashboards  │  │ Reports │ │\r\n│  │ Collection  │  │ System      │  │ (Real-time) │  │ (Trends)│ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Performance Components\r\n\r\n### 1. Development Performance Optimization\r\n\r\n**Purpose:** Maximize developer productivity through optimized tooling and workflows\r\n\r\n**pnpm Integration & Optimization:**\r\n```javascript\r\n// packages/farm-core/src/performance/package-manager.js\r\nexport class PackageManager {\r\n  constructor() {\r\n    this.manager = 'pnpm'; // Default to pnpm for performance\r\n    this.cacheDir = '.farm/cache/pnpm';\r\n    this.metrics = new PerformanceMetrics();\r\n  }\r\n\r\n  async install(projectPath, options = {}) {\r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      // Configure pnpm for optimal performance\r\n      const pnpmConfig = {\r\n        'store-dir': path.join(os.homedir(), '.pnpm-store'),\r\n        'package-import-method': 'hardlink',\r\n        'symlink': false,\r\n        'hoist': true,\r\n        'shamefully-hoist': true, // For better compatibility\r\n        'prefer-offline': true,\r\n        'registry': options.registry || 'https://registry.npmjs.org'\r\n      };\r\n\r\n      // Create .npmrc for pnpm optimization\r\n      await this.createPnpmConfig(projectPath, pnpmConfig);\r\n\r\n      // Run pnpm install with performance optimizations\r\n      const result = await this.runPnpmInstall(projectPath, options);\r\n      \r\n      const duration = performance.now() - startTime;\r\n      this.metrics.recordInstallTime(duration, result.packageCount);\r\n      \r\n      return {\r\n        success: true,\r\n        duration,\r\n        packageCount: result.packageCount,\r\n        cacheHitRate: result.cacheHitRate\r\n      };\r\n      \r\n    } catch (error) {\r\n      const duration = performance.now() - startTime;\r\n      this.metrics.recordInstallError(error, duration);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async createPnpmConfig(projectPath, config) {\r\n    const npmrcPath = path.join(projectPath, '.npmrc');\r\n    const configLines = Object.entries(config)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('\\n');\r\n    \r\n    await fs.writeFile(npmrcPath, configLines);\r\n  }\r\n\r\n  async runPnpmInstall(projectPath, options) {\r\n    const args = ['install'];\r\n    \r\n    if (options.frozen) args.push('--frozen-lockfile');\r\n    if (options.production) args.push('--production');\r\n    if (options.offline) args.push('--prefer-offline');\r\n    \r\n    // Add performance flags\r\n    args.push('--reporter=silent'); // Reduce output overhead\r\n    args.push('--prefer-frozen-lockfile');\r\n    \r\n    const result = await execAsync('pnpm', args, { cwd: projectPath });\r\n    \r\n    // Parse pnpm output for metrics\r\n    return this.parsePnpmOutput(result.stdout);\r\n  }\r\n\r\n  parsePnpmOutput(output) {\r\n    // Extract metrics from pnpm output\r\n    const packageCountMatch = output.match(/(\\d+) packages installed/);\r\n    const cacheHitMatch = output.match(/(\\d+)% cache hit/);\r\n    \r\n    return {\r\n      packageCount: packageCountMatch ? parseInt(packageCountMatch[1]) : 0,\r\n      cacheHitRate: cacheHitMatch ? parseInt(cacheHitMatch[1]) : 0\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n**Development Server Performance Monitoring:**\r\n```javascript\r\n// tools/dev-server/performance-monitor.js\r\nexport class DevServerPerformanceMonitor {\r\n  constructor() {\r\n    this.metrics = {\r\n      startupTime: null,\r\n      serviceStartTimes: new Map(),\r\n      hotReloadTimes: new Map(),\r\n      typeGenerationTimes: [],\r\n      memoryUsage: [],\r\n      cpuUsage: []\r\n    };\r\n    \r\n    this.startSystemMonitoring();\r\n  }\r\n\r\n  recordStartupTime(serviceName, startTime, endTime) {\r\n    const duration = endTime - startTime;\r\n    this.metrics.serviceStartTimes.set(serviceName, duration);\r\n    \r\n    console.log(`⚡ ${serviceName} started in ${duration.toFixed(0)}ms`);\r\n    \r\n    // Alert if startup is slow\r\n    if (duration > this.getSlowStartupThreshold(serviceName)) {\r\n      console.warn(`⚠️ ${serviceName} startup slower than expected (${duration.toFixed(0)}ms)`);\r\n      this.suggestOptimizations(serviceName, duration);\r\n    }\r\n  }\r\n\r\n  recordHotReloadTime(triggerType, duration) {\r\n    this.metrics.hotReloadTimes.set(triggerType, duration);\r\n    \r\n    const emoji = duration < 100 ? '🚀' : duration < 500 ? '⚡' : '🐌';\r\n    console.log(`${emoji} Hot reload (${triggerType}): ${duration.toFixed(0)}ms`);\r\n    \r\n    // Track hot reload performance trends\r\n    this.trackHotReloadTrends(triggerType, duration);\r\n  }\r\n\r\n  recordTypeGenerationTime(trigger, duration, filesGenerated) {\r\n    this.metrics.typeGenerationTimes.push({\r\n      trigger,\r\n      duration,\r\n      filesGenerated,\r\n      timestamp: Date.now()\r\n    });\r\n    \r\n    const efficiency = filesGenerated / (duration / 1000); // files per second\r\n    console.log(`🔄 Type generation: ${duration.toFixed(0)}ms (${filesGenerated} files, ${efficiency.toFixed(1)} files/sec)`);\r\n    \r\n    // Warn if type generation is slow\r\n    if (duration > 2000) {\r\n      console.warn(`⚠️ Type generation taking longer than expected. Consider optimizing model complexity.`);\r\n    }\r\n  }\r\n\r\n  startSystemMonitoring() {\r\n    setInterval(() => {\r\n      const memUsage = process.memoryUsage();\r\n      const cpuUsage = process.cpuUsage();\r\n      \r\n      this.metrics.memoryUsage.push({\r\n        rss: memUsage.rss / 1024 / 1024, // MB\r\n        heapUsed: memUsage.heapUsed / 1024 / 1024, // MB\r\n        timestamp: Date.now()\r\n      });\r\n      \r\n      this.metrics.cpuUsage.push({\r\n        user: cpuUsage.user / 1000, // milliseconds\r\n        system: cpuUsage.system / 1000, // milliseconds\r\n        timestamp: Date.now()\r\n      });\r\n      \r\n      // Keep only last 100 measurements\r\n      if (this.metrics.memoryUsage.length > 100) {\r\n        this.metrics.memoryUsage.shift();\r\n      }\r\n      if (this.metrics.cpuUsage.length > 100) {\r\n        this.metrics.cpuUsage.shift();\r\n      }\r\n      \r\n    }, 1000); // Every second\r\n  }\r\n\r\n  getSlowStartupThreshold(serviceName) {\r\n    const thresholds = {\r\n      'database': 5000,    // 5 seconds for DB startup\r\n      'ollama': 10000,     // 10 seconds for Ollama (model loading)\r\n      'backend': 3000,     // 3 seconds for FastAPI\r\n      'frontend': 2000     // 2 seconds for Vite\r\n    };\r\n    return thresholds[serviceName] || 5000;\r\n  }\r\n\r\n  suggestOptimizations(serviceName, duration) {\r\n    const suggestions = {\r\n      'ollama': [\r\n        '💡 Consider pre-pulling frequently used models',\r\n        '💡 Enable GPU acceleration if available',\r\n        '💡 Use smaller models for development (llama3.1 8B vs 70B)'\r\n      ],\r\n      'backend': [\r\n        '💡 Check for unnecessary imports in main.py',\r\n        '💡 Consider lazy loading of ML dependencies',\r\n        '💡 Optimize database connection pooling'\r\n      ],\r\n      'frontend': [\r\n        '💡 Use pnpm instead of npm for faster installs',\r\n        '💡 Consider reducing bundle size',\r\n        '💡 Check for unnecessary dependencies'\r\n      ]\r\n    };\r\n    \r\n    if (suggestions[serviceName]) {\r\n      suggestions[serviceName].forEach(suggestion => console.log(suggestion));\r\n    }\r\n  }\r\n\r\n  generatePerformanceReport() {\r\n    const totalStartupTime = Array.from(this.metrics.serviceStartTimes.values())\r\n      .reduce((sum, time) => sum + time, 0);\r\n    \r\n    const avgHotReloadTime = Array.from(this.metrics.hotReloadTimes.values())\r\n      .reduce((sum, time) => sum + time, 0) / this.metrics.hotReloadTimes.size;\r\n    \r\n    const recentMemory = this.metrics.memoryUsage.slice(-10);\r\n    const avgMemoryUsage = recentMemory.reduce((sum, m) => sum + m.rss, 0) / recentMemory.length;\r\n    \r\n    return {\r\n      startup: {\r\n        total: totalStartupTime,\r\n        services: Object.fromEntries(this.metrics.serviceStartTimes)\r\n      },\r\n      hotReload: {\r\n        average: avgHotReloadTime,\r\n        byType: Object.fromEntries(this.metrics.hotReloadTimes)\r\n      },\r\n      system: {\r\n        memoryUsageMB: avgMemoryUsage,\r\n        peakMemoryMB: Math.max(...recentMemory.map(m => m.rss))\r\n      },\r\n      typeGeneration: {\r\n        recent: this.metrics.typeGenerationTimes.slice(-5),\r\n        average: this.getAverageTypeGenerationTime()\r\n      }\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n### 2. AI/ML Performance Monitoring\r\n\r\n**Purpose:** Track AI provider performance, GPU utilization, and model inference metrics\r\n\r\n**AI Provider Performance Tracking:**\r\n```python\r\n# packages/farm-core/src/ai/performance_monitor.py\r\nimport time\r\nimport psutil\r\nimport asyncio\r\nfrom typing import Dict, List, Optional\r\nfrom dataclasses import dataclass\r\nfrom collections import defaultdict, deque\r\n\r\n@dataclass\r\nclass AIPerformanceMetric:\r\n    provider: str\r\n    model: str\r\n    operation: str  # chat, chat_stream, embed\r\n    duration_ms: float\r\n    tokens_input: int\r\n    tokens_output: int\r\n    memory_used_mb: float\r\n    gpu_utilization: Optional[float]\r\n    timestamp: float\r\n\r\nclass AIPerformanceMonitor:\r\n    \"\"\"Comprehensive AI performance monitoring and optimization\"\"\"\r\n    \r\n    def __init__(self):\r\n        self.metrics = deque(maxlen=1000)  # Keep last 1000 metrics\r\n        self.provider_stats = defaultdict(list)\r\n        self.gpu_available = self.check_gpu_availability()\r\n        self.baseline_memory = self.get_current_memory()\r\n        \r\n    def check_gpu_availability(self) -> bool:\r\n        \"\"\"Check if GPU monitoring is available\"\"\"\r\n        try:\r\n            import nvidia_ml_py3 as nvml\r\n            nvml.nvmlInit()\r\n            return True\r\n        except:\r\n            return False\r\n    \r\n    def get_current_memory(self) -> float:\r\n        \"\"\"Get current process memory usage in MB\"\"\"\r\n        process = psutil.Process()\r\n        return process.memory_info().rss / 1024 / 1024\r\n    \r\n    def get_gpu_utilization(self) -> Optional[float]:\r\n        \"\"\"Get current GPU utilization percentage\"\"\"\r\n        if not self.gpu_available:\r\n            return None\r\n            \r\n        try:\r\n            import nvidia_ml_py3 as nvml\r\n            handle = nvml.nvmlDeviceGetHandleByIndex(0)\r\n            utilization = nvml.nvmlDeviceGetUtilizationRates(handle)\r\n            return utilization.gpu\r\n        except:\r\n            return None\r\n    \r\n    async def monitor_ai_operation(self, provider: str, model: str, operation: str, \r\n                                 operation_func, *args, **kwargs):\r\n        \"\"\"Monitor performance of an AI operation\"\"\"\r\n        \r\n        start_time = time.time()\r\n        start_memory = self.get_current_memory()\r\n        start_gpu = self.get_gpu_utilization()\r\n        \r\n        # Count input tokens (approximate)\r\n        tokens_input = self.estimate_input_tokens(args, kwargs)\r\n        \r\n        try:\r\n            # Execute the AI operation\r\n            result = await operation_func(*args, **kwargs)\r\n            \r\n            # Calculate metrics\r\n            end_time = time.time()\r\n            duration_ms = (end_time - start_time) * 1000\r\n            end_memory = self.get_current_memory()\r\n            end_gpu = self.get_gpu_utilization()\r\n            \r\n            # Count output tokens (approximate)\r\n            tokens_output = self.estimate_output_tokens(result)\r\n            \r\n            # Record metrics\r\n            metric = AIPerformanceMetric(\r\n                provider=provider,\r\n                model=model,\r\n                operation=operation,\r\n                duration_ms=duration_ms,\r\n                tokens_input=tokens_input,\r\n                tokens_output=tokens_output,\r\n                memory_used_mb=end_memory - start_memory,\r\n                gpu_utilization=end_gpu if end_gpu else start_gpu,\r\n                timestamp=time.time()\r\n            )\r\n            \r\n            self.metrics.append(metric)\r\n            self.provider_stats[provider].append(metric)\r\n            \r\n            # Log performance if notable\r\n            self.log_performance_if_notable(metric)\r\n            \r\n            return result\r\n            \r\n        except Exception as e:\r\n            # Record failed operation\r\n            duration_ms = (time.time() - start_time) * 1000\r\n            print(f\"❌ AI operation failed after {duration_ms:.0f}ms: {e}\")\r\n            raise\r\n    \r\n    def estimate_input_tokens(self, args, kwargs) -> int:\r\n        \"\"\"Estimate input tokens from operation arguments\"\"\"\r\n        text_content = \"\"\r\n        \r\n        # Extract text from common argument patterns\r\n        if args and hasattr(args[0], '__iter__'):\r\n            # Chat messages\r\n            for item in args[0]:\r\n                if hasattr(item, 'content'):\r\n                    text_content += item.content + \" \"\r\n        \r\n        # Simple token estimation (4 chars ≈ 1 token)\r\n        return len(text_content) // 4\r\n    \r\n    def estimate_output_tokens(self, result) -> int:\r\n        \"\"\"Estimate output tokens from AI response\"\"\"\r\n        if isinstance(result, str):\r\n            return len(result) // 4\r\n        return 0\r\n    \r\n    def log_performance_if_notable(self, metric: AIPerformanceMetric):\r\n        \"\"\"Log performance metrics if they're notably good or bad\"\"\"\r\n        \r\n        # Define thresholds\r\n        slow_thresholds = {\r\n            'ollama': 5000,    # 5 seconds for local AI\r\n            'openai': 10000,   # 10 seconds for OpenAI\r\n            'huggingface': 8000 # 8 seconds for HuggingFace\r\n        }\r\n        \r\n        fast_thresholds = {\r\n            'ollama': 500,     # 500ms for local AI\r\n            'openai': 1000,    # 1 second for OpenAI\r\n            'huggingface': 1500 # 1.5 seconds for HuggingFace\r\n        }\r\n        \r\n        provider_slow = slow_thresholds.get(metric.provider, 5000)\r\n        provider_fast = fast_thresholds.get(metric.provider, 1000)\r\n        \r\n        if metric.duration_ms > provider_slow:\r\n            print(f\"🐌 Slow AI response: {metric.provider}/{metric.model} took {metric.duration_ms:.0f}ms\")\r\n            self.suggest_ai_optimizations(metric)\r\n        elif metric.duration_ms < provider_fast:\r\n            print(f\"🚀 Fast AI response: {metric.provider}/{metric.model} in {metric.duration_ms:.0f}ms\")\r\n        \r\n        # Check GPU utilization\r\n        if metric.gpu_utilization and metric.gpu_utilization < 10 and metric.provider == 'ollama':\r\n            print(f\"⚠️ Low GPU utilization ({metric.gpu_utilization:.1f}%) - consider enabling GPU acceleration\")\r\n    \r\n    def suggest_ai_optimizations(self, metric: AIPerformanceMetric):\r\n        \"\"\"Suggest optimizations based on performance metrics\"\"\"\r\n        \r\n        suggestions = []\r\n        \r\n        if metric.provider == 'ollama':\r\n            if metric.gpu_utilization and metric.gpu_utilization < 50:\r\n                suggestions.append(\"💡 Enable GPU acceleration in Ollama configuration\")\r\n            if metric.memory_used_mb > 1000:\r\n                suggestions.append(\"💡 Consider using a smaller model variant\")\r\n            suggestions.append(\"💡 Ensure Ollama is running with sufficient resources\")\r\n            \r\n        elif metric.provider == 'openai':\r\n            suggestions.append(\"💡 Consider caching responses for repeated queries\")\r\n            suggestions.append(\"💡 Use streaming for long responses to improve perceived performance\")\r\n            \r\n        elif metric.provider == 'huggingface':\r\n            suggestions.append(\"💡 Consider pre-loading the model to avoid cold start\")\r\n            suggestions.append(\"💡 Use batch processing for multiple requests\")\r\n        \r\n        for suggestion in suggestions:\r\n            print(suggestion)\r\n    \r\n    def get_provider_performance_summary(self, provider: str) -> Dict:\r\n        \"\"\"Get performance summary for a specific AI provider\"\"\"\r\n        \r\n        if provider not in self.provider_stats:\r\n            return {\"error\": f\"No metrics available for provider {provider}\"}\r\n        \r\n        metrics = self.provider_stats[provider]\r\n        recent_metrics = [m for m in metrics if time.time() - m.timestamp < 3600]  # Last hour\r\n        \r\n        if not recent_metrics:\r\n            return {\"error\": f\"No recent metrics for provider {provider}\"}\r\n        \r\n        durations = [m.duration_ms for m in recent_metrics]\r\n        \r\n        return {\r\n            \"provider\": provider,\r\n            \"total_requests\": len(recent_metrics),\r\n            \"average_duration_ms\": sum(durations) / len(durations),\r\n            \"min_duration_ms\": min(durations),\r\n            \"max_duration_ms\": max(durations),\r\n            \"p95_duration_ms\": sorted(durations)[int(len(durations) * 0.95)],\r\n            \"average_tokens_per_second\": self.calculate_tokens_per_second(recent_metrics),\r\n            \"average_gpu_utilization\": self.calculate_average_gpu_utilization(recent_metrics),\r\n            \"memory_efficiency\": self.calculate_memory_efficiency(recent_metrics)\r\n        }\r\n    \r\n    def calculate_tokens_per_second(self, metrics: List[AIPerformanceMetric]) -> float:\r\n        \"\"\"Calculate average tokens per second\"\"\"\r\n        total_tokens = sum(m.tokens_output for m in metrics)\r\n        total_time_seconds = sum(m.duration_ms for m in metrics) / 1000\r\n        \r\n        return total_tokens / total_time_seconds if total_time_seconds > 0 else 0\r\n    \r\n    def calculate_average_gpu_utilization(self, metrics: List[AIPerformanceMetric]) -> Optional[float]:\r\n        \"\"\"Calculate average GPU utilization\"\"\"\r\n        gpu_metrics = [m.gpu_utilization for m in metrics if m.gpu_utilization is not None]\r\n        \r\n        return sum(gpu_metrics) / len(gpu_metrics) if gpu_metrics else None\r\n    \r\n    def calculate_memory_efficiency(self, metrics: List[AIPerformanceMetric]) -> float:\r\n        \"\"\"Calculate memory efficiency (tokens per MB)\"\"\"\r\n        total_tokens = sum(m.tokens_output for m in metrics)\r\n        total_memory = sum(max(m.memory_used_mb, 0.1) for m in metrics)  # Avoid division by zero\r\n        \r\n        return total_tokens / total_memory if total_memory > 0 else 0\r\n```\r\n\r\n**GPU Performance Monitoring:**\r\n```python\r\n# packages/farm-core/src/ai/gpu_monitor.py\r\nclass GPUMonitor:\r\n    \"\"\"Monitor GPU usage for AI workloads\"\"\"\r\n    \r\n    def __init__(self):\r\n        self.gpu_available = self.initialize_gpu_monitoring()\r\n        self.metrics_history = deque(maxlen=300)  # 5 minutes at 1 sample/second\r\n        \r\n        if self.gpu_available:\r\n            self.start_monitoring()\r\n    \r\n    def initialize_gpu_monitoring(self) -> bool:\r\n        \"\"\"Initialize GPU monitoring if available\"\"\"\r\n        try:\r\n            import nvidia_ml_py3 as nvml\r\n            nvml.nvmlInit()\r\n            self.device_count = nvml.nvmlDeviceGetCount()\r\n            return True\r\n        except:\r\n            print(\"ℹ️ GPU monitoring not available (NVIDIA GPU not found)\")\r\n            return False\r\n    \r\n    def start_monitoring(self):\r\n        \"\"\"Start continuous GPU monitoring\"\"\"\r\n        async def monitor_loop():\r\n            while True:\r\n                try:\r\n                    metrics = self.collect_gpu_metrics()\r\n                    self.metrics_history.append(metrics)\r\n                    \r\n                    # Alert on high memory usage\r\n                    for gpu_id, gpu_metrics in enumerate(metrics['gpus']):\r\n                        memory_percent = (gpu_metrics['memory_used'] / gpu_metrics['memory_total']) * 100\r\n                        if memory_percent > 90:\r\n                            print(f\"⚠️ GPU {gpu_id} memory usage high: {memory_percent:.1f}%\")\r\n                        \r\n                        # Alert on thermal throttling\r\n                        if gpu_metrics['temperature'] > 80:\r\n                            print(f\"🌡️ GPU {gpu_id} running hot: {gpu_metrics['temperature']}°C\")\r\n                    \r\n                    await asyncio.sleep(1)\r\n                except Exception as e:\r\n                    print(f\"GPU monitoring error: {e}\")\r\n                    await asyncio.sleep(5)\r\n        \r\n        # Start monitoring in background\r\n        asyncio.create_task(monitor_loop())\r\n    \r\n    def collect_gpu_metrics(self) -> Dict:\r\n        \"\"\"Collect current GPU metrics\"\"\"\r\n        if not self.gpu_available:\r\n            return {\"available\": False}\r\n        \r\n        import nvidia_ml_py3 as nvml\r\n        \r\n        metrics = {\r\n            \"timestamp\": time.time(),\r\n            \"available\": True,\r\n            \"gpus\": []\r\n        }\r\n        \r\n        for i in range(self.device_count):\r\n            handle = nvml.nvmlDeviceGetHandleByIndex(i)\r\n            \r\n            # Get utilization\r\n            utilization = nvml.nvmlDeviceGetUtilizationRates(handle)\r\n            \r\n            # Get memory info\r\n            memory_info = nvml.nvmlDeviceGetMemoryInfo(handle)\r\n            \r\n            # Get temperature\r\n            temperature = nvml.nvmlDeviceGetTemperature(handle, nvml.NVML_TEMPERATURE_GPU)\r\n            \r\n            # Get power usage\r\n            try:\r\n                power_usage = nvml.nvmlDeviceGetPowerUsage(handle) / 1000  # Convert to watts\r\n            except:\r\n                power_usage = None\r\n            \r\n            gpu_metrics = {\r\n                \"gpu_id\": i,\r\n                \"name\": nvml.nvmlDeviceGetName(handle).decode(),\r\n                \"utilization\": utilization.gpu,\r\n                \"memory_utilization\": utilization.memory,\r\n                \"memory_used\": memory_info.used // 1024 // 1024,  # MB\r\n                \"memory_total\": memory_info.total // 1024 // 1024,  # MB\r\n                \"memory_free\": memory_info.free // 1024 // 1024,  # MB\r\n                \"temperature\": temperature,\r\n                \"power_usage\": power_usage\r\n            }\r\n            \r\n            metrics[\"gpus\"].append(gpu_metrics)\r\n        \r\n        return metrics\r\n    \r\n    def get_performance_recommendations(self) -> List[str]:\r\n        \"\"\"Analyze GPU performance and provide recommendations\"\"\"\r\n        if not self.metrics_history:\r\n            return [\"No GPU metrics available for analysis\"]\r\n        \r\n        recent_metrics = list(self.metrics_history)[-60:]  # Last minute\r\n        recommendations = []\r\n        \r\n        for gpu_id in range(self.device_count):\r\n            gpu_utilizations = [m['gpus'][gpu_id]['utilization'] for m in recent_metrics]\r\n            avg_utilization = sum(gpu_utilizations) / len(gpu_utilizations)\r\n            \r\n            memory_usages = [m['gpus'][gpu_id]['memory_used'] / m['gpus'][gpu_id]['memory_total'] * 100 \r\n                           for m in recent_metrics]\r\n            avg_memory_usage = sum(memory_usages) / len(memory_usages)\r\n            \r\n            if avg_utilization < 20:\r\n                recommendations.append(f\"💡 GPU {gpu_id}: Low utilization ({avg_utilization:.1f}%) - consider enabling GPU acceleration in Ollama\")\r\n            \r\n            if avg_memory_usage > 90:\r\n                recommendations.append(f\"⚠️ GPU {gpu_id}: High memory usage ({avg_memory_usage:.1f}%) - consider using smaller AI models\")\r\n            \r\n            if avg_utilization > 95:\r\n                recommendations.append(f\"🚀 GPU {gpu_id}: Excellent utilization ({avg_utilization:.1f}%)\")\r\n        \r\n        return recommendations\r\n```\r\n\r\n### 3. Build System Performance\r\n\r\n**Purpose:** Optimize build times and track build performance metrics\r\n\r\n**Build Performance Monitoring:**\r\n```javascript\r\n// tools/build/performance-monitor.js\r\nexport class BuildPerformanceMonitor {\r\n  constructor() {\r\n    this.buildMetrics = new Map();\r\n    this.bundleAnalyzer = new BundleAnalyzer();\r\n  }\r\n\r\n  async monitorBuild(buildType, buildFunction) {\r\n    const startTime = performance.now();\r\n    const startMemory = process.memoryUsage();\r\n    \r\n    console.log(`🏗️ Starting ${buildType} build...`);\r\n    \r\n    try {\r\n      const result = await buildFunction();\r\n      \r\n      const endTime = performance.now();\r\n      const endMemory = process.memoryUsage();\r\n      const duration = endTime - startTime;\r\n      \r\n      const metrics = {\r\n        buildType,\r\n        duration,\r\n        memoryUsed: (endMemory.heapUsed - startMemory.heapUsed) / 1024 / 1024, // MB\r\n        bundleSize: await this.calculateBundleSize(result),\r\n        timestamp: Date.now()\r\n      };\r\n      \r\n      this.buildMetrics.set(buildType, metrics);\r\n      this.logBuildPerformance(metrics);\r\n      \r\n      return result;\r\n      \r\n    } catch (error) {\r\n      const duration = performance.now() - startTime;\r\n      console.error(`❌ ${buildType} build failed after ${duration.toFixed(0)}ms:`, error.message);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  logBuildPerformance(metrics) {\r\n    const { buildType, duration, memoryUsed, bundleSize } = metrics;\r\n    \r\n    console.log(`✅ ${buildType} build completed in ${duration.toFixed(0)}ms`);\r\n    console.log(`📊 Bundle size: ${this.formatBytes(bundleSize)}`);\r\n    console.log(`🧠 Memory used: ${memoryUsed.toFixed(1)}MB`);\r\n    \r\n    // Performance warnings\r\n    if (duration > 30000) { // 30 seconds\r\n      console.warn(`⚠️ Build time exceeded 30 seconds. Consider optimizing:\r\n💡 Enable pnpm caching with --prefer-offline\r\n💡 Use build caching for unchanged files  \r\n💡 Consider code splitting optimization`);\r\n    }\r\n    \r\n    if (bundleSize > 5 * 1024 * 1024) { // 5MB\r\n      console.warn(`⚠️ Large bundle size detected (${this.formatBytes(bundleSize)})\r\n💡 Consider code splitting\r\n💡 Review AI/ML dependencies for tree-shaking\r\n💡 Use dynamic imports for heavy libraries`);\r\n    }\r\n  }\r\n\r\n  formatBytes(bytes) {\r\n    if (bytes === 0) return '0 Bytes';\r\n    const k = 1024;\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\r\n  }\r\n\r\n  async calculateBundleSize(buildResult) {\r\n    // Calculate total bundle size from build output\r\n    if (buildResult.output) {\r\n      return buildResult.output.reduce((total, chunk) => {\r\n        return total + (chunk.code ? chunk.code.length : 0);\r\n      }, 0);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  async optimizePnpmWorkspace(projectPath) {\r\n    \"\"\"Optimize pnpm workspace configuration for better performance\"\"\"\r\n    \r\n    const workspaceConfig = {\r\n      'prefer-workspace-packages': true,\r\n      'link-workspace-packages': true,\r\n      'shared-workspace-lockfile': true,\r\n      'hoist-pattern': ['*'],\r\n      'shamefully-hoist': true,\r\n      'package-import-method': 'hardlink'\r\n    };\r\n\r\n    // Create optimized .npmrc\r\n    const npmrcPath = path.join(projectPath, '.npmrc');\r\n    const configContent = Object.entries(workspaceConfig)\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('\\n');\r\n    \r\n    await fs.writeFile(npmrcPath, configContent);\r\n    \r\n    // Create pnpm-workspace.yaml if it doesn't exist\r\n    const workspaceFile = path.join(projectPath, 'pnpm-workspace.yaml');\r\n    if (!await fs.pathExists(workspaceFile)) {\r\n      const workspaceContent = `\r\npackages:\r\n  - 'apps/*'\r\n  - 'packages/*'\r\n  - '!**/test/**'\r\n`;\r\n      await fs.writeFile(workspaceFile, workspaceContent);\r\n    }\r\n    \r\n    console.log('⚡ pnpm workspace optimized for performance');\r\n  }\r\n}\r\n```\r\n\r\n**Type Generation Performance:**\r\n```typescript\r\n// tools/codegen/performance-monitor.ts\r\nexport class TypeGenerationMonitor {\r\n  private metrics: GenerationMetric[] = [];\r\n\r\n  async monitorGeneration(trigger: string, generationFn: () => Promise<GenerationResult>) {\r\n    const startTime = performance.now();\r\n    const startMemory = process.memoryUsage().heapUsed;\r\n\r\n    try {\r\n      const result = await generationFn();\r\n      \r\n      const endTime = performance.now();\r\n      const duration = endTime - startTime;\r\n      const memoryUsed = (process.memoryUsage().heapUsed - startMemory) / 1024 / 1024;\r\n\r\n      const metric: GenerationMetric = {\r\n        trigger,\r\n        duration,\r\n        memoryUsed,\r\n        filesGenerated: result.filesGenerated,\r\n        linesGenerated: result.linesGenerated,\r\n        typesGenerated: result.typesGenerated,\r\n        timestamp: Date.now()\r\n      };\r\n\r\n      this.metrics.push(metric);\r\n      this.logGenerationPerformance(metric);\r\n\r\n      // Cleanup old metrics\r\n      this.metrics = this.metrics.slice(-100);\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      const duration = performance.now() - startTime;\r\n      console.error(`❌ Type generation failed after ${duration.toFixed(0)}ms:`, error.message);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private logGenerationPerformance(metric: GenerationMetric) {\r\n    const efficiency = metric.typesGenerated / (metric.duration / 1000); // types per second\r\n    \r\n    console.log(`🔄 Type generation (${metric.trigger}): ${metric.duration.toFixed(0)}ms`);\r\n    console.log(`📁 Generated: ${metric.filesGenerated} files, ${metric.typesGenerated} types`);\r\n    console.log(`⚡ Efficiency: ${efficiency.toFixed(1)} types/second`);\r\n\r\n    // Performance optimization suggestions\r\n    if (metric.duration > 5000) {\r\n      console.warn(`⚠️ Type generation slower than expected:\r\n💡 Consider simplifying complex model relationships\r\n💡 Enable incremental generation for large schemas\r\n💡 Use type generation caching`);\r\n    }\r\n\r\n    if (metric.memoryUsed > 100) {\r\n      console.warn(`⚠️ High memory usage during type generation (${metric.memoryUsed.toFixed(1)}MB):\r\n💡 Process models in smaller batches\r\n💡 Clear intermediate data structures`);\r\n    }\r\n  }\r\n\r\n  getGenerationTrends(): GenerationTrends {\r\n    if (this.metrics.length < 5) {\r\n      return { insufficient_data: true };\r\n    }\r\n\r\n    const recent = this.metrics.slice(-10);\r\n    const avgDuration = recent.reduce((sum, m) => sum + m.duration, 0) / recent.length;\r\n    const avgEfficiency = recent.reduce((sum, m) => sum + (m.typesGenerated / (m.duration / 1000)), 0) / recent.length;\r\n\r\n    return {\r\n      average_duration_ms: avgDuration,\r\n      average_efficiency_types_per_second: avgEfficiency,\r\n      trend: this.calculateTrend(recent.map(m => m.duration)),\r\n      recommendations: this.getOptimizationRecommendations(recent)\r\n    };\r\n  }\r\n\r\n  private getOptimizationRecommendations(metrics: GenerationMetric[]): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    const avgDuration = metrics.reduce((sum, m) => sum + m.duration, 0) / metrics.length;\r\n    const avgMemory = metrics.reduce((sum, m) => sum + m.memoryUsed, 0) / metrics.length;\r\n    \r\n    if (avgDuration > 2000) {\r\n      recommendations.push('Enable incremental type generation');\r\n      recommendations.push('Consider type generation caching');\r\n    }\r\n    \r\n    if (avgMemory > 50) {\r\n      recommendations.push('Optimize memory usage in type generator');\r\n      recommendations.push('Process models in smaller batches');\r\n    }\r\n    \r\n    const variability = this.calculateVariability(metrics.map(m => m.duration));\r\n    if (variability > 0.5) {\r\n      recommendations.push('Investigate inconsistent generation times');\r\n      recommendations.push('Consider warming up type generation cache');\r\n    }\r\n    \r\n    return recommendations;\r\n  }\r\n}\r\n```\r\n\r\n### 4. Production Monitoring\r\n\r\n**Purpose:** Monitor production applications with AI-specific metrics\r\n\r\n**Production Metrics Collection:**\r\n```python\r\n# packages/farm-monitoring/src/production_monitor.py\r\nfrom prometheus_client import Counter, Histogram, Gauge, CollectorRegistry\r\nimport time\r\nfrom typing import Dict, Any\r\n\r\nclass ProductionMonitor:\r\n    \"\"\"Production monitoring for FARM applications with AI metrics\"\"\"\r\n    \r\n    def __init__(self):\r\n        self.registry = CollectorRegistry()\r\n        self.setup_metrics()\r\n    \r\n    def setup_metrics(self):\r\n        \"\"\"Setup Prometheus metrics for production monitoring\"\"\"\r\n        \r\n        # HTTP request metrics\r\n        self.http_requests_total = Counter(\r\n            'farm_http_requests_total',\r\n            'Total HTTP requests',\r\n            ['method', 'endpoint', 'status_code'],\r\n            registry=self.registry\r\n        )\r\n        \r\n        self.http_request_duration = Histogram(\r\n            'farm_http_request_duration_seconds',\r\n            'HTTP request duration',\r\n            ['method', 'endpoint'],\r\n            registry=self.registry\r\n        )\r\n        \r\n        # AI-specific metrics\r\n        self.ai_requests_total = Counter(\r\n            'farm_ai_requests_total',\r\n            'Total AI requests',\r\n            ['provider', 'model', 'operation'],\r\n            registry=self.registry\r\n        )\r\n        \r\n        self.ai_request_duration = Histogram(\r\n            'farm_ai_request_duration_seconds',\r\n            'AI request duration',\r\n            ['provider', 'model', 'operation'],\r\n            buckets=(0.1, 0.5, 1.0, 2.5, 5.0, 10.0, 25.0, 50.0, 100.0),\r\n            registry=self.registry\r\n        )\r\n        \r\n        self.ai_tokens_processed = Counter(\r\n            'farm_ai_tokens_processed_total',\r\n            'Total AI tokens processed',\r\n            ['provider', 'model', 'type'],  # type: input/output\r\n            registry=self.registry\r\n        )\r\n        \r\n        self.ai_provider_errors = Counter(\r\n            'farm_ai_provider_errors_total',\r\n            'AI provider errors',\r\n            ['provider', 'error_type'],\r\n            registry=self.registry\r\n        )\r\n        \r\n        # System metrics\r\n        self.active_connections = Gauge(\r\n            'farm_active_connections',\r\n            'Active database connections',\r\n            registry=self.registry\r\n        )\r\n        \r\n        self.memory_usage = Gauge(\r\n            'farm_memory_usage_bytes',\r\n            'Memory usage',\r\n            ['type'],  # heap, rss, external\r\n            registry=self.registry\r\n        )\r\n        \r\n        # GPU metrics (if available)\r\n        self.gpu_utilization = Gauge(\r\n            'farm_gpu_utilization_percent',\r\n            'GPU utilization percentage',\r\n            ['gpu_id'],\r\n            registry=self.registry\r\n        )\r\n        \r\n        self.gpu_memory_usage = Gauge(\r\n            'farm_gpu_memory_usage_bytes',\r\n            'GPU memory usage',\r\n            ['gpu_id', 'type'],  # used, total\r\n            registry=self.registry\r\n        )\r\n    \r\n    def record_http_request(self, method: str, endpoint: str, status_code: int, duration: float):\r\n        \"\"\"Record HTTP request metrics\"\"\"\r\n        self.http_requests_total.labels(\r\n            method=method,\r\n            endpoint=endpoint,\r\n            status_code=status_code\r\n        ).inc()\r\n        \r\n        self.http_request_duration.labels(\r\n            method=method,\r\n            endpoint=endpoint\r\n        ).observe(duration)\r\n    \r\n    def record_ai_request(self, provider: str, model: str, operation: str, \r\n                         duration: float, input_tokens: int, output_tokens: int):\r\n        \"\"\"Record AI request metrics\"\"\"\r\n        self.ai_requests_total.labels(\r\n            provider=provider,\r\n            model=model,\r\n            operation=operation\r\n        ).inc()\r\n        \r\n        self.ai_request_duration.labels(\r\n            provider=provider,\r\n            model=model,\r\n            operation=operation\r\n        ).observe(duration)\r\n        \r\n        self.ai_tokens_processed.labels(\r\n            provider=provider,\r\n            model=model,\r\n            type='input'\r\n        ).inc(input_tokens)\r\n        \r\n        self.ai_tokens_processed.labels(\r\n            provider=provider,\r\n            model=model,\r\n            type='output'\r\n        ).inc(output_tokens)\r\n    \r\n    def record_ai_error(self, provider: str, error_type: str):\r\n        \"\"\"Record AI provider errors\"\"\"\r\n        self.ai_provider_errors.labels(\r\n            provider=provider,\r\n            error_type=error_type\r\n        ).inc()\r\n    \r\n    async def update_system_metrics(self):\r\n        \"\"\"Update system metrics periodically\"\"\"\r\n        import psutil\r\n        \r\n        # Memory metrics\r\n        memory = psutil.virtual_memory()\r\n        self.memory_usage.labels(type='total').set(memory.total)\r\n        self.memory_usage.labels(type='used').set(memory.used)\r\n        self.memory_usage.labels(type='available').set(memory.available)\r\n        \r\n        # Process memory\r\n        process = psutil.Process()\r\n        process_memory = process.memory_info()\r\n        self.memory_usage.labels(type='process_rss').set(process_memory.rss)\r\n        self.memory_usage.labels(type='process_vms').set(process_memory.vms)\r\n    \r\n    async def update_gpu_metrics(self):\r\n        \"\"\"Update GPU metrics if available\"\"\"\r\n        try:\r\n            import nvidia_ml_py3 as nvml\r\n            \r\n            for i in range(nvml.nvmlDeviceGetCount()):\r\n                handle = nvml.nvmlDeviceGetHandleByIndex(i)\r\n                \r\n                # Utilization\r\n                utilization = nvml.nvmlDeviceGetUtilizationRates(handle)\r\n                self.gpu_utilization.labels(gpu_id=str(i)).set(utilization.gpu)\r\n                \r\n                # Memory\r\n                memory = nvml.nvmlDeviceGetMemoryInfo(handle)\r\n                self.gpu_memory_usage.labels(gpu_id=str(i), type='used').set(memory.used)\r\n                self.gpu_memory_usage.labels(gpu_id=str(i), type='total').set(memory.total)\r\n                \r\n        except Exception:\r\n            pass  # GPU metrics not available\r\n```\r\n\r\n**AI Performance Dashboard:**\r\n```typescript\r\n// packages/farm-monitoring/src/dashboard.tsx\r\nexport function AIPerformanceDashboard() {\r\n  const [metrics, setMetrics] = useState(null);\r\n  const [timeRange, setTimeRange] = useState('1h');\r\n\r\n  useEffect(() => {\r\n    const fetchMetrics = async () => {\r\n      const response = await fetch(`/api/metrics/ai?range=${timeRange}`);\r\n      const data = await response.json();\r\n      setMetrics(data);\r\n    };\r\n\r\n    fetchMetrics();\r\n    const interval = setInterval(fetchMetrics, 30000); // Update every 30 seconds\r\n\r\n    return () => clearInterval(interval);\r\n  }, [timeRange]);\r\n\r\n  if (!metrics) return <div>Loading metrics...</div>;\r\n\r\n  return (\r\n    <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 p-6\">\r\n      {/* AI Provider Performance */}\r\n      <MetricCard\r\n        title=\"AI Provider Performance\"\r\n        subtitle=\"Average response times\"\r\n      >\r\n        <div className=\"space-y-2\">\r\n          {Object.entries(metrics.providers).map(([provider, data]) => (\r\n            <div key={provider} className=\"flex justify-between items-center\">\r\n              <span className=\"font-medium capitalize\">{provider}</span>\r\n              <div className=\"text-right\">\r\n                <div className=\"text-lg font-mono\">\r\n                  {data.avgDuration.toFixed(0)}ms\r\n                </div>\r\n                <div className=\"text-sm text-gray-500\">\r\n                  {data.requests} requests\r\n                </div>\r\n              </div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      </MetricCard>\r\n\r\n      {/* Token Processing Rate */}\r\n      <MetricCard\r\n        title=\"Token Processing\"\r\n        subtitle=\"Tokens per second by provider\"\r\n      >\r\n        <div className=\"space-y-2\">\r\n          {Object.entries(metrics.tokenRates).map(([provider, rate]) => (\r\n            <div key={provider} className=\"flex justify-between items-center\">\r\n              <span className=\"font-medium capitalize\">{provider}</span>\r\n              <span className=\"text-lg font-mono\">{rate.toFixed(1)} tok/s</span>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      </MetricCard>\r\n\r\n      {/* GPU Utilization */}\r\n      {metrics.gpu && (\r\n        <MetricCard\r\n          title=\"GPU Utilization\"\r\n          subtitle=\"Real-time GPU metrics\"\r\n        >\r\n          <div className=\"space-y-3\">\r\n            {metrics.gpu.devices.map((device, index) => (\r\n              <div key={index} className=\"space-y-1\">\r\n                <div className=\"flex justify-between text-sm\">\r\n                  <span>GPU {index}</span>\r\n                  <span>{device.utilization}%</span>\r\n                </div>\r\n                <div className=\"w-full bg-gray-200 rounded-full h-2\">\r\n                  <div\r\n                    className=\"bg-blue-600 h-2 rounded-full\"\r\n                    style={{ width: `${device.utilization}%` }}\r\n                  />\r\n                </div>\r\n                <div className=\"text-xs text-gray-500\">\r\n                  Memory: {device.memoryUsed}MB / {device.memoryTotal}MB\r\n                </div>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        </MetricCard>\r\n      )}\r\n\r\n      {/* Error Rates */}\r\n      <MetricCard\r\n        title=\"Error Rates\"\r\n        subtitle=\"AI provider error tracking\"\r\n      >\r\n        <div className=\"space-y-2\">\r\n          {Object.entries(metrics.errors).map(([provider, errorData]) => (\r\n            <div key={provider} className=\"flex justify-between items-center\">\r\n              <span className=\"font-medium capitalize\">{provider}</span>\r\n              <div className=\"text-right\">\r\n                <div className={`text-lg font-mono ${\r\n                  errorData.rate > 0.05 ? 'text-red-600' : 'text-green-600'\r\n                }`}>\r\n                  {(errorData.rate * 100).toFixed(2)}%\r\n                </div>\r\n                <div className=\"text-sm text-gray-500\">\r\n                  {errorData.count} errors\r\n                </div>\r\n              </div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      </MetricCard>\r\n\r\n      {/* Response Time Trends */}\r\n      <div className=\"col-span-full\">\r\n        <MetricCard\r\n          title=\"Response Time Trends\"\r\n          subtitle=\"AI response times over time\"\r\n        >\r\n          <div className=\"h-64\">\r\n            <ResponsiveContainer width=\"100%\" height=\"100%\">\r\n              <LineChart data={metrics.timeSeries}>\r\n                <XAxis dataKey=\"timestamp\" />\r\n                <YAxis />\r\n                <Tooltip />\r\n                <Legend />\r\n                {Object.keys(metrics.providers).map((provider, index) => (\r\n                  <Line\r\n                    key={provider}\r\n                    type=\"monotone\"\r\n                    dataKey={provider}\r\n                    stroke={`hsl(${index * 60}, 70%, 50%)`}\r\n                    strokeWidth={2}\r\n                  />\r\n                ))}\r\n              </LineChart>\r\n            </ResponsiveContainer>\r\n          </div>\r\n        </MetricCard>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n---\r\n\r\n## Performance CLI Integration\r\n\r\n### Performance Commands\r\n\r\n**CLI Performance Monitoring:**\r\n```bash\r\n# Performance monitoring commands\r\nfarm perf                           # Show current performance dashboard\r\nfarm perf:dev                      # Development server performance\r\nfarm perf:ai                       # AI provider performance\r\nfarm perf:build                    # Build performance analysis\r\n\r\n# Performance optimization\r\nfarm optimize                      # Run all optimizations\r\nfarm optimize:pnpm                 # Optimize pnpm configuration\r\nfarm optimize:ai                   # Optimize AI model configuration\r\nfarm optimize:build                # Optimize build configuration\r\n\r\n# Performance testing\r\nfarm perf:test                     # Run performance test suite\r\nfarm perf:test --ai-providers      # Test all AI providers\r\nfarm perf:test --load              # Load testing\r\nfarm perf:benchmark               # Benchmark AI operations\r\n\r\n# Performance reports\r\nfarm perf:report                   # Generate performance report\r\nfarm perf:report --export          # Export metrics to file\r\nfarm perf:report --compare         # Compare with previous runs\r\n```\r\n\r\n### Performance Configuration\r\n\r\n**Farm Config Performance Settings:**\r\n```typescript\r\n// farm.config.ts - Performance configuration\r\nexport default defineConfig({\r\n  performance: {\r\n    // Development optimizations\r\n    development: {\r\n      pnpm: {\r\n        enabled: true,\r\n        preferOffline: true,\r\n        shamefullyHoist: true,\r\n        storeDir: '~/.pnpm-store'\r\n      },\r\n      hotReload: {\r\n        typeGeneration: {\r\n          incremental: true,\r\n          debounceMs: 200,\r\n          caching: true\r\n        },\r\n        aiModels: {\r\n          hotSwap: true,\r\n          preloadModels: ['llama3.1']\r\n        }\r\n      },\r\n      monitoring: {\r\n        enabled: true,\r\n        gpuMonitoring: true,\r\n        memoryTracking: true\r\n      }\r\n    },\r\n    \r\n    // AI performance settings\r\n    ai: {\r\n      caching: {\r\n        enabled: true,\r\n        ttl: 3600, // 1 hour\r\n        maxSize: '500MB'\r\n      },\r\n      optimization: {\r\n        batchRequests: true,\r\n        connectionPooling: true,\r\n        timeouts: {\r\n          ollama: 30000,\r\n          openai: 60000,\r\n          huggingface: 45000\r\n        }\r\n      },\r\n      monitoring: {\r\n        enabled: true,\r\n        detailedMetrics: true,\r\n        performanceAlerts: true\r\n      }\r\n    },\r\n    \r\n    // Build performance\r\n    build: {\r\n      optimization: {\r\n        codeSplitting: true,\r\n        treeshaking: true,\r\n        minification: true,\r\n        compressionLevel: 6\r\n      },\r\n      caching: {\r\n        enabled: true,\r\n        strategy: 'filesystem',\r\n        maxAge: '7d'\r\n      },\r\n      monitoring: {\r\n        bundleAnalysis: true,\r\n        buildTiming: true,\r\n        memoryTracking: true\r\n      }\r\n    },\r\n    \r\n    // Production monitoring\r\n    production: {\r\n      metrics: {\r\n        enabled: true,\r\n        prometheus: true,\r\n        customMetrics: true\r\n      },\r\n      alerting: {\r\n        enabled: true,\r\n        thresholds: {\r\n          responseTime: 5000,    // 5 seconds\r\n          errorRate: 0.05,       // 5%\r\n          aiProviderTimeout: 30000 // 30 seconds\r\n        }\r\n      },\r\n      optimization: {\r\n        caching: true,\r\n        compression: true,\r\n        aiResponseCaching: true\r\n      }\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n---\r\n\r\n## Alert System\r\n\r\n### Performance Alerts\r\n\r\n**Intelligent Performance Alerting:**\r\n```python\r\n# packages/farm-monitoring/src/alerts.py\r\nclass PerformanceAlertSystem:\r\n    \"\"\"Intelligent alerting for performance issues\"\"\"\r\n    \r\n    def __init__(self):\r\n        self.thresholds = {\r\n            'ai_response_time': {\r\n                'ollama': 10000,    # 10 seconds\r\n                'openai': 30000,    # 30 seconds\r\n                'huggingface': 20000 # 20 seconds\r\n            },\r\n            'error_rate': 0.05,     # 5%\r\n            'gpu_utilization': 95,  # 95%\r\n            'memory_usage': 90,     # 90%\r\n            'build_time': 120000    # 2 minutes\r\n        }\r\n        \r\n        self.alert_cooldowns = {}  # Prevent spam\r\n        \r\n    def check_ai_performance(self, metrics):\r\n        \"\"\"Check AI performance and alert if necessary\"\"\"\r\n        alerts = []\r\n        \r\n        for provider, provider_metrics in metrics.items():\r\n            threshold = self.thresholds['ai_response_time'].get(provider, 15000)\r\n            \r\n            if provider_metrics['avg_response_time'] > threshold:\r\n                alert = {\r\n                    'type': 'ai_performance',\r\n                    'severity': 'warning',\r\n                    'provider': provider,\r\n                    'message': f\"{provider} response time ({provider_metrics['avg_response_time']:.0f}ms) exceeds threshold ({threshold}ms)\",\r\n                    'suggestions': self.get_ai_optimization_suggestions(provider, provider_metrics)\r\n                }\r\n                alerts.append(alert)\r\n        \r\n        return alerts\r\n    \r\n    def get_ai_optimization_suggestions(self, provider, metrics):\r\n        \"\"\"Get provider-specific optimization suggestions\"\"\"\r\n        suggestions = []\r\n        \r\n        if provider == 'ollama':\r\n            if metrics.get('gpu_utilization', 0) < 50:\r\n                suggestions.append(\"Enable GPU acceleration in Ollama\")\r\n            if metrics.get('memory_usage', 0) > 8000:  # 8GB\r\n                suggestions.append(\"Consider using a smaller model variant\")\r\n            suggestions.append(\"Ensure Ollama has sufficient CPU/GPU resources\")\r\n            \r\n        elif provider == 'openai':\r\n            suggestions.append(\"Consider implementing response caching\")\r\n            suggestions.append(\"Use streaming for long responses\")\r\n            suggestions.append(\"Check network connectivity to OpenAI\")\r\n            \r\n        elif provider == 'huggingface':\r\n            suggestions.append(\"Pre-load models to avoid cold starts\")\r\n            suggestions.append(\"Consider using model quantization\")\r\n            suggestions.append(\"Implement request batching\")\r\n        \r\n        return suggestions\r\n    \r\n    def format_alert_message(self, alert):\r\n        \"\"\"Format alert for display/notification\"\"\"\r\n        message = f\"🚨 {alert['type'].title()} Alert\\n\"\r\n        message += f\"Severity: {alert['severity'].upper()}\\n\"\r\n        message += f\"Message: {alert['message']}\\n\"\r\n        \r\n        if alert.get('suggestions'):\r\n            message += \"\\n💡 Suggestions:\\n\"\r\n            for suggestion in alert['suggestions']:\r\n                message += f\"• {suggestion}\\n\"\r\n        \r\n        return message\r\n```\r\n\r\n---\r\n\r\n*Status: ✅ Completed - Ready for implementation*\r\n",
      "excerpt": "FARM's performance and monitoring system provides comprehensive observability across the entire AI-first full-stack architecture.",
      "category": "architectural-sketches-detailed/phase3",
      "type": "reference",
      "tags": [
        "fastapi",
        "farm",
        "typescript",
        "python",
        "database"
      ],
      "lastModified": "2025-06-12T21:57:32.783Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase3",
        "Performance_monitoring_design"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Performance & Monitoring Design",
          "id": "performance-monitoring-design"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "Multi-Layer Performance Architecture",
          "id": "multi-layer-performance-architecture"
        },
        {
          "level": 2,
          "text": "Core Performance Components",
          "id": "core-performance-components"
        },
        {
          "level": 3,
          "text": "1. Development Performance Optimization",
          "id": "1-development-performance-optimization"
        },
        {
          "level": 3,
          "text": "2. AI/ML Performance Monitoring",
          "id": "2-aiml-performance-monitoring"
        },
        {
          "level": 1,
          "text": "packages/farm-core/src/ai/performance_monitor.py",
          "id": "packagesfarm-coresrcaiperformance_monitorpy"
        },
        {
          "level": 1,
          "text": "packages/farm-core/src/ai/gpu_monitor.py",
          "id": "packagesfarm-coresrcaigpu_monitorpy"
        },
        {
          "level": 3,
          "text": "3. Build System Performance",
          "id": "3-build-system-performance"
        },
        {
          "level": 3,
          "text": "4. Production Monitoring",
          "id": "4-production-monitoring"
        },
        {
          "level": 1,
          "text": "packages/farm-monitoring/src/production_monitor.py",
          "id": "packagesfarm-monitoringsrcproduction_monitorpy"
        },
        {
          "level": 2,
          "text": "Performance CLI Integration",
          "id": "performance-cli-integration"
        },
        {
          "level": 3,
          "text": "Performance Commands",
          "id": "performance-commands"
        },
        {
          "level": 1,
          "text": "Performance monitoring commands",
          "id": "performance-monitoring-commands"
        },
        {
          "level": 1,
          "text": "Performance optimization",
          "id": "performance-optimization"
        },
        {
          "level": 1,
          "text": "Performance testing",
          "id": "performance-testing"
        },
        {
          "level": 1,
          "text": "Performance reports",
          "id": "performance-reports"
        },
        {
          "level": 3,
          "text": "Performance Configuration",
          "id": "performance-configuration"
        },
        {
          "level": 2,
          "text": "Alert System",
          "id": "alert-system"
        },
        {
          "level": 3,
          "text": "Performance Alerts",
          "id": "performance-alerts"
        },
        {
          "level": 1,
          "text": "packages/farm-monitoring/src/alerts.py",
          "id": "packagesfarm-monitoringsrcalertspy"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase3-security_architecture",
      "title": "Security_architecture",
      "url": "/architectural-sketches-detailed/phase3/security_architecture",
      "content": "# Security Architecture\r\n\r\n## Overview\r\n\r\nFARM's security architecture provides comprehensive protection across the AI-first full-stack platform, addressing unique challenges including AI provider security, prompt injection prevention, secure code generation, and cross-stack security consistency. The framework implements defense-in-depth strategies with AI-aware security patterns and secure-by-default configurations.\r\n\r\n---\r\n\r\n## Multi-Layer Security Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Security Architecture                   │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │   AI/ML     │  │ Framework   │  │Application  │  │Cross-   │ │\r\n│  │ Security    │  │ Security    │  │ Security    │  │Stack    │ │\r\n│  │(Providers)  │  │(CLI/Codegen)│  │(Auth/Data)  │ │Security │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Threat      │  │ Secret      │  │ Access      │  │Security │ │\r\n│  │ Detection   │  │ Management  │  │ Control     │  │Monitoring│ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Encryption  │  │ Validation  │  │ Compliance  │  │ Audit   │ │\r\n│  │ & Privacy   │  │ & Sanitization │  │ & Governance│  │ Logging │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Security Components\r\n\r\n### 1. AI/ML Security Framework\r\n\r\n**Purpose:** Secure AI provider integrations and protect against AI-specific threats\r\n\r\n**AI Provider Security Management:**\r\n\r\n````python\r\n# packages/farm-security/src/ai_security.py\r\nfrom typing import Dict, List, Optional, Any\r\nfrom dataclasses import dataclass\r\nimport hashlib\r\nimport hmac\r\nimport json\r\nimport re\r\nfrom datetime import datetime, timedelta\r\n\r\n@dataclass\r\nclass AISecurityConfig:\r\n    provider: str\r\n    authentication_method: str  # api_key, oauth, local\r\n    rate_limiting: Dict[str, int]\r\n    content_filtering: bool\r\n    audit_logging: bool\r\n    encryption_at_rest: bool\r\n    prompt_injection_protection: bool\r\n\r\nclass AISecurityManager:\r\n    \"\"\"Comprehensive AI security management\"\"\"\r\n\r\n    def __init__(self):\r\n        self.provider_configs = {}\r\n        self.prompt_filters = PromptInjectionFilter()\r\n        self.audit_logger = AIAuditLogger()\r\n        self.rate_limiters = {}\r\n\r\n    def configure_provider_security(self, provider: str, config: AISecurityConfig):\r\n        \"\"\"Configure security settings for an AI provider\"\"\"\r\n        self.provider_configs[provider] = config\r\n\r\n        # Initialize rate limiter\r\n        if config.rate_limiting:\r\n            self.rate_limiters[provider] = RateLimiter(\r\n                requests_per_minute=config.rate_limiting.get('requests_per_minute', 60),\r\n                tokens_per_minute=config.rate_limiting.get('tokens_per_minute', 40000)\r\n            )\r\n\r\n    async def secure_ai_request(self, provider: str, request_data: Dict[str, Any],\r\n                               user_id: Optional[str] = None) -> Dict[str, Any]:\r\n        \"\"\"Secure and validate AI request before processing\"\"\"\r\n\r\n        config = self.provider_configs.get(provider)\r\n        if not config:\r\n            raise SecurityError(f\"No security configuration for provider {provider}\")\r\n\r\n        # Rate limiting check\r\n        if provider in self.rate_limiters:\r\n            await self.rate_limiters[provider].check_limits(user_id)\r\n\r\n        # Prompt injection protection\r\n        if config.prompt_injection_protection:\r\n            await self.validate_prompt_safety(request_data)\r\n\r\n        # Content filtering\r\n        if config.content_filtering:\r\n            await self.apply_content_filters(request_data)\r\n\r\n        # Audit logging\r\n        if config.audit_logging:\r\n            await self.audit_logger.log_request(provider, request_data, user_id)\r\n\r\n        # Sanitize request data\r\n        sanitized_request = await self.sanitize_request(request_data)\r\n\r\n        return sanitized_request\r\n\r\n    async def validate_prompt_safety(self, request_data: Dict[str, Any]):\r\n        \"\"\"Validate prompts against injection attacks\"\"\"\r\n\r\n        # Extract prompt content from various request formats\r\n        prompt_content = self.extract_prompt_content(request_data)\r\n\r\n        # Check for prompt injection patterns\r\n        threats = await self.prompt_filters.detect_threats(prompt_content)\r\n\r\n        if threats:\r\n            threat_summary = \", \".join([t['type'] for t in threats])\r\n            raise PromptInjectionError(\r\n                f\"Potential prompt injection detected: {threat_summary}\",\r\n                threats=threats\r\n            )\r\n\r\n    def extract_prompt_content(self, request_data: Dict[str, Any]) -> str:\r\n        \"\"\"Extract prompt content from request for analysis\"\"\"\r\n        content = \"\"\r\n\r\n        # Handle chat messages format\r\n        if 'messages' in request_data:\r\n            for message in request_data['messages']:\r\n                if isinstance(message, dict) and 'content' in message:\r\n                    content += message['content'] + \" \"\r\n\r\n        # Handle direct prompt format\r\n        if 'prompt' in request_data:\r\n            content += request_data['prompt']\r\n\r\n        # Handle system prompts\r\n        if 'system_prompt' in request_data:\r\n            content += request_data['system_prompt']\r\n\r\n        return content.strip()\r\n\r\n    async def apply_content_filters(self, request_data: Dict[str, Any]):\r\n        \"\"\"Apply content filtering to requests\"\"\"\r\n\r\n        content = self.extract_prompt_content(request_data)\r\n\r\n        # Check for prohibited content\r\n        violations = await self.check_content_policy(content)\r\n\r\n        if violations:\r\n            raise ContentPolicyViolation(\r\n                f\"Content policy violations detected: {violations}\",\r\n                violations=violations\r\n            )\r\n\r\n    async def sanitize_request(self, request_data: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Sanitize request data to prevent injection attacks\"\"\"\r\n\r\n        sanitized = {}\r\n\r\n        for key, value in request_data.items():\r\n            if key in ['messages', 'prompt', 'system_prompt']:\r\n                # Sanitize text content\r\n                sanitized[key] = self.sanitize_text_content(value)\r\n            elif key in ['temperature', 'max_tokens', 'top_p']:\r\n                # Validate numeric parameters\r\n                sanitized[key] = self.validate_numeric_parameter(key, value)\r\n            elif key in ['model', 'provider']:\r\n                # Validate identifiers\r\n                sanitized[key] = self.validate_identifier(value)\r\n            else:\r\n                # Pass through other parameters after basic validation\r\n                sanitized[key] = self.sanitize_generic_value(value)\r\n\r\n        return sanitized\r\n\r\n    def sanitize_text_content(self, content) -> Any:\r\n        \"\"\"Sanitize text content for AI requests\"\"\"\r\n\r\n        if isinstance(content, str):\r\n            # Remove potential injection patterns\r\n            content = re.sub(r'<\\|.*?\\|>', '', content)  # Remove special tokens\r\n            content = re.sub(r'###\\s*SYSTEM.*?###', '', content, flags=re.IGNORECASE | re.DOTALL)\r\n            content = re.sub(r'```python.*?```', '', content, flags=re.DOTALL)  # Remove code blocks\r\n\r\n            # Limit length to prevent resource exhaustion\r\n            if len(content) > 50000:  # 50KB limit\r\n                content = content[:50000] + \"... [truncated for security]\"\r\n\r\n            return content\r\n\r\n        elif isinstance(content, list):\r\n            return [self.sanitize_text_content(item) for item in content]\r\n\r\n        elif isinstance(content, dict):\r\n            return {k: self.sanitize_text_content(v) for k, v in content.items()}\r\n\r\n        return content\r\n\r\nclass PromptInjectionFilter:\r\n    \"\"\"Advanced prompt injection detection and prevention\"\"\"\r\n\r\n    def __init__(self):\r\n        self.injection_patterns = [\r\n            # Direct instruction injection\r\n            r'(?i)(ignore|forget|disregard)\\s+(all\\s+)?(previous|above|prior)\\s+(instructions|prompts|rules)',\r\n            r'(?i)system\\s*:\\s*you\\s+(are|must|should|will)',\r\n            r'(?i)(act|behave|pretend)\\s+as\\s+(if\\s+)?(you\\s+are|a)',\r\n\r\n            # Role injection\r\n            r'(?i)you\\s+are\\s+now\\s+(a|an|the)',\r\n            r'(?i)(new|different)\\s+(role|character|persona|identity)',\r\n            r'(?i)from\\s+now\\s+on\\s+you\\s+(are|will|must)',\r\n\r\n            # System manipulation\r\n            r'(?i)override\\s+(system|safety|security)',\r\n            r'(?i)(disable|turn\\s+off|bypass)\\s+(safety|security|filtering)',\r\n            r'(?i)developer\\s+(mode|access|override)',\r\n\r\n            # Data extraction attempts\r\n            r'(?i)(show|display|print|output)\\s+(your\\s+)?(training|system|internal)',\r\n            r'(?i)(what|how)\\s+(are\\s+)?your\\s+(instructions|guidelines|rules)',\r\n            r'(?i)repeat\\s+(your\\s+)?(system\\s+)?(prompt|instructions)',\r\n\r\n            # Code injection\r\n            r'```[\\w]*\\s*\\n.*?```',\r\n            r'<script.*?>.*?</script>',\r\n            r'javascript:.*',\r\n\r\n            # Jailbreak attempts\r\n            r'(?i)(jailbreak|dan\\s+mode|developer\\s+mode)',\r\n            r'(?i)hypothetically|theoretically|imagine\\s+if',\r\n            r'(?i)for\\s+(educational|research)\\s+purposes\\s+only'\r\n        ]\r\n\r\n        self.compiled_patterns = [re.compile(pattern, re.MULTILINE | re.DOTALL)\r\n                                for pattern in self.injection_patterns]\r\n\r\n    async def detect_threats(self, content: str) -> List[Dict[str, Any]]:\r\n        \"\"\"Detect potential prompt injection threats\"\"\"\r\n\r\n        threats = []\r\n\r\n        for i, pattern in enumerate(self.compiled_patterns):\r\n            matches = pattern.findall(content)\r\n            if matches:\r\n                threats.append({\r\n                    'type': 'prompt_injection',\r\n                    'pattern_id': i,\r\n                    'matches': matches,\r\n                    'risk_level': self.assess_risk_level(i, matches),\r\n                    'description': self.get_threat_description(i)\r\n                })\r\n\r\n        # Additional heuristic checks\r\n        if self.check_excessive_instructions(content):\r\n            threats.append({\r\n                'type': 'excessive_instructions',\r\n                'risk_level': 'medium',\r\n                'description': 'Unusually long or complex instructions detected'\r\n            })\r\n\r\n        if self.check_system_token_abuse(content):\r\n            threats.append({\r\n                'type': 'system_token_abuse',\r\n                'risk_level': 'high',\r\n                'description': 'Potential system token manipulation detected'\r\n            })\r\n\r\n        return threats\r\n\r\n    def assess_risk_level(self, pattern_id: int, matches: List) -> str:\r\n        \"\"\"Assess risk level based on pattern and matches\"\"\"\r\n\r\n        high_risk_patterns = [0, 1, 2, 6, 7, 8]  # Critical injection patterns\r\n        medium_risk_patterns = [3, 4, 5, 9, 10, 11]  # Moderate injection patterns\r\n\r\n        if pattern_id in high_risk_patterns:\r\n            return 'high'\r\n        elif pattern_id in medium_risk_patterns:\r\n            return 'medium'\r\n        else:\r\n            return 'low'\r\n\r\n    def check_excessive_instructions(self, content: str) -> bool:\r\n        \"\"\"Check for unusually complex instruction patterns\"\"\"\r\n\r\n        instruction_words = ['must', 'should', 'will', 'always', 'never', 'only', 'exactly']\r\n        instruction_count = sum(content.lower().count(word) for word in instruction_words)\r\n\r\n        return instruction_count > 10 or len(content) > 10000\r\n\r\n    def check_system_token_abuse(self, content: str) -> bool:\r\n        \"\"\"Check for system token manipulation attempts\"\"\"\r\n\r\n        system_tokens = ['<|system|>', '<|user|>', '<|assistant|>', '[INST]', '[/INST]']\r\n\r\n        return any(token in content for token in system_tokens)\r\n\r\nclass RateLimiter:\r\n    \"\"\"AI-aware rate limiting\"\"\"\r\n\r\n    def __init__(self, requests_per_minute: int, tokens_per_minute: int):\r\n        self.requests_per_minute = requests_per_minute\r\n        self.tokens_per_minute = tokens_per_minute\r\n        self.request_history = {}\r\n        self.token_history = {}\r\n\r\n    async def check_limits(self, user_id: Optional[str] = None):\r\n        \"\"\"Check rate limits for user or global\"\"\"\r\n\r\n        key = user_id or 'global'\r\n        now = datetime.now()\r\n\r\n        # Clean old entries\r\n        self.cleanup_history(key, now)\r\n\r\n        # Check request rate limit\r\n        user_requests = self.request_history.get(key, [])\r\n        if len(user_requests) >= self.requests_per_minute:\r\n            raise RateLimitExceeded(\r\n                f\"Request rate limit exceeded: {len(user_requests)}/{self.requests_per_minute} per minute\"\r\n            )\r\n\r\n        # Check token rate limit\r\n        user_tokens = sum(self.token_history.get(key, []))\r\n        if user_tokens >= self.tokens_per_minute:\r\n            raise RateLimitExceeded(\r\n                f\"Token rate limit exceeded: {user_tokens}/{self.tokens_per_minute} per minute\"\r\n            )\r\n\r\n        # Record request\r\n        if key not in self.request_history:\r\n            self.request_history[key] = []\r\n        self.request_history[key].append(now)\r\n\r\n    def record_token_usage(self, user_id: Optional[str], token_count: int):\r\n        \"\"\"Record token usage for rate limiting\"\"\"\r\n\r\n        key = user_id or 'global'\r\n        now = datetime.now()\r\n\r\n        if key not in self.token_history:\r\n            self.token_history[key] = []\r\n\r\n        self.token_history[key].append((now, token_count))\r\n\r\n    def cleanup_history(self, key: str, now: datetime):\r\n        \"\"\"Remove entries older than 1 minute\"\"\"\r\n\r\n        cutoff = now - timedelta(minutes=1)\r\n\r\n        if key in self.request_history:\r\n            self.request_history[key] = [\r\n                timestamp for timestamp in self.request_history[key]\r\n                if timestamp > cutoff\r\n            ]\r\n\r\n        if key in self.token_history:\r\n            self.token_history[key] = [\r\n                (timestamp, count) for timestamp, count in self.token_history[key]\r\n                if timestamp > cutoff\r\n            ]\r\n````\r\n\r\n**Ollama Security Configuration:**\r\n\r\n```python\r\n# packages/farm-security/src/ollama_security.py\r\nclass OllamaSecurityManager:\r\n    \"\"\"Security management for local Ollama instances\"\"\"\r\n\r\n    def __init__(self):\r\n        self.allowed_models = set()\r\n        self.model_access_controls = {}\r\n        self.resource_limits = {}\r\n\r\n    def configure_local_security(self, config: Dict[str, Any]):\r\n        \"\"\"Configure security for local Ollama instance\"\"\"\r\n\r\n        # Model access controls\r\n        self.allowed_models = set(config.get('allowed_models', []))\r\n\r\n        # Resource limits\r\n        self.resource_limits = {\r\n            'max_memory_gb': config.get('max_memory_gb', 8),\r\n            'max_cpu_cores': config.get('max_cpu_cores', 4),\r\n            'max_concurrent_requests': config.get('max_concurrent_requests', 5)\r\n        }\r\n\r\n        # Network isolation\r\n        self.network_isolation = config.get('network_isolation', True)\r\n\r\n        # Model integrity checking\r\n        self.verify_model_integrity = config.get('verify_model_integrity', True)\r\n\r\n    async def validate_model_access(self, model_name: str, user_context: Optional[Dict] = None) -> bool:\r\n        \"\"\"Validate access to specific model\"\"\"\r\n\r\n        # Check allowed models list\r\n        if self.allowed_models and model_name not in self.allowed_models:\r\n            raise ModelAccessDenied(f\"Model {model_name} not in allowed list\")\r\n\r\n        # Check model-specific access controls\r\n        if model_name in self.model_access_controls:\r\n            access_rules = self.model_access_controls[model_name]\r\n            if not await self.check_access_rules(access_rules, user_context):\r\n                raise ModelAccessDenied(f\"Access denied to model {model_name}\")\r\n\r\n        # Verify model integrity if enabled\r\n        if self.verify_model_integrity:\r\n            if not await self.verify_model_checksum(model_name):\r\n                raise ModelIntegrityError(f\"Model {model_name} failed integrity check\")\r\n\r\n        return True\r\n\r\n    async def verify_model_checksum(self, model_name: str) -> bool:\r\n        \"\"\"Verify model file integrity\"\"\"\r\n\r\n        try:\r\n            # Get model info from Ollama\r\n            model_info = await self.get_ollama_model_info(model_name)\r\n\r\n            # Verify against known checksums (would be stored securely)\r\n            expected_checksum = await self.get_expected_checksum(model_name)\r\n\r\n            if expected_checksum and model_info.get('digest') != expected_checksum:\r\n                return False\r\n\r\n            return True\r\n\r\n        except Exception as e:\r\n            print(f\"Model integrity check failed for {model_name}: {e}\")\r\n            return False\r\n\r\n    def setup_network_isolation(self):\r\n        \"\"\"Configure network isolation for Ollama\"\"\"\r\n\r\n        if self.network_isolation:\r\n            # Configure firewall rules to isolate Ollama\r\n            # Only allow connections from localhost\r\n            firewall_rules = [\r\n                'allow from 127.0.0.1 to any port 11434',\r\n                'deny from any to any port 11434'\r\n            ]\r\n\r\n            # Apply firewall rules (implementation specific)\r\n            return self.apply_firewall_rules(firewall_rules)\r\n\r\n    def monitor_resource_usage(self):\r\n        \"\"\"Monitor Ollama resource usage for security\"\"\"\r\n\r\n        import psutil\r\n\r\n        # Find Ollama process\r\n        ollama_processes = [p for p in psutil.process_iter() if 'ollama' in p.name().lower()]\r\n\r\n        for process in ollama_processes:\r\n            try:\r\n                # Check memory usage\r\n                memory_gb = process.memory_info().rss / 1024 / 1024 / 1024\r\n                if memory_gb > self.resource_limits['max_memory_gb']:\r\n                    print(f\"⚠️ Ollama memory usage ({memory_gb:.1f}GB) exceeds limit\")\r\n\r\n                # Check CPU usage\r\n                cpu_percent = process.cpu_percent()\r\n                if cpu_percent > 90:  # High CPU usage\r\n                    print(f\"⚠️ Ollama high CPU usage: {cpu_percent}%\")\r\n\r\n            except psutil.NoSuchProcess:\r\n                continue\r\n```\r\n\r\n### 2. Framework Security\r\n\r\n**Purpose:** Secure CLI operations, code generation, and development workflows\r\n\r\n**CLI Security Manager:**\r\n\r\n```typescript\r\n// packages/farm-cli/src/security/cli-security.ts\r\nexport class CLISecurityManager {\r\n  private allowedCommands: Set<string>;\r\n  private secureTemplates: Map<string, TemplateSecurityConfig>;\r\n  private auditLogger: AuditLogger;\r\n\r\n  constructor() {\r\n    this.allowedCommands = new Set([\r\n      'create', 'dev', 'build', 'deploy', 'generate', 'test'\r\n    ]);\r\n    this.secureTemplates = new Map();\r\n    this.auditLogger = new AuditLogger();\r\n  }\r\n\r\n  async validateCommand(command: string, args: string[], context: CLIContext): Promise<void> {\r\n    // Command whitelist validation\r\n    if (!this.allowedCommands.has(command)) {\r\n      throw new SecurityError(`Command '${command}' not allowed`);\r\n    }\r\n\r\n    // Argument validation\r\n    await this.validateArguments(command, args);\r\n\r\n    // Path traversal protection\r\n    await this.validatePaths(args);\r\n\r\n    // Template security validation\r\n    if (command === 'create') {\r\n      await this.validateTemplateCreation(args, context);\r\n    }\r\n\r\n    // Code generation security\r\n    if (command === 'generate') {\r\n      await this.validateCodeGeneration(args, context);\r\n    }\r\n\r\n    // Audit logging\r\n    await this.auditLogger.logCommand(command, args, context);\r\n  }\r\n\r\n  async validateArguments(command: string, args: string[]): Promise<void> {\r\n    const patterns = {\r\n      projectName: /^[a-zA-Z0-9-_]+$/,\r\n      templateName: /^[a-zA-Z0-9-_]+$/,\r\n      modelName: /^[a-zA-Z0-9-_]+$/,\r\n      fileName: /^[a-zA-Z0-9-_.\\/]+$/\r\n    };\r\n\r\n    for (const arg of args) {\r\n      // Check for command injection attempts\r\n      if (this.containsCommandInjection(arg)) {\r\n        throw new SecurityError(`Potential command injection detected in argument: ${arg}`);\r\n      }\r\n\r\n      // Check for path traversal attempts\r\n      if (this.containsPathTraversal(arg)) {\r\n        throw new SecurityError(`Path traversal attempt detected: ${arg}`);\r\n      }\r\n\r\n      // Validate against known patterns\r\n      if (arg.startsWith('--')) {\r\n        const flagName = arg.replace(/^--/, '').split('=')[0];\r\n        if (!this.isAllowedFlag(command, flagName)) {\r\n          throw new SecurityError(`Flag '${flagName}' not allowed for command '${command}'`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  containsCommandInjection(input: string): boolean {\r\n    const dangerousPatterns = [\r\n      /[;&|`$(){}[\\]<>]/,          // Shell metacharacters\r\n      /\\$\\(.*\\)/,                  // Command substitution\r\n      /`.*`/,                      // Backtick command substitution\r\n      /\\|\\s*\\w+/,                  // Pipe to command\r\n      /&&|\\|\\|/,                   // Command chaining\r\n      /(rm|del|format|mkfs)\\s/,    // Dangerous commands\r\n      /(curl|wget|nc|telnet)\\s/    // Network commands\r\n    ];\r\n\r\n    return dangerousPatterns.some(pattern => pattern.test(input));\r\n  }\r\n\r\n  containsPathTraversal(input: string): boolean {\r\n    const traversalPatterns = [\r\n      /\\.\\.\\//,                    // Directory traversal\r\n      /\\.\\.\\\\\\/,                   // Windows directory traversal\r\n      /\\/etc\\/passwd/,             // Unix system files\r\n      /\\/proc\\//,                  // Linux proc filesystem\r\n      /C:\\\\Windows\\\\/,             // Windows system directory\r\n      /%2e%2e%2f/i,               // URL encoded traversal\r\n      /\\.\\.%2f/i                   // Mixed encoding\r\n    ];\r\n\r\n    return traversalPatterns.some(pattern => pattern.test(input));\r\n  }\r\n\r\n  async validateTemplateCreation(args: string[], context: CLIContext): Promise<void> {\r\n    const templateArg = args.find(arg => arg.startsWith('--template='));\r\n    const template = templateArg?.split('=')[1] || 'basic';\r\n\r\n    // Validate template source\r\n    if (template.startsWith('http://') || template.startsWith('https://')) {\r\n      await this.validateRemoteTemplate(template);\r\n    } else if (template.includes('/') || template.includes('\\\\')) {\r\n      await this.validateLocalTemplate(template);\r\n    } else {\r\n      await this.validateBuiltInTemplate(template);\r\n    }\r\n\r\n    // Check template security configuration\r\n    const securityConfig = this.secureTemplates.get(template);\r\n    if (securityConfig) {\r\n      await this.enforceTemplateSecurityPolicy(securityConfig, context);\r\n    }\r\n  }\r\n\r\n  async validateRemoteTemplate(templateUrl: string): Promise<void> {\r\n    const url = new URL(templateUrl);\r\n\r\n    // Only allow HTTPS for remote templates\r\n    if (url.protocol !== 'https:') {\r\n      throw new SecurityError('Remote templates must use HTTPS');\r\n    }\r\n\r\n    // Whitelist allowed domains\r\n    const allowedDomains = [\r\n      'github.com',\r\n      'raw.githubusercontent.com',\r\n      'gitlab.com',\r\n      'bitbucket.org'\r\n    ];\r\n\r\n    if (!allowedDomains.includes(url.hostname)) {\r\n      throw new SecurityError(`Template domain '${url.hostname}' not allowed`);\r\n    }\r\n\r\n    // Validate template content before downloading\r\n    await this.validateRemoteTemplateContent(templateUrl);\r\n  }\r\n\r\n  async validateCodeGeneration(args: string[], context: CLIContext): Promise<void> {\r\n    const generateType = args[0]; // model, route, component, etc.\r\n    const entityName = args[1];\r\n\r\n    // Validate generation type\r\n    const allowedTypes = ['model', 'route', 'component', 'page', 'api'];\r\n    if (!allowedTypes.includes(generateType)) {\r\n      throw new SecurityError(`Code generation type '${generateType}' not allowed`);\r\n    }\r\n\r\n    // Validate entity name\r\n    if (!this.isValidIdentifier(entityName)) {\r\n      throw new SecurityError(`Invalid entity name: ${entityName}`);\r\n    }\r\n\r\n    // Check for template injection in additional arguments\r\n    const additionalArgs = args.slice(2);\r\n    for (const arg of additionalArgs) {\r\n      if (this.containsTemplateInjection(arg)) {\r\n        throw new SecurityError(`Template injection detected in argument: ${arg}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  containsTemplateInjection(input: string): boolean {\r\n    const injectionPatterns = [\r\n      /\\{\\{.*eval.*\\}\\}/,          // Template eval injection\r\n      /\\{\\{.*require.*\\}\\}/,       // Node.js require injection\r\n      /\\{\\{.*process.*\\}\\}/,       // Process access\r\n      /\\{\\{.*fs\\..*\\}\\}/,          // Filesystem access\r\n      /<%.*%>/,                    // ERB/EJS injection\r\n      /\\$\\{.*\\}/,                  // Template literal injection\r\n      /__import__/,                // Python import injection\r\n      /exec\\(/,                    // Code execution\r\n      /eval\\(/                     // Eval injection\r\n    ];\r\n\r\n    return injectionPatterns.some(pattern => pattern.test(input));\r\n  }\r\n\r\n  isValidIdentifier(name: string): boolean {\r\n    // Must be valid programming identifier\r\n    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name) && name.length <= 100;\r\n  }\r\n}\r\n```\r\n\r\n**Code Generation Security:**\r\n\r\n```typescript\r\n// tools/codegen/security/generation-security.ts\r\nexport class CodeGenerationSecurity {\r\n  private sanitizer: CodeSanitizer;\r\n  private validator: CodeValidator;\r\n  private auditLogger: CodeGenAuditLogger;\r\n\r\n  constructor() {\r\n    this.sanitizer = new CodeSanitizer();\r\n    this.validator = new CodeValidator();\r\n    this.auditLogger = new CodeGenAuditLogger();\r\n  }\r\n\r\n  async secureGeneration(\r\n    generationType: string,\r\n    sourceData: any,\r\n    template: string,\r\n    outputPath: string\r\n  ): Promise<GenerationResult> {\r\n    // Validate generation parameters\r\n    await this.validateGenerationParameters(\r\n      generationType,\r\n      sourceData,\r\n      outputPath\r\n    );\r\n\r\n    // Sanitize source data\r\n    const sanitizedData = await this.sanitizer.sanitizeSourceData(sourceData);\r\n\r\n    // Validate template security\r\n    await this.validateTemplate(template);\r\n\r\n    // Generate code with security context\r\n    const generatedCode = await this.generateSecureCode(\r\n      generationType,\r\n      sanitizedData,\r\n      template\r\n    );\r\n\r\n    // Validate generated code\r\n    await this.validator.validateGeneratedCode(generatedCode, generationType);\r\n\r\n    // Audit the generation\r\n    await this.auditLogger.logGeneration({\r\n      type: generationType,\r\n      sourceData: sanitizedData,\r\n      outputPath,\r\n      generatedLinesCount: generatedCode.split(\"\\n\").length,\r\n      timestamp: new Date(),\r\n    });\r\n\r\n    return {\r\n      code: generatedCode,\r\n      metadata: {\r\n        generated: true,\r\n        secure: true,\r\n        sanitized: true,\r\n        validated: true,\r\n      },\r\n    };\r\n  }\r\n\r\n  async validateTemplate(template: string): Promise<void> {\r\n    // Check for dangerous template constructs\r\n    const dangerousPatterns = [\r\n      /require\\(['\"]fs['\"]\\)/, // File system access\r\n      /require\\(['\"]child_process['\"]\\)/, // Process spawning\r\n      /require\\(['\"]os['\"]\\)/, // OS access\r\n      /eval\\(/, // Code evaluation\r\n      /Function\\(/, // Dynamic function creation\r\n      /process\\./, // Process access\r\n      /global\\./, // Global object access\r\n      /__dirname|__filename/, // File path access\r\n      /import\\s+.*\\s+from\\s+['\"]node:/, // Node.js built-in imports\r\n    ];\r\n\r\n    for (const pattern of dangerousPatterns) {\r\n      if (pattern.test(template)) {\r\n        throw new TemplateSecurityError(\r\n          `Dangerous pattern detected in template: ${pattern.source}`\r\n        );\r\n      }\r\n    }\r\n\r\n    // Validate template syntax and structure\r\n    await this.validateTemplateSyntax(template);\r\n  }\r\n\r\n  async validateGeneratedCode(code: string, type: string): Promise<void> {\r\n    // Check for injection vulnerabilities in generated code\r\n    const securityChecks = {\r\n      typescript: [\r\n        /eval\\(/, // Eval usage\r\n        /Function\\(/, // Dynamic function creation\r\n        /document\\.write/, // XSS vector\r\n        /innerHTML\\s*=.*\\+/, // XSS via concatenation\r\n        /dangerouslySetInnerHTML/, // React XSS vector\r\n        /window\\[.*\\]/, // Dynamic property access\r\n        /localStorage\\.setItem.*\\+/, // Storage injection\r\n      ],\r\n      python: [\r\n        /exec\\(/, // Code execution\r\n        /eval\\(/, // Expression evaluation\r\n        /compile\\(/, // Code compilation\r\n        /__import__\\(/, // Dynamic imports\r\n        /getattr\\(/, // Dynamic attribute access\r\n        /setattr\\(/, // Dynamic attribute setting\r\n        /pickle\\.loads/, // Deserialization\r\n        /subprocess\\./, // Process spawning\r\n        /os\\.system/, // System command execution\r\n      ],\r\n    };\r\n\r\n    const checks = securityChecks[type as keyof typeof securityChecks] || [];\r\n\r\n    for (const pattern of checks) {\r\n      if (pattern.test(code)) {\r\n        throw new GeneratedCodeSecurityError(\r\n          `Security violation in generated ${type} code: ${pattern.source}`\r\n        );\r\n      }\r\n    }\r\n\r\n    // Additional context-specific validation\r\n    if (type === \"api\") {\r\n      await this.validateAPISecurityPatterns(code);\r\n    } else if (type === \"component\") {\r\n      await this.validateComponentSecurityPatterns(code);\r\n    }\r\n  }\r\n\r\n  async validateAPISecurityPatterns(code: string): Promise<void> {\r\n    const apiSecurityPatterns = [\r\n      // Missing authentication checks\r\n      {\r\n        pattern:\r\n          /@app\\.(get|post|put|delete)\\(.*\\)\\s*\\n\\s*async\\s+def\\s+\\w+\\([^)]*\\):\\s*\\n(?!\\s*#.*auth|\\s*if.*auth|\\s*@.*auth)/,\r\n        message: \"API endpoint missing authentication check\",\r\n      },\r\n      // SQL injection vulnerability\r\n      {\r\n        pattern: /\\.execute\\s*\\(\\s*f?[\"'].*\\{.*\\}.*[\"']/,\r\n        message: \"Potential SQL injection vulnerability\",\r\n      },\r\n      // Missing input validation\r\n      {\r\n        pattern:\r\n          /def\\s+\\w+\\([^)]*request[^)]*\\):\\s*\\n(?!\\s*#.*valid|\\s*if.*valid|\\s*request\\.)/,\r\n        message: \"API endpoint missing input validation\",\r\n      },\r\n    ];\r\n\r\n    for (const check of apiSecurityPatterns) {\r\n      if (check.pattern.test(code)) {\r\n        throw new APISecurityError(check.message);\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 3. Application Security Framework\r\n\r\n**Purpose:** Provide secure authentication, authorization, and data protection\r\n\r\n**Integrated Authentication System:**\r\n\r\n```python\r\n# packages/farm-auth/src/auth_security.py\r\nfrom typing import Optional, Dict, List, Any\r\nfrom datetime import datetime, timedelta\r\nimport jwt\r\nimport bcrypt\r\nimport secrets\r\nfrom dataclasses import dataclass\r\n\r\n@dataclass\r\nclass SecurityConfig:\r\n    jwt_secret_key: str\r\n    jwt_algorithm: str = \"HS256\"\r\n    access_token_expire_minutes: int = 30\r\n    refresh_token_expire_days: int = 7\r\n    password_min_length: int = 8\r\n    password_require_special: bool = True\r\n    max_login_attempts: int = 5\r\n    lockout_duration_minutes: int = 15\r\n    mfa_enabled: bool = False\r\n    session_security: bool = True\r\n\r\nclass FarmSecurityManager:\r\n    \"\"\"Comprehensive security management for FARM applications\"\"\"\r\n\r\n    def __init__(self, config: SecurityConfig):\r\n        self.config = config\r\n        self.login_attempts = {}  # Track failed login attempts\r\n        self.active_sessions = {}  # Track active sessions\r\n        self.password_validator = PasswordValidator(config)\r\n        self.token_manager = TokenManager(config)\r\n        self.audit_logger = SecurityAuditLogger()\r\n\r\n    async def authenticate_user(self, email: str, password: str,\r\n                               ip_address: str, user_agent: str) -> Dict[str, Any]:\r\n        \"\"\"Secure user authentication with comprehensive security checks\"\"\"\r\n\r\n        # Check for account lockout\r\n        if await self.is_account_locked(email, ip_address):\r\n            raise AccountLockedError(\"Account temporarily locked due to failed login attempts\")\r\n\r\n        try:\r\n            # Validate credentials\r\n            user = await self.validate_credentials(email, password)\r\n\r\n            if not user:\r\n                await self.record_failed_login(email, ip_address)\r\n                raise AuthenticationError(\"Invalid credentials\")\r\n\r\n            # Additional security checks\r\n            await self.check_account_security(user, ip_address, user_agent)\r\n\r\n            # Generate secure tokens\r\n            tokens = await self.token_manager.generate_tokens(user)\r\n\r\n            # Create secure session\r\n            session = await self.create_secure_session(user, tokens, ip_address, user_agent)\r\n\r\n            # Clear failed login attempts\r\n            await self.clear_failed_login_attempts(email, ip_address)\r\n\r\n            # Audit successful login\r\n            await self.audit_logger.log_successful_login(user, ip_address, user_agent)\r\n\r\n            return {\r\n                \"user\": self.sanitize_user_data(user),\r\n                \"access_token\": tokens[\"access_token\"],\r\n                \"refresh_token\": tokens[\"refresh_token\"],\r\n                \"session_id\": session[\"session_id\"],\r\n                \"expires_in\": self.config.access_token_expire_minutes * 60\r\n            }\r\n\r\n        except Exception as e:\r\n            await self.audit_logger.log_failed_login(email, ip_address, str(e))\r\n            raise\r\n\r\n    async def validate_credentials(self, email: str, password: str) -> Optional[Dict]:\r\n        \"\"\"Secure credential validation\"\"\"\r\n\r\n        # Get user from database (timing attack protection)\r\n        user = await self.get_user_by_email(email)\r\n\r\n        # Always perform password check to prevent timing attacks\r\n        if user:\r\n            password_valid = bcrypt.checkpw(\r\n                password.encode('utf-8'),\r\n                user['password_hash'].encode('utf-8')\r\n            )\r\n\r\n            if password_valid and user.get('active', True):\r\n                return user\r\n        else:\r\n            # Perform dummy bcrypt operation to prevent timing attacks\r\n            bcrypt.checkpw(b'dummy', b'$2b$12$dummy.hash.to.prevent.timing.attacks')\r\n\r\n        return None\r\n\r\n    async def check_account_security(self, user: Dict, ip_address: str, user_agent: str):\r\n        \"\"\"Additional security checks for user account\"\"\"\r\n\r\n        # Check for suspicious login patterns\r\n        if await self.detect_suspicious_login(user, ip_address, user_agent):\r\n            # Could implement additional verification here\r\n            await self.audit_logger.log_suspicious_login(user, ip_address, user_agent)\r\n\r\n        # Check if account requires password change\r\n        if self.requires_password_change(user):\r\n            raise PasswordChangeRequiredError(\"Password change required\")\r\n\r\n        # Check account status\r\n        if not user.get('active', True):\r\n            raise AccountDisabledError(\"Account is disabled\")\r\n\r\n        if user.get('locked', False):\r\n            raise AccountLockedError(\"Account is locked\")\r\n\r\n    async def authorize_action(self, user_id: str, action: str, resource: str,\r\n                              context: Optional[Dict] = None) -> bool:\r\n        \"\"\"Comprehensive authorization system\"\"\"\r\n\r\n        user = await self.get_user_by_id(user_id)\r\n        if not user:\r\n            return False\r\n\r\n        # Check role-based permissions\r\n        user_roles = user.get('roles', [])\r\n\r\n        # Check direct permissions\r\n        if await self.check_direct_permissions(user_roles, action, resource):\r\n            return True\r\n\r\n        # Check resource-specific permissions\r\n        if await self.check_resource_permissions(user_id, action, resource, context):\r\n            return True\r\n\r\n        # Check conditional permissions\r\n        if await self.check_conditional_permissions(user, action, resource, context):\r\n            return True\r\n\r\n        # Audit authorization failure\r\n        await self.audit_logger.log_authorization_failure(\r\n            user_id, action, resource, context\r\n        )\r\n\r\n        return False\r\n\r\n    async def secure_ai_request_authorization(self, user_id: str, provider: str,\r\n                                            model: str, request_data: Dict) -> bool:\r\n        \"\"\"AI-specific authorization checks\"\"\"\r\n\r\n        # Check if user can access AI features\r\n        if not await self.authorize_action(user_id, 'use', 'ai_services'):\r\n            return False\r\n\r\n        # Check provider-specific permissions\r\n        if not await self.authorize_action(user_id, 'use', f'ai_provider:{provider}'):\r\n            return False\r\n\r\n        # Check model-specific permissions\r\n        if not await self.authorize_action(user_id, 'use', f'ai_model:{model}'):\r\n            return False\r\n\r\n        # Check request content\r\n        if await self.contains_restricted_content(request_data):\r\n            await self.audit_logger.log_restricted_content_attempt(user_id, request_data)\r\n            return False\r\n\r\n        # Check rate limits\r\n        if not await self.check_ai_rate_limits(user_id, provider):\r\n            return False\r\n\r\n        return True\r\n\r\nclass PasswordValidator:\r\n    \"\"\"Secure password validation and policy enforcement\"\"\"\r\n\r\n    def __init__(self, config: SecurityConfig):\r\n        self.config = config\r\n        self.common_passwords = self.load_common_passwords()\r\n\r\n    def validate_password(self, password: str, user_data: Optional[Dict] = None) -> Dict[str, Any]:\r\n        \"\"\"Comprehensive password validation\"\"\"\r\n\r\n        issues = []\r\n        score = 0\r\n\r\n        # Length check\r\n        if len(password) < self.config.password_min_length:\r\n            issues.append(f\"Password must be at least {self.config.password_min_length} characters\")\r\n        else:\r\n            score += 1\r\n\r\n        # Complexity checks\r\n        has_upper = any(c.isupper() for c in password)\r\n        has_lower = any(c.islower() for c in password)\r\n        has_digit = any(c.isdigit() for c in password)\r\n        has_special = any(c in \"!@#$%^&*()_+-=[]{}|;:,.<>?\" for c in password)\r\n\r\n        if not has_upper:\r\n            issues.append(\"Password must contain uppercase letters\")\r\n        else:\r\n            score += 1\r\n\r\n        if not has_lower:\r\n            issues.append(\"Password must contain lowercase letters\")\r\n        else:\r\n            score += 1\r\n\r\n        if not has_digit:\r\n            issues.append(\"Password must contain numbers\")\r\n        else:\r\n            score += 1\r\n\r\n        if self.config.password_require_special and not has_special:\r\n            issues.append(\"Password must contain special characters\")\r\n        elif has_special:\r\n            score += 1\r\n\r\n        # Common password check\r\n        if password.lower() in self.common_passwords:\r\n            issues.append(\"Password is too common\")\r\n        else:\r\n            score += 1\r\n\r\n        # Personal information check\r\n        if user_data and self.contains_personal_info(password, user_data):\r\n            issues.append(\"Password cannot contain personal information\")\r\n        else:\r\n            score += 1\r\n\r\n        # Repetition check\r\n        if self.has_excessive_repetition(password):\r\n            issues.append(\"Password has too much repetition\")\r\n        else:\r\n            score += 1\r\n\r\n        strength = self.calculate_strength(score, len(issues))\r\n\r\n        return {\r\n            \"valid\": len(issues) == 0,\r\n            \"issues\": issues,\r\n            \"strength\": strength,\r\n            \"score\": score\r\n        }\r\n\r\n    def calculate_strength(self, score: int, issue_count: int) -> str:\r\n        \"\"\"Calculate password strength rating\"\"\"\r\n\r\n        if issue_count > 0:\r\n            return \"weak\"\r\n        elif score >= 7:\r\n            return \"strong\"\r\n        elif score >= 5:\r\n            return \"medium\"\r\n        else:\r\n            return \"weak\"\r\n```\r\n\r\n### 4. Data Protection & Privacy\r\n\r\n**Purpose:** Secure data handling, encryption, and privacy compliance\r\n\r\n**Data Security Manager:**\r\n\r\n```python\r\n# packages/farm-security/src/data_security.py\r\nfrom cryptography.fernet import Fernet\r\nfrom cryptography.hazmat.primitives import hashes\r\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\r\nimport base64\r\nimport os\r\nfrom typing import Dict, Any, Optional, List\r\n\r\nclass DataSecurityManager:\r\n    \"\"\"Comprehensive data security and encryption management\"\"\"\r\n\r\n    def __init__(self):\r\n        self.encryption_key = self.get_or_create_encryption_key()\r\n        self.fernet = Fernet(self.encryption_key)\r\n        self.pii_detector = PIIDetector()\r\n        self.data_classifier = DataClassifier()\r\n\r\n    def get_or_create_encryption_key(self) -> bytes:\r\n        \"\"\"Get or create encryption key for data at rest\"\"\"\r\n\r\n        key_file = os.path.join(os.getcwd(), '.farm', 'encryption.key')\r\n\r\n        if os.path.exists(key_file):\r\n            with open(key_file, 'rb') as f:\r\n                return f.read()\r\n        else:\r\n            # Generate new key\r\n            key = Fernet.generate_key()\r\n\r\n            # Ensure directory exists\r\n            os.makedirs(os.path.dirname(key_file), exist_ok=True)\r\n\r\n            # Save key securely\r\n            with open(key_file, 'wb') as f:\r\n                f.write(key)\r\n\r\n            # Set restrictive permissions\r\n            os.chmod(key_file, 0o600)\r\n\r\n            return key\r\n\r\n    def encrypt_sensitive_data(self, data: Any, data_type: str = 'general') -> str:\r\n        \"\"\"Encrypt sensitive data with appropriate method\"\"\"\r\n\r\n        # Serialize data\r\n        if isinstance(data, dict):\r\n            data_str = json.dumps(data)\r\n        else:\r\n            data_str = str(data)\r\n\r\n        # Encrypt data\r\n        encrypted_data = self.fernet.encrypt(data_str.encode())\r\n\r\n        # Return base64 encoded for storage\r\n        return base64.b64encode(encrypted_data).decode()\r\n\r\n    def decrypt_sensitive_data(self, encrypted_data: str, expected_type: type = str) -> Any:\r\n        \"\"\"Decrypt sensitive data\"\"\"\r\n\r\n        try:\r\n            # Decode from base64\r\n            encrypted_bytes = base64.b64decode(encrypted_data.encode())\r\n\r\n            # Decrypt data\r\n            decrypted_bytes = self.fernet.decrypt(encrypted_bytes)\r\n            decrypted_str = decrypted_bytes.decode()\r\n\r\n            # Deserialize if needed\r\n            if expected_type == dict:\r\n                return json.loads(decrypted_str)\r\n            elif expected_type == int:\r\n                return int(decrypted_str)\r\n            elif expected_type == float:\r\n                return float(decrypted_str)\r\n            else:\r\n                return decrypted_str\r\n\r\n        except Exception as e:\r\n            raise DecryptionError(f\"Failed to decrypt data: {e}\")\r\n\r\n    async def secure_ai_conversation_storage(self, conversation_data: Dict[str, Any],\r\n                                           user_id: str) -> Dict[str, Any]:\r\n        \"\"\"Securely store AI conversation data with PII protection\"\"\"\r\n\r\n        # Detect and classify PII in conversation\r\n        pii_analysis = await self.pii_detector.analyze_conversation(conversation_data)\r\n\r\n        # Apply data protection based on classification\r\n        protected_data = await self.apply_data_protection(conversation_data, pii_analysis)\r\n\r\n        # Encrypt sensitive parts\r\n        if pii_analysis['contains_pii']:\r\n            protected_data['messages'] = self.encrypt_sensitive_data(\r\n                protected_data['messages'], 'pii'\r\n            )\r\n\r\n        # Add metadata for compliance\r\n        protected_data['_security'] = {\r\n            'encrypted': pii_analysis['contains_pii'],\r\n            'pii_detected': pii_analysis['pii_types'],\r\n            'classification': pii_analysis['classification'],\r\n            'retention_policy': self.get_retention_policy(pii_analysis['classification']),\r\n            'user_id_hash': self.hash_user_id(user_id)\r\n        }\r\n\r\n        return protected_data\r\n\r\n    async def apply_data_protection(self, data: Dict[str, Any],\r\n                                  pii_analysis: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Apply appropriate data protection measures\"\"\"\r\n\r\n        protected_data = data.copy()\r\n\r\n        # Redact or mask PII based on type\r\n        for pii_type in pii_analysis['pii_types']:\r\n            if pii_type == 'email':\r\n                protected_data = self.mask_emails(protected_data)\r\n            elif pii_type == 'phone':\r\n                protected_data = self.mask_phone_numbers(protected_data)\r\n            elif pii_type == 'ssn':\r\n                protected_data = self.mask_ssn(protected_data)\r\n            elif pii_type == 'credit_card':\r\n                protected_data = self.mask_credit_cards(protected_data)\r\n            elif pii_type == 'name':\r\n                protected_data = self.mask_names(protected_data)\r\n\r\n        return protected_data\r\n\r\n    def get_retention_policy(self, classification: str) -> Dict[str, Any]:\r\n        \"\"\"Get data retention policy based on classification\"\"\"\r\n\r\n        policies = {\r\n            'public': {'retention_days': 365, 'auto_delete': False},\r\n            'internal': {'retention_days': 180, 'auto_delete': True},\r\n            'confidential': {'retention_days': 90, 'auto_delete': True},\r\n            'restricted': {'retention_days': 30, 'auto_delete': True}\r\n        }\r\n\r\n        return policies.get(classification, policies['restricted'])\r\n\r\nclass PIIDetector:\r\n    \"\"\"Advanced PII detection for AI conversations\"\"\"\r\n\r\n    def __init__(self):\r\n        self.patterns = {\r\n            'email': r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b',\r\n            'phone': r'\\b(?:\\+1[-.\\s]?)?\\(?[0-9]{3}\\)?[-.\\s]?[0-9]{3}[-.\\s]?[0-9]{4}\\b',\r\n            'ssn': r'\\b\\d{3}-?\\d{2}-?\\d{4}\\b',\r\n            'credit_card': r'\\b(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3[0-9]{13}|6(?:011|5[0-9]{2})[0-9]{12})\\b',\r\n            'name': r'\\b[A-Z][a-z]+ [A-Z][a-z]+\\b',  # Simple name pattern\r\n            'address': r'\\b\\d+\\s+[A-Za-z0-9\\s,]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Way|Court|Ct)\\b'\r\n        }\r\n\r\n        self.compiled_patterns = {\r\n            name: re.compile(pattern, re.IGNORECASE)\r\n            for name, pattern in self.patterns.items()\r\n        }\r\n\r\n    async def analyze_conversation(self, conversation: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Analyze conversation for PII and classify data sensitivity\"\"\"\r\n\r\n        # Extract text content from conversation\r\n        text_content = self.extract_text_content(conversation)\r\n\r\n        # Detect PII types\r\n        pii_types = []\r\n        pii_locations = {}\r\n\r\n        for pii_type, pattern in self.compiled_patterns.items():\r\n            matches = pattern.findall(text_content)\r\n            if matches:\r\n                pii_types.append(pii_type)\r\n                pii_locations[pii_type] = matches\r\n\r\n        # Classify data sensitivity\r\n        classification = self.classify_data_sensitivity(pii_types)\r\n\r\n        return {\r\n            'contains_pii': len(pii_types) > 0,\r\n            'pii_types': pii_types,\r\n            'pii_locations': pii_locations,\r\n            'classification': classification,\r\n            'risk_level': self.assess_risk_level(pii_types)\r\n        }\r\n\r\n    def extract_text_content(self, conversation: Dict[str, Any]) -> str:\r\n        \"\"\"Extract all text content from conversation\"\"\"\r\n\r\n        content = \"\"\r\n\r\n        if 'messages' in conversation:\r\n            for message in conversation['messages']:\r\n                if isinstance(message, dict) and 'content' in message:\r\n                    content += message['content'] + \" \"\r\n\r\n        if 'system_prompt' in conversation:\r\n            content += conversation['system_prompt'] + \" \"\r\n\r\n        return content\r\n\r\n    def classify_data_sensitivity(self, pii_types: List[str]) -> str:\r\n        \"\"\"Classify data sensitivity based on PII types detected\"\"\"\r\n\r\n        high_sensitivity = ['ssn', 'credit_card', 'medical']\r\n        medium_sensitivity = ['email', 'phone', 'address']\r\n        low_sensitivity = ['name']\r\n\r\n        if any(pii_type in high_sensitivity for pii_type in pii_types):\r\n            return 'restricted'\r\n        elif any(pii_type in medium_sensitivity for pii_type in pii_types):\r\n            return 'confidential'\r\n        elif any(pii_type in low_sensitivity for pii_type in pii_types):\r\n            return 'internal'\r\n        else:\r\n            return 'public'\r\n```\r\n\r\n---\r\n\r\n## Security CLI Integration\r\n\r\n### Security Commands\r\n\r\n**Comprehensive Security CLI:**\r\n\r\n```bash\r\n# Security management commands\r\nfarm security                          # Security dashboard and status\r\nfarm security:scan                     # Run security scans\r\nfarm security:audit                    # Security audit report\r\nfarm security:config                   # Security configuration wizard\r\n\r\n# Secret management\r\nfarm secrets                           # List managed secrets\r\nfarm secrets:add <name>               # Add new secret\r\nfarm secrets:rotate <name>            # Rotate secret\r\nfarm secrets:validate                 # Validate all secrets\r\n\r\n# AI security\r\nfarm security:ai                      # AI-specific security audit\r\nfarm security:ai:scan                 # Scan for AI vulnerabilities\r\nfarm security:ai:prompt-test          # Test prompt injection defenses\r\n\r\n# Code security\r\nfarm security:code                    # Code security analysis\r\nfarm security:deps                    # Dependency vulnerability scan\r\nfarm security:generate               # Security-focused code generation\r\n\r\n# Compliance and reporting\r\nfarm security:report                  # Generate security report\r\nfarm security:compliance             # Compliance check\r\nfarm security:export                 # Export security data\r\n```\r\n\r\n### Security Configuration\r\n\r\n**Farm Config Security Settings:**\r\n\r\n```typescript\r\n// farm.config.ts - Security configuration\r\nexport default defineConfig({\r\n  security: {\r\n    // AI security settings\r\n    ai: {\r\n      promptInjectionProtection: true,\r\n      contentFiltering: true,\r\n      rateLimiting: {\r\n        enabled: true,\r\n        requestsPerMinute: 60,\r\n        tokensPerMinute: 40000\r\n      },\r\n      auditLogging: true,\r\n      modelAccessControl: {\r\n        allowedModels: ['llama3.1', 'gpt-3.5-turbo'],\r\n        userPermissions: true\r\n      }\r\n    },\r\n\r\n    // Authentication and authorization\r\n    auth: {\r\n      jwtSecretKey: process.env.JWT_SECRET_KEY,\r\n      accessTokenExpire: 30, // minutes\r\n      refreshTokenExpire: 7,  // days\r\n      passwordPolicy: {\r\n        minLength: 8,\r\n        requireSpecialChars: true,\r\n        maxLoginAttempts: 5,\r\n        lockoutDuration: 15 // minutes\r\n      },\r\n      mfa: {\r\n        enabled: false,\r\n        methods: ['totp', 'sms']\r\n      }\r\n    },\r\n\r\n    // Data protection\r\n    data: {\r\n      encryptionAtRest: true,\r\n      piiDetection: true,\r\n      dataClassification: true,\r\n      retentionPolicies: {\r\n        logs: '90d',\r\n        aiConversations: '30d',\r\n        userData: '2y'\r\n      }\r\n    },\r\n\r\n    // Code and framework security\r\n    framework: {\r\n      cliSecurity: true,\r\n      templateValidation: true,\r\n      codeGenerationSecurity: true,\r\n      dependencyScanning: true,\r\n      secretScanning: true\r\n    },\r\n\r\n    // Production security\r\n    production: {\r\n      httpsEnforcement: true,\r\n      securityHeaders: true,\r\n      rateLimiting: true,\r\n      auditLogging: true,\r\n      intrusion Detection: true\r\n    },\r\n\r\n    // Compliance\r\n    compliance: {\r\n      gdpr: true,\r\n      ccpa: true,\r\n      hipaa: false,\r\n      soc2: false\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n---\r\n\r\n## Security Monitoring & Alerts\r\n\r\n### Real-Time Security Dashboard\r\n\r\n```typescript\r\n// packages/farm-security/src/dashboard.tsx\r\nexport function SecurityDashboard() {\r\n  const [securityMetrics, setSecurityMetrics] = useState(null);\r\n  const [alerts, setAlerts] = useState([]);\r\n  const [threats, setThreats] = useState([]);\r\n\r\n  return (\r\n    <div className=\"security-dashboard p-6 space-y-6\">\r\n      {/* Security Status Overview */}\r\n      <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\">\r\n        <SecurityMetricCard\r\n          title=\"AI Security\"\r\n          status={securityMetrics?.ai?.status || \"unknown\"}\r\n          details={[\r\n            `Prompt injections blocked: ${\r\n              securityMetrics?.ai?.blockedInjections || 0\r\n            }`,\r\n            `Rate limit violations: ${\r\n              securityMetrics?.ai?.rateLimitViolations || 0\r\n            }`,\r\n            `Active models: ${securityMetrics?.ai?.activeModels || 0}`,\r\n          ]}\r\n        />\r\n\r\n        <SecurityMetricCard\r\n          title=\"Authentication\"\r\n          status={securityMetrics?.auth?.status || \"unknown\"}\r\n          details={[\r\n            `Failed logins: ${securityMetrics?.auth?.failedLogins || 0}`,\r\n            `Locked accounts: ${securityMetrics?.auth?.lockedAccounts || 0}`,\r\n            `Active sessions: ${securityMetrics?.auth?.activeSessions || 0}`,\r\n          ]}\r\n        />\r\n\r\n        <SecurityMetricCard\r\n          title=\"Data Protection\"\r\n          status={securityMetrics?.data?.status || \"unknown\"}\r\n          details={[\r\n            `PII detections: ${securityMetrics?.data?.piiDetections || 0}`,\r\n            `Encrypted records: ${\r\n              securityMetrics?.data?.encryptedRecords || 0\r\n            }`,\r\n            `Policy violations: ${\r\n              securityMetrics?.data?.policyViolations || 0\r\n            }`,\r\n          ]}\r\n        />\r\n\r\n        <SecurityMetricCard\r\n          title=\"Code Security\"\r\n          status={securityMetrics?.code?.status || \"unknown\"}\r\n          details={[\r\n            `Vulnerabilities: ${securityMetrics?.code?.vulnerabilities || 0}`,\r\n            `Secrets exposed: ${securityMetrics?.code?.exposedSecrets || 0}`,\r\n            `Security scans: ${securityMetrics?.code?.scansToday || 0}`,\r\n          ]}\r\n        />\r\n      </div>\r\n\r\n      {/* Recent Security Alerts */}\r\n      <div className=\"bg-white rounded-lg shadow p-6\">\r\n        <h3 className=\"text-lg font-semibold mb-4\">Recent Security Alerts</h3>\r\n        <div className=\"space-y-3\">\r\n          {alerts.map((alert, index) => (\r\n            <SecurityAlert key={index} alert={alert} />\r\n          ))}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Threat Analysis */}\r\n      <div className=\"bg-white rounded-lg shadow p-6\">\r\n        <h3 className=\"text-lg font-semibold mb-4\">Threat Analysis</h3>\r\n        <ThreatAnalysisChart threats={threats} />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n---\r\n\r\n**🎉 Phase 3 Complete!**\r\n\r\nWe've successfully completed all Phase 3 architectural sketches:\r\n\r\n```md\r\n### Phase 3: Production & Deployment ✅ COMPLETED\r\n\r\n- [x] **Deployment Pipeline Structure**\r\n- [x] **Testing Strategy Architecture**\r\n- [x] **Performance & Monitoring Design**\r\n- [x] **Security Architecture** ✅ JUST COMPLETED\r\n```\r\n\r\nThe Security Architecture provides comprehensive protection for FARM's unique AI-first challenges:\r\n\r\n### 🔒 **Key Security Innovations:**\r\n\r\n- **AI-Specific Security**: Prompt injection protection, AI provider security, model access controls\r\n- **Cross-Stack Security**: Consistent security patterns between Python and TypeScript\r\n- **Framework Security**: CLI security, secure code generation, template validation\r\n- **Production Ready**: Authentication, authorization, data protection, compliance\r\n- **Real-time Monitoring**: Security dashboards, threat detection, automated alerts\r\n\r\n### 🏗️ **Complete Architectural Foundation:**\r\n\r\nWith all **12 architectural sketches** completed, FARM now has a comprehensive technical foundation covering:\r\n\r\n- Core framework architecture and development experience\r\n- AI/ML integration with local and cloud providers\r\n- Production deployment, testing, performance, and security\r\n- Plugin system and community ecosystem\r\n\r\n**Ready for implementation phase!** 🚀\r\n",
      "excerpt": "FARM's security architecture provides comprehensive protection across the AI-first full-stack platform, addressing unique challenges including AI provider secur...",
      "category": "architectural-sketches-detailed/phase3",
      "type": "reference",
      "tags": [
        "react",
        "farm",
        "typescript",
        "python",
        "authentication"
      ],
      "lastModified": "2025-06-12T21:57:32.784Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase3",
        "Security_architecture"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Security Architecture",
          "id": "security-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "Multi-Layer Security Architecture",
          "id": "multi-layer-security-architecture"
        },
        {
          "level": 2,
          "text": "Core Security Components",
          "id": "core-security-components"
        },
        {
          "level": 3,
          "text": "1. AI/ML Security Framework",
          "id": "1-aiml-security-framework"
        },
        {
          "level": 1,
          "text": "packages/farm-security/src/ai_security.py",
          "id": "packagesfarm-securitysrcai_securitypy"
        },
        {
          "level": 1,
          "text": "packages/farm-security/src/ollama_security.py",
          "id": "packagesfarm-securitysrcollama_securitypy"
        },
        {
          "level": 3,
          "text": "2. Framework Security",
          "id": "2-framework-security"
        },
        {
          "level": 3,
          "text": "3. Application Security Framework",
          "id": "3-application-security-framework"
        },
        {
          "level": 1,
          "text": "packages/farm-auth/src/auth_security.py",
          "id": "packagesfarm-authsrcauth_securitypy"
        },
        {
          "level": 3,
          "text": "4. Data Protection & Privacy",
          "id": "4-data-protection-privacy"
        },
        {
          "level": 1,
          "text": "packages/farm-security/src/data_security.py",
          "id": "packagesfarm-securitysrcdata_securitypy"
        },
        {
          "level": 2,
          "text": "Security CLI Integration",
          "id": "security-cli-integration"
        },
        {
          "level": 3,
          "text": "Security Commands",
          "id": "security-commands"
        },
        {
          "level": 1,
          "text": "Security management commands",
          "id": "security-management-commands"
        },
        {
          "level": 1,
          "text": "Secret management",
          "id": "secret-management"
        },
        {
          "level": 1,
          "text": "AI security",
          "id": "ai-security"
        },
        {
          "level": 1,
          "text": "Code security",
          "id": "code-security"
        },
        {
          "level": 1,
          "text": "Compliance and reporting",
          "id": "compliance-and-reporting"
        },
        {
          "level": 3,
          "text": "Security Configuration",
          "id": "security-configuration"
        },
        {
          "level": 2,
          "text": "Security Monitoring & Alerts",
          "id": "security-monitoring-alerts"
        },
        {
          "level": 3,
          "text": "Real-Time Security Dashboard",
          "id": "real-time-security-dashboard"
        },
        {
          "level": 3,
          "text": "Phase 3: Production & Deployment ✅ COMPLETED",
          "id": "phase-3-production-deployment-completed"
        },
        {
          "level": 3,
          "text": "🔒 **Key Security Innovations:**",
          "id": "-key-security-innovations"
        },
        {
          "level": 3,
          "text": "🏗️ **Complete Architectural Foundation:**",
          "id": "-complete-architectural-foundation"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase3-testing_strategy_architecture",
      "title": "Testing_strategy_architecture",
      "url": "/architectural-sketches-detailed/phase3/testing_strategy_architecture",
      "content": "# Testing Strategy Architecture\r\n\r\n## Overview\r\n\r\nThe FARM testing strategy encompasses three layers: **framework-level testing** (testing FARM itself), **auto-generated application testing** (testing user code), and **AI-specific testing** (validating AI provider integrations and model behaviors). The system provides comprehensive test generation, cross-stack validation, and AI-aware testing capabilities while maintaining excellent developer experience.\r\n\r\n---\r\n\r\n## Multi-Layer Testing Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Testing Architecture                    │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │Framework    │  │Application  │  │Integration  │  │   AI    │ │\r\n│  │Tests        │  │Tests        │  │Tests        │  │ Tests   │ │\r\n│  │(FARM Core)  │  │(Generated)  │  │(Cross-Stack)│  │(Models) │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │ Unit Tests  │  │ API Tests   │  │ E2E Tests   │  │Contract │ │\r\n│  │            │  │            │  │            │  │ Tests   │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │Test Runner  │  │Mock Manager │  │ Coverage    │  │ Report  │ │\r\n│  │Orchestrator │  │(AI Models)  │  │ Analyzer    │  │ System  │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Testing Components\r\n\r\n### 1. Framework-Level Testing Suite\r\n\r\n**Purpose:** Test FARM framework internals and core functionality\r\n\r\n**Structure:**\r\n\r\n```\r\npackages/farm-core/tests/\r\n├── cli/\r\n│   ├── create.test.ts          # Project scaffolding tests\r\n│   ├── generate.test.ts        # Code generation tests\r\n│   └── dev-server.test.ts      # Development server tests\r\n├── codegen/\r\n│   ├── typescript-gen.test.ts  # Type generation tests\r\n│   ├── api-client-gen.test.ts  # API client generation tests\r\n│   └── schema-validation.test.ts\r\n├── ai/\r\n│   ├── provider-router.test.ts # AI provider routing tests\r\n│   ├── ollama-integration.test.ts\r\n│   ├── model-manager.test.ts   # Model loading/switching tests\r\n│   └── streaming.test.ts       # AI streaming response tests\r\n├── config/\r\n│   ├── loader.test.ts          # Configuration loading tests\r\n│   ├── validation.test.ts      # Config validation tests\r\n│   └── hot-reload.test.ts      # Config hot reload tests\r\n└── dev-server/\r\n    ├── service-manager.test.ts # Service orchestration tests\r\n    ├── file-watcher.test.ts    # File watching tests\r\n    └── proxy.test.ts           # Request proxying tests\r\n```\r\n\r\n**Example Framework Test:**\r\n\r\n```typescript\r\n// packages/farm-core/tests/codegen/typescript-gen.test.ts\r\nimport { TypeScriptGenerator } from \"../../src/codegen/typescript-generator\";\r\nimport { OpenAPISchema } from \"../../src/types\";\r\n\r\ndescribe(\"TypeScript Generator\", () => {\r\n  let generator: TypeScriptGenerator;\r\n\r\n  beforeEach(() => {\r\n    generator = new TypeScriptGenerator();\r\n  });\r\n\r\n  test(\"generates correct interfaces from Pydantic models\", async () => {\r\n    const openApiSchema: OpenAPISchema = {\r\n      components: {\r\n        schemas: {\r\n          User: {\r\n            type: \"object\",\r\n            properties: {\r\n              id: { type: \"string\" },\r\n              name: { type: \"string\" },\r\n              email: { type: \"string\", format: \"email\" },\r\n              createdAt: { type: \"string\", format: \"date-time\" },\r\n            },\r\n            required: [\"id\", \"name\", \"email\"],\r\n          },\r\n        },\r\n      },\r\n    };\r\n\r\n    const result = await generator.generateTypes(openApiSchema);\r\n\r\n    expect(result.interfaces).toContain(`\r\n      export interface User {\r\n        id: string;\r\n        name: string;\r\n        email: string;\r\n        createdAt?: string;\r\n      }\r\n    `);\r\n  });\r\n\r\n  test(\"handles optional fields correctly\", async () => {\r\n    // Test optional field generation logic\r\n  });\r\n\r\n  test(\"generates AI provider types correctly\", async () => {\r\n    // Test AI-specific type generation\r\n  });\r\n});\r\n```\r\n\r\n### 2. Auto-Generated Application Testing\r\n\r\n**Purpose:** Automatically generate comprehensive test suites for user applications\r\n\r\n**Test Generation Triggers:**\r\n\r\n```typescript\r\n// When user runs: farm generate model User\r\n// Auto-generates:\r\nexport interface TestGenerationConfig {\r\n  model: {\r\n    unitTests: boolean; // Test model validation\r\n    factoryTests: boolean; // Test data factories\r\n    migrationTests: boolean; // Test database migrations\r\n  };\r\n  api: {\r\n    endpointTests: boolean; // Test all CRUD endpoints\r\n    authTests: boolean; // Test authentication\r\n    validationTests: boolean; // Test request validation\r\n  };\r\n  frontend: {\r\n    componentTests: boolean; // Test React components\r\n    hookTests: boolean; // Test custom hooks\r\n    integrationTests: boolean; // Test API integration\r\n  };\r\n  ai: {\r\n    providerTests: boolean; // Test AI provider switching\r\n    modelTests: boolean; // Test model interactions\r\n    streamingTests: boolean; // Test streaming responses\r\n  };\r\n}\r\n```\r\n\r\n**Generated Test Structure:**\r\n\r\n```\r\napps/api/tests/\r\n├── models/\r\n│   ├── test_user.py          # Generated model tests\r\n│   └── test_conversation.py   # AI model tests\r\n├── routes/\r\n│   ├── test_users.py         # Generated API tests\r\n│   ├── test_auth.py          # Generated auth tests\r\n│   └── test_ai.py            # Generated AI endpoint tests\r\n├── ai/\r\n│   ├── test_providers.py     # AI provider tests\r\n│   ├── test_model_manager.py # Model management tests\r\n│   └── test_streaming.py     # Streaming tests\r\n└── factories/\r\n    ├── user_factory.py       # Test data factories\r\n    └── conversation_factory.py\r\n\r\napps/web/tests/\r\n├── components/\r\n│   ├── UserList.test.tsx     # Generated component tests\r\n│   ├── ChatWindow.test.tsx   # Generated AI component tests\r\n│   └── forms/\r\n│       └── UserForm.test.tsx\r\n├── hooks/\r\n│   ├── useUsers.test.ts      # Generated hook tests\r\n│   ├── useStreamingChat.test.ts # Generated AI hook tests\r\n│   └── useAuth.test.ts\r\n├── services/\r\n│   ├── api.test.ts           # Generated API client tests\r\n│   └── aiApi.test.ts         # Generated AI API tests\r\n└── utils/\r\n    └── test-utils.tsx        # Testing utilities\r\n```\r\n\r\n### 3. AI-Specific Testing Framework\r\n\r\n**Purpose:** Comprehensive testing for AI providers and model interactions\r\n\r\n**AI Test Categories:**\r\n\r\n```typescript\r\n// AI Provider Testing\r\nexport interface AITestSuite {\r\n  providerHealth: {\r\n    ollamaConnection: boolean;\r\n    openaiConnection: boolean;\r\n    huggingfaceConnection: boolean;\r\n    providerSwitching: boolean;\r\n  };\r\n  modelOperations: {\r\n    modelLoading: boolean;\r\n    modelCaching: boolean;\r\n    modelHotSwap: boolean;\r\n    memoryManagement: boolean;\r\n  };\r\n  inference: {\r\n    syncResponse: boolean;\r\n    streamingResponse: boolean;\r\n    errorHandling: boolean;\r\n    responseValidation: boolean;\r\n  };\r\n  performance: {\r\n    responseTime: boolean;\r\n    throughput: boolean;\r\n    memoryUsage: boolean;\r\n    gpuUtilization: boolean;\r\n  };\r\n}\r\n```\r\n\r\n**AI Provider Mock System:**\r\n\r\n```python\r\n# apps/api/tests/ai/mocks/providers.py\r\nfrom farm.ai.providers.base import AIProvider\r\nfrom typing import AsyncIterator, List\r\nimport asyncio\r\n\r\nclass MockOllamaProvider(AIProvider):\r\n    \"\"\"Mock Ollama provider for testing\"\"\"\r\n\r\n    def __init__(self, config: dict):\r\n        super().__init__(config)\r\n        self.mock_responses = {}\r\n        self.call_log = []\r\n\r\n    async def chat(self, messages: List[ChatMessage], model: str, **kwargs) -> str:\r\n        self.call_log.append({\r\n            'method': 'chat',\r\n            'messages': messages,\r\n            'model': model,\r\n            'kwargs': kwargs\r\n        })\r\n\r\n        # Return mock response based on input\r\n        if 'hello' in messages[-1].content.lower():\r\n            return \"Hello! How can I help you today?\"\r\n\r\n        return self.mock_responses.get(model, \"Mock response\")\r\n\r\n    async def chat_stream(self, messages: List[ChatMessage], model: str, **kwargs) -> AsyncIterator[str]:\r\n        \"\"\"Mock streaming response\"\"\"\r\n        response = await self.chat(messages, model, **kwargs)\r\n        words = response.split()\r\n\r\n        for word in words:\r\n            yield word + \" \"\r\n            await asyncio.sleep(0.01)  # Simulate streaming delay\r\n\r\n    async def health_check(self) -> bool:\r\n        return True  # Always healthy in tests\r\n\r\n    def set_mock_response(self, model: str, response: str):\r\n        \"\"\"Set mock response for specific model\"\"\"\r\n        self.mock_responses[model] = response\r\n\r\nclass MockOpenAIProvider(AIProvider):\r\n    \"\"\"Mock OpenAI provider for testing\"\"\"\r\n    # Similar implementation for OpenAI testing\r\n    pass\r\n```\r\n\r\n**AI Integration Tests:**\r\n\r\n```python\r\n# apps/api/tests/ai/test_provider_integration.py\r\nimport pytest\r\nfrom farm.ai.router import AIRouter\r\nfrom .mocks.providers import MockOllamaProvider, MockOpenAIProvider\r\n\r\nclass TestAIProviderIntegration:\r\n\r\n    @pytest.fixture\r\n    async def ai_router(self):\r\n        \"\"\"Setup AI router with mock providers\"\"\"\r\n        router = AIRouter()\r\n        router.providers['ollama'] = MockOllamaProvider({})\r\n        router.providers['openai'] = MockOpenAIProvider({})\r\n        router.default_provider = 'ollama'\r\n        return router\r\n\r\n    async def test_provider_switching(self, ai_router):\r\n        \"\"\"Test switching between AI providers\"\"\"\r\n        # Test Ollama provider\r\n        ollama_provider = ai_router.get_provider('ollama')\r\n        ollama_response = await ollama_provider.chat([\r\n            ChatMessage(role=\"user\", content=\"Hello\")\r\n        ], \"llama3.1\")\r\n\r\n        assert \"Hello\" in ollama_response\r\n\r\n        # Test OpenAI provider\r\n        openai_provider = ai_router.get_provider('openai')\r\n        openai_response = await openai_provider.chat([\r\n            ChatMessage(role=\"user\", content=\"Hello\")\r\n        ], \"gpt-3.5-turbo\")\r\n\r\n        assert openai_response is not None\r\n\r\n    async def test_environment_routing(self, ai_router, monkeypatch):\r\n        \"\"\"Test automatic provider selection based on environment\"\"\"\r\n        # Test development environment (should use Ollama)\r\n        monkeypatch.setenv('FARM_ENV', 'development')\r\n        provider = ai_router.get_provider()\r\n        assert isinstance(provider, MockOllamaProvider)\r\n\r\n        # Test production environment (should use OpenAI)\r\n        monkeypatch.setenv('FARM_ENV', 'production')\r\n        # Would need configuration to specify production provider\r\n\r\n    async def test_fallback_behavior(self, ai_router):\r\n        \"\"\"Test fallback when primary provider fails\"\"\"\r\n        # Simulate Ollama failure\r\n        ai_router.providers['ollama'].health_check = lambda: False\r\n\r\n        # Should fallback to OpenAI\r\n        fallback_provider = ai_router.get_fallback_provider('ollama')\r\n        assert fallback_provider is not None\r\n\r\n    async def test_streaming_response(self, ai_router):\r\n        \"\"\"Test AI streaming response functionality\"\"\"\r\n        provider = ai_router.get_provider('ollama')\r\n\r\n        collected_chunks = []\r\n        async for chunk in provider.chat_stream([\r\n            ChatMessage(role=\"user\", content=\"Hello\")\r\n        ], \"llama3.1\"):\r\n            collected_chunks.append(chunk)\r\n\r\n        assert len(collected_chunks) > 0\r\n        assert \"\".join(collected_chunks).strip() == \"Hello! How can I help you today?\"\r\n```\r\n\r\n### 4. Cross-Stack Integration Testing\r\n\r\n**Purpose:** Validate consistency between Python backend and TypeScript frontend\r\n\r\n**Type Consistency Tests:**\r\n\r\n```typescript\r\n// tools/codegen/tests/type-consistency.test.ts\r\nimport { generateTypesFromOpenAPI } from \"../src/typescript-generator\";\r\nimport { extractOpenAPIFromPython } from \"../src/openapi-extractor\";\r\n\r\ndescribe(\"Cross-Stack Type Consistency\", () => {\r\n  test(\"Python models generate correct TypeScript types\", async () => {\r\n    // Start test FastAPI server\r\n    const testServer = await startTestFastAPIServer();\r\n\r\n    try {\r\n      // Extract OpenAPI schema from running server\r\n      const openApiSchema = await extractOpenAPIFromPython(testServer.url);\r\n\r\n      // Generate TypeScript types\r\n      const generatedTypes = await generateTypesFromOpenAPI(openApiSchema);\r\n\r\n      // Validate User model consistency\r\n      expect(generatedTypes).toContain(`\r\n        export interface User {\r\n          id: string;\r\n          name: string;\r\n          email: string;\r\n          createdAt: string;\r\n          updatedAt: string;\r\n        }\r\n      `);\r\n\r\n      // Validate AI-specific types\r\n      expect(generatedTypes).toContain(`\r\n        export interface ChatRequest {\r\n          messages: ChatMessage[];\r\n          model: string;\r\n          provider?: 'ollama' | 'openai' | 'huggingface';\r\n          temperature?: number;\r\n          maxTokens?: number;\r\n        }\r\n      `);\r\n    } finally {\r\n      await testServer.stop();\r\n    }\r\n  });\r\n\r\n  test(\"API client methods match FastAPI routes\", async () => {\r\n    // Test that generated API client has correct methods\r\n    const apiClient = await import(\"../generated/api-client\");\r\n\r\n    // Validate CRUD operations exist\r\n    expect(apiClient.userApi.create).toBeDefined();\r\n    expect(apiClient.userApi.getById).toBeDefined();\r\n    expect(apiClient.userApi.update).toBeDefined();\r\n    expect(apiClient.userApi.delete).toBeDefined();\r\n    expect(apiClient.userApi.list).toBeDefined();\r\n\r\n    // Validate AI operations exist\r\n    expect(apiClient.aiApi.chat).toBeDefined();\r\n    expect(apiClient.aiApi.chatStream).toBeDefined();\r\n    expect(apiClient.aiApi.listModels).toBeDefined();\r\n    expect(apiClient.aiApi.healthCheck).toBeDefined();\r\n  });\r\n\r\n  test(\"React hooks work with generated API client\", async () => {\r\n    // Test generated hooks against mock API\r\n    const { renderHook, waitFor } = require(\"@testing-library/react\");\r\n    const { useUsers, useStreamingChat } = require(\"../generated/hooks\");\r\n\r\n    const { result } = renderHook(() => useUsers());\r\n\r\n    await waitFor(() => {\r\n      expect(result.current.isLoading).toBe(false);\r\n    });\r\n\r\n    expect(result.current.data).toBeDefined();\r\n  });\r\n});\r\n```\r\n\r\n### 5. End-to-End Testing Framework\r\n\r\n**Purpose:** Test complete user workflows including AI interactions\r\n\r\n**E2E Test Structure:**\r\n\r\n```\r\ntests/e2e/\r\n├── scaffolding/\r\n│   ├── basic-project.spec.ts     # Test project creation\r\n│   ├── ai-chat-project.spec.ts   # Test AI template\r\n│   └── template-switching.spec.ts\r\n├── development/\r\n│   ├── hot-reload.spec.ts        # Test hot reload functionality\r\n│   ├── type-generation.spec.ts   # Test type generation pipeline\r\n│   └── ai-model-switching.spec.ts # Test AI model hot-swap\r\n├── ai-workflows/\r\n│   ├── local-chat.spec.ts        # Test Ollama chat functionality\r\n│   ├── provider-switching.spec.ts # Test provider switching\r\n│   ├── streaming-responses.spec.ts # Test streaming AI responses\r\n│   └── model-management.spec.ts   # Test model loading/unloading\r\n└── deployment/\r\n    ├── build-process.spec.ts      # Test production builds\r\n    ├── docker-deployment.spec.ts  # Test Docker deployment\r\n    └── cloud-deployment.spec.ts   # Test cloud deployment\r\n```\r\n\r\n**AI Workflow E2E Test:**\r\n\r\n```typescript\r\n// tests/e2e/ai-workflows/local-chat.spec.ts\r\nimport { test, expect } from \"@playwright/test\";\r\n\r\ntest.describe(\"Local AI Chat Workflow\", () => {\r\n  test.beforeEach(async ({ page }) => {\r\n    // Start FARM development server with Ollama\r\n    await page.goto(\"http://localhost:4000\");\r\n  });\r\n\r\n  test(\"creates AI chat application and tests chat functionality\", async ({\r\n    page,\r\n  }) => {\r\n    // Navigate to chat interface\r\n    await page.click('[data-testid=\"chat-tab\"]');\r\n\r\n    // Verify Ollama is connected\r\n    await expect(page.locator('[data-testid=\"ai-status\"]')).toContainText(\r\n      \"Ollama: Connected\"\r\n    );\r\n\r\n    // Test model selection\r\n    await page.selectOption('[data-testid=\"model-selector\"]', \"llama3.1\");\r\n\r\n    // Send a test message\r\n    await page.fill(\r\n      '[data-testid=\"chat-input\"]',\r\n      \"Hello, can you help me with React?\"\r\n    );\r\n    await page.click('[data-testid=\"send-button\"]');\r\n\r\n    // Verify message appears in chat\r\n    await expect(\r\n      page.locator('[data-testid=\"user-message\"]').last()\r\n    ).toContainText(\"Hello, can you help me with React?\");\r\n\r\n    // Wait for AI response (streaming)\r\n    await expect(page.locator('[data-testid=\"ai-message\"]').last()).toBeVisible(\r\n      { timeout: 10000 }\r\n    );\r\n    await expect(\r\n      page.locator('[data-testid=\"ai-message\"]').last()\r\n    ).toContainText(\"React\", { timeout: 15000 });\r\n\r\n    // Test provider switching\r\n    await page.selectOption('[data-testid=\"provider-selector\"]', \"openai\");\r\n    await page.fill('[data-testid=\"chat-input\"]', \"Switch to OpenAI\");\r\n    await page.click('[data-testid=\"send-button\"]');\r\n\r\n    // Verify provider switch worked\r\n    await expect(page.locator('[data-testid=\"ai-status\"]')).toContainText(\r\n      \"OpenAI: Connected\"\r\n    );\r\n  });\r\n\r\n  test(\"handles Ollama model loading and switching\", async ({ page }) => {\r\n    // Test model management interface\r\n    await page.click('[data-testid=\"ai-settings\"]');\r\n\r\n    // Load a new model\r\n    await page.click('[data-testid=\"load-model-button\"]');\r\n    await page.fill('[data-testid=\"model-name-input\"]', \"codestral\");\r\n    await page.click('[data-testid=\"confirm-load\"]');\r\n\r\n    // Wait for model loading\r\n    await expect(\r\n      page.locator('[data-testid=\"loading-indicator\"]')\r\n    ).toBeVisible();\r\n    await expect(page.locator('[data-testid=\"loading-indicator\"]')).toBeHidden({\r\n      timeout: 60000,\r\n    });\r\n\r\n    // Verify model is available\r\n    await expect(page.locator('[data-testid=\"model-selector\"]')).toContainText(\r\n      \"codestral\"\r\n    );\r\n  });\r\n});\r\n```\r\n\r\n---\r\n\r\n## Test Generation System\r\n\r\n### 1. Model-Based Test Generation\r\n\r\n**Automatic Test Generation from Pydantic Models:**\r\n\r\n```python\r\n# tools/codegen/test_generator.py\r\nfrom typing import Dict, Any\r\nimport ast\r\nfrom jinja2 import Template\r\n\r\nclass ModelTestGenerator:\r\n    def __init__(self):\r\n        self.test_templates = {\r\n            'model_validation': '''\r\ndef test_{{model_name|lower}}_validation():\r\n    \"\"\"Test {{model_name}} model validation\"\"\"\r\n\r\n    # Test valid data\r\n    valid_data = {{valid_example}}\r\n    model = {{model_name}}(**valid_data)\r\n    assert model.{{primary_field}} == valid_data['{{primary_field}}']\r\n\r\n    # Test invalid data\r\n    {% for field, validation in validations.items() %}\r\n    with pytest.raises(ValidationError):\r\n        {{model_name}}({{invalid_examples[field]}})\r\n    {% endfor %}\r\n''',\r\n            'model_serialization': '''\r\ndef test_{{model_name|lower}}_serialization():\r\n    \"\"\"Test {{model_name}} serialization/deserialization\"\"\"\r\n\r\n    data = {{valid_example}}\r\n    model = {{model_name}}(**data)\r\n\r\n    # Test dict conversion\r\n    model_dict = model.dict()\r\n    assert model_dict['{{primary_field}}'] == data['{{primary_field}}']\r\n\r\n    # Test JSON serialization\r\n    json_str = model.json()\r\n    assert json_str is not None\r\n\r\n    # Test JSON deserialization\r\n    recreated = {{model_name}}.parse_raw(json_str)\r\n    assert recreated.{{primary_field}} == model.{{primary_field}}\r\n'''\r\n        }\r\n\r\n    def generate_tests_for_model(self, model_info: Dict[str, Any]) -> str:\r\n        \"\"\"Generate comprehensive tests for a Pydantic model\"\"\"\r\n\r\n        # Extract model information\r\n        model_name = model_info['name']\r\n        fields = model_info['fields']\r\n        validations = model_info['validations']\r\n\r\n        # Generate test data\r\n        valid_example = self.generate_valid_example(fields)\r\n        invalid_examples = self.generate_invalid_examples(fields, validations)\r\n\r\n        # Render test templates\r\n        tests = []\r\n        for template_name, template_str in self.test_templates.items():\r\n            template = Template(template_str)\r\n            test_code = template.render(\r\n                model_name=model_name,\r\n                valid_example=valid_example,\r\n                invalid_examples=invalid_examples,\r\n                validations=validations,\r\n                primary_field=self.get_primary_field(fields)\r\n            )\r\n            tests.append(test_code)\r\n\r\n        return '\\n\\n'.join(tests)\r\n\r\n    def generate_valid_example(self, fields: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Generate valid test data for model fields\"\"\"\r\n        example = {}\r\n\r\n        for field_name, field_info in fields.items():\r\n            field_type = field_info['type']\r\n\r\n            if field_type == 'str':\r\n                example[field_name] = f\"test_{field_name}\"\r\n            elif field_type == 'int':\r\n                example[field_name] = 42\r\n            elif field_type == 'float':\r\n                example[field_name] = 3.14\r\n            elif field_type == 'bool':\r\n                example[field_name] = True\r\n            elif field_type == 'datetime':\r\n                example[field_name] = \"2025-06-04T12:00:00Z\"\r\n            # Add more type handlers\r\n\r\n        return example\r\n```\r\n\r\n### 2. API Route Test Generation\r\n\r\n**Automatic API Tests from FastAPI Routes:**\r\n\r\n```python\r\n# tools/codegen/api_test_generator.py\r\nclass APITestGenerator:\r\n    def generate_crud_tests(self, route_info: Dict[str, Any]) -> str:\r\n        \"\"\"Generate CRUD API tests for a resource\"\"\"\r\n\r\n        template = '''\r\nclass Test{{resource_name}}API:\r\n    \"\"\"Auto-generated tests for {{resource_name}} API\"\"\"\r\n\r\n    @pytest.fixture\r\n    async def client(self):\r\n        \"\"\"Test client fixture\"\"\"\r\n        return TestClient(app)\r\n\r\n    @pytest.fixture\r\n    async def sample_{{resource_name|lower}}(self):\r\n        \"\"\"Sample {{resource_name}} data\"\"\"\r\n        return {{sample_data}}\r\n\r\n    async def test_create_{{resource_name|lower}}(self, client, sample_{{resource_name|lower}}):\r\n        \"\"\"Test creating a {{resource_name}}\"\"\"\r\n        response = await client.post(\"{{base_path}}\", json=sample_{{resource_name|lower}})\r\n        assert response.status_code == 201\r\n\r\n        data = response.json()\r\n        assert data[\"{{primary_field}}\"] is not None\r\n        {% for field, expected in sample_data.items() %}\r\n        assert data[\"{{field}}\"] == \"{{expected}}\"\r\n        {% endfor %}\r\n\r\n    async def test_get_{{resource_name|lower}}(self, client, sample_{{resource_name|lower}}):\r\n        \"\"\"Test retrieving a {{resource_name}}\"\"\"\r\n        # Create resource first\r\n        create_response = await client.post(\"{{base_path}}\", json=sample_{{resource_name|lower}})\r\n        created_id = create_response.json()[\"{{primary_field}}\"]\r\n\r\n        # Retrieve resource\r\n        response = await client.get(f\"{{base_path}}/{created_id}\")\r\n        assert response.status_code == 200\r\n\r\n        data = response.json()\r\n        assert data[\"{{primary_field}}\"] == created_id\r\n\r\n    async def test_update_{{resource_name|lower}}(self, client, sample_{{resource_name|lower}}):\r\n        \"\"\"Test updating a {{resource_name}}\"\"\"\r\n        # Create and update logic\r\n        pass\r\n\r\n    async def test_delete_{{resource_name|lower}}(self, client, sample_{{resource_name|lower}}):\r\n        \"\"\"Test deleting a {{resource_name}}\"\"\"\r\n        # Create and delete logic\r\n        pass\r\n\r\n    async def test_list_{{resource_name|lower}}s(self, client):\r\n        \"\"\"Test listing {{resource_name}}s\"\"\"\r\n        response = await client.get(\"{{base_path}}\")\r\n        assert response.status_code == 200\r\n\r\n        data = response.json()\r\n        assert \"items\" in data\r\n        assert \"total\" in data\r\n        assert isinstance(data[\"items\"], list)\r\n'''\r\n\r\n        return Template(template).render(**route_info)\r\n```\r\n\r\n### 3. Frontend Test Generation\r\n\r\n**React Component and Hook Tests:**\r\n\r\n```typescript\r\n// tools/codegen/frontend-test-generator.ts\r\nexport class FrontendTestGenerator {\r\n  generateComponentTests(componentInfo: ComponentInfo): string {\r\n    return `\r\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\r\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\r\nimport { ${componentInfo.name} } from './${componentInfo.name}';\r\nimport { mockApi } from '../utils/test-utils';\r\n\r\ndescribe('${componentInfo.name}', () => {\r\n  let queryClient: QueryClient;\r\n\r\n  beforeEach(() => {\r\n    queryClient = new QueryClient({\r\n      defaultOptions: {\r\n        queries: { retry: false },\r\n        mutations: { retry: false },\r\n      },\r\n    });\r\n    \r\n    mockApi.reset();\r\n  });\r\n\r\n  const renderComponent = (props = {}) => {\r\n    return render(\r\n      <QueryClientProvider client={queryClient}>\r\n        <${componentInfo.name} {...props} />\r\n      </QueryClientProvider>\r\n    );\r\n  };\r\n\r\n  test('renders correctly with default props', () => {\r\n    renderComponent();\r\n    \r\n    ${componentInfo.testElements\r\n      .map(\r\n        (element) =>\r\n          `expect(screen.getByTestId('${element}')).toBeInTheDocument();`\r\n      )\r\n      .join(\"\\n    \")}\r\n  });\r\n\r\n  ${componentInfo.interactions\r\n    .map(\r\n      (interaction) => `\r\n  test('handles ${interaction.action} correctly', async () => {\r\n    ${interaction.setup || \"\"}\r\n    renderComponent();\r\n    \r\n    ${interaction.trigger}\r\n    \r\n    await waitFor(() => {\r\n      ${interaction.assertion}\r\n    });\r\n  });`\r\n    )\r\n    .join(\"\\n\")}\r\n});\r\n`;\r\n  }\r\n\r\n  generateHookTests(hookInfo: HookInfo): string {\r\n    return `\r\nimport { renderHook, waitFor } from '@testing-library/react';\r\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\r\nimport { ${hookInfo.name} } from './${hookInfo.name}';\r\nimport { mockApiClient } from '../utils/test-utils';\r\n\r\ndescribe('${hookInfo.name}', () => {\r\n  let queryClient: QueryClient;\r\n\r\n  beforeEach(() => {\r\n    queryClient = new QueryClient({\r\n      defaultOptions: {\r\n        queries: { retry: false },\r\n        mutations: { retry: false },\r\n      },\r\n    });\r\n  });\r\n\r\n  const wrapper = ({ children }: { children: React.ReactNode }) => (\r\n    <QueryClientProvider client={queryClient}>\r\n      {children}\r\n    </QueryClientProvider>\r\n  );\r\n\r\n  test('returns expected data structure', () => {\r\n    const { result } = renderHook(() => ${hookInfo.name}(), { wrapper });\r\n    \r\n    ${hookInfo.expectedProperties\r\n      .map((prop) => `expect(result.current.${prop}).toBeDefined();`)\r\n      .join(\"\\n    \")}\r\n  });\r\n\r\n  ${hookInfo.operations\r\n    .map(\r\n      (operation) => `\r\n  test('${operation.name} works correctly', async () => {\r\n    mockApiClient.${operation.endpoint}.mockResolvedValue(${operation.mockResponse});\r\n    \r\n    const { result } = renderHook(() => ${hookInfo.name}(), { wrapper });\r\n    \r\n    ${operation.trigger}\r\n    \r\n    await waitFor(() => {\r\n      ${operation.assertion}\r\n    });\r\n    \r\n    expect(mockApiClient.${operation.endpoint}).toHaveBeenCalledWith(${operation.expectedCall});\r\n  });`\r\n    )\r\n    .join(\"\\n\")}\r\n});\r\n`;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## AI Testing Infrastructure\r\n\r\n### 1. AI Provider Mock Framework\r\n\r\n**Comprehensive AI Provider Mocking:**\r\n\r\n```python\r\n# packages/farm-testing/src/ai_mocks.py\r\nfrom typing import Dict, List, Any, AsyncIterator\r\nimport asyncio\r\nimport json\r\n\r\nclass AITestSuite:\r\n    \"\"\"Comprehensive AI testing framework\"\"\"\r\n\r\n    def __init__(self):\r\n        self.mock_providers = {}\r\n        self.test_scenarios = {}\r\n        self.performance_metrics = {}\r\n\r\n    def register_mock_provider(self, name: str, provider_mock: 'MockAIProvider'):\r\n        \"\"\"Register a mock AI provider for testing\"\"\"\r\n        self.mock_providers[name] = provider_mock\r\n\r\n    def create_test_scenario(self, name: str, scenario_config: Dict[str, Any]):\r\n        \"\"\"Create a test scenario for AI interactions\"\"\"\r\n        self.test_scenarios[name] = {\r\n            'inputs': scenario_config.get('inputs', []),\r\n            'expected_outputs': scenario_config.get('expected_outputs', []),\r\n            'provider': scenario_config.get('provider', 'ollama'),\r\n            'model': scenario_config.get('model', 'llama3.1'),\r\n            'streaming': scenario_config.get('streaming', False)\r\n        }\r\n\r\n    async def run_scenario(self, scenario_name: str) -> Dict[str, Any]:\r\n        \"\"\"Run a specific test scenario\"\"\"\r\n        scenario = self.test_scenarios[scenario_name]\r\n        provider = self.mock_providers[scenario['provider']]\r\n\r\n        results = []\r\n        for input_data in scenario['inputs']:\r\n            if scenario['streaming']:\r\n                output = []\r\n                async for chunk in provider.chat_stream(input_data['messages'], scenario['model']):\r\n                    output.append(chunk)\r\n                results.append(''.join(output))\r\n            else:\r\n                output = await provider.chat(input_data['messages'], scenario['model'])\r\n                results.append(output)\r\n\r\n        return {\r\n            'scenario': scenario_name,\r\n            'results': results,\r\n            'expected': scenario['expected_outputs'],\r\n            'passed': results == scenario['expected_outputs']\r\n        }\r\n\r\nclass MockOllamaProvider:\r\n    \"\"\"Advanced Ollama mock with realistic behavior\"\"\"\r\n\r\n    def __init__(self):\r\n        self.models = {}\r\n        self.response_patterns = {}\r\n        self.latency_config = {'min': 0.1, 'max': 2.0}\r\n        self.error_simulation = {'rate': 0.0, 'types': []}\r\n\r\n    def configure_model_responses(self, model: str, patterns: Dict[str, str]):\r\n        \"\"\"Configure response patterns for model\"\"\"\r\n        self.response_patterns[model] = patterns\r\n\r\n    def configure_latency(self, min_seconds: float, max_seconds: float):\r\n        \"\"\"Configure response latency simulation\"\"\"\r\n        self.latency_config = {'min': min_seconds, 'max': max_seconds}\r\n\r\n    def configure_error_simulation(self, error_rate: float, error_types: List[str]):\r\n        \"\"\"Configure error simulation for testing error handling\"\"\"\r\n        self.error_simulation = {'rate': error_rate, 'types': error_types}\r\n\r\n    async def chat(self, messages: List[ChatMessage], model: str, **kwargs) -> str:\r\n        \"\"\"Mock chat with realistic behavior simulation\"\"\"\r\n\r\n        # Simulate network latency\r\n        latency = random.uniform(self.latency_config['min'], self.latency_config['max'])\r\n        await asyncio.sleep(latency)\r\n\r\n        # Simulate errors if configured\r\n        if random.random() < self.error_simulation['rate']:\r\n            error_type = random.choice(self.error_simulation['types'])\r\n            if error_type == 'connection':\r\n                raise ConnectionError(\"Mock connection error\")\r\n            elif error_type == 'timeout':\r\n                raise TimeoutError(\"Mock timeout error\")\r\n\r\n        # Generate response based on patterns\r\n        user_message = messages[-1].content.lower()\r\n        patterns = self.response_patterns.get(model, {})\r\n\r\n        for pattern, response in patterns.items():\r\n            if pattern in user_message:\r\n                return response\r\n\r\n        # Default response\r\n        return f\"Mock response from {model} for: {user_message}\"\r\n\r\n    async def chat_stream(self, messages: List[ChatMessage], model: str, **kwargs) -> AsyncIterator[str]:\r\n        \"\"\"Mock streaming with realistic chunking\"\"\"\r\n        full_response = await self.chat(messages, model, **kwargs)\r\n        words = full_response.split()\r\n\r\n        for word in words:\r\n            # Simulate streaming delay\r\n            await asyncio.sleep(random.uniform(0.05, 0.2))\r\n            yield word + \" \"\r\n```\r\n\r\n### 2. Performance Testing Framework\r\n\r\n**AI Performance and Load Testing:**\r\n\r\n```python\r\n# packages/farm-testing/src/performance_testing.py\r\nimport asyncio\r\nimport time\r\nfrom typing import List, Dict, Any\r\nfrom concurrent.futures import ThreadPoolExecutor\r\n\r\nclass AIPerformanceTestSuite:\r\n    \"\"\"Performance testing for AI operations\"\"\"\r\n\r\n    def __init__(self, ai_router):\r\n        self.ai_router = ai_router\r\n        self.metrics = {}\r\n\r\n    async def test_response_time(self, provider: str, model: str, num_requests: int = 10) -> Dict[str, float]:\r\n        \"\"\"Test average response time for AI provider\"\"\"\r\n\r\n        async def single_request():\r\n            start_time = time.time()\r\n            await self.ai_router.get_provider(provider).chat([\r\n                ChatMessage(role=\"user\", content=\"Test performance\")\r\n            ], model)\r\n            return time.time() - start_time\r\n\r\n        # Run concurrent requests\r\n        tasks = [single_request() for _ in range(num_requests)]\r\n        response_times = await asyncio.gather(*tasks)\r\n\r\n        return {\r\n            'average_ms': sum(response_times) / len(response_times) * 1000,\r\n            'min_ms': min(response_times) * 1000,\r\n            'max_ms': max(response_times) * 1000,\r\n            'total_requests': num_requests\r\n        }\r\n\r\n    async def test_throughput(self, provider: str, model: str, duration_seconds: int = 60) -> Dict[str, float]:\r\n        \"\"\"Test throughput (requests per second)\"\"\"\r\n\r\n        start_time = time.time()\r\n        completed_requests = 0\r\n\r\n        async def continuous_requests():\r\n            nonlocal completed_requests\r\n            while time.time() - start_time < duration_seconds:\r\n                try:\r\n                    await self.ai_router.get_provider(provider).chat([\r\n                        ChatMessage(role=\"user\", content=f\"Request {completed_requests}\")\r\n                    ], model)\r\n                    completed_requests += 1\r\n                except Exception:\r\n                    pass  # Continue testing despite errors\r\n\r\n        # Run multiple concurrent workers\r\n        workers = 5\r\n        await asyncio.gather(*[continuous_requests() for _ in range(workers)])\r\n\r\n        actual_duration = time.time() - start_time\r\n\r\n        return {\r\n            'requests_per_second': completed_requests / actual_duration,\r\n            'total_requests': completed_requests,\r\n            'duration_seconds': actual_duration\r\n        }\r\n\r\n    async def test_memory_usage(self, provider: str, model: str) -> Dict[str, float]:\r\n        \"\"\"Test memory usage during AI operations\"\"\"\r\n        import psutil\r\n\r\n        process = psutil.Process()\r\n\r\n        # Baseline memory\r\n        baseline_memory = process.memory_info().rss / 1024 / 1024  # MB\r\n\r\n        # Perform AI operations\r\n        for i in range(10):\r\n            await self.ai_router.get_provider(provider).chat([\r\n                ChatMessage(role=\"user\", content=f\"Memory test {i}\")\r\n            ], model)\r\n\r\n        # Peak memory\r\n        peak_memory = process.memory_info().rss / 1024 / 1024  # MB\r\n\r\n        return {\r\n            'baseline_mb': baseline_memory,\r\n            'peak_mb': peak_memory,\r\n            'memory_increase_mb': peak_memory - baseline_memory\r\n        }\r\n```\r\n\r\n### 3. Integration Testing with Real AI Services\r\n\r\n**Testing Against Real AI Services (Optional):**\r\n\r\n```python\r\n# apps/api/tests/integration/test_real_ai_services.py\r\nimport pytest\r\nimport os\r\nfrom farm.ai.router import AIRouter\r\n\r\n@pytest.mark.integration\r\n@pytest.mark.skipif(not os.getenv('INTEGRATION_TESTS'), reason=\"Integration tests disabled\")\r\nclass TestRealAIServices:\r\n    \"\"\"Integration tests with real AI services (when available)\"\"\"\r\n\r\n    @pytest.fixture\r\n    async def real_ai_router(self):\r\n        \"\"\"AI router configured for real services\"\"\"\r\n        return AIRouter()  # Uses real configuration\r\n\r\n    @pytest.mark.skipif(not os.getenv('OLLAMA_URL'), reason=\"Ollama not available\")\r\n    async def test_real_ollama_connection(self, real_ai_router):\r\n        \"\"\"Test connection to real Ollama service\"\"\"\r\n        ollama = real_ai_router.get_provider('ollama')\r\n\r\n        health = await ollama.health_check()\r\n        assert health is True\r\n\r\n        # Test simple chat\r\n        response = await ollama.chat([\r\n            ChatMessage(role=\"user\", content=\"Hello\")\r\n        ], \"llama3.1\")\r\n\r\n        assert response is not None\r\n        assert len(response) > 0\r\n\r\n    @pytest.mark.skipif(not os.getenv('OPENAI_API_KEY'), reason=\"OpenAI API key not available\")\r\n    async def test_real_openai_connection(self, real_ai_router):\r\n        \"\"\"Test connection to real OpenAI service\"\"\"\r\n        openai = real_ai_router.get_provider('openai')\r\n\r\n        response = await openai.chat([\r\n            ChatMessage(role=\"user\", content=\"Hello\")\r\n        ], \"gpt-3.5-turbo\")\r\n\r\n        assert response is not None\r\n        assert len(response) > 0\r\n\r\n    async def test_provider_fallback_real(self, real_ai_router):\r\n        \"\"\"Test real provider fallback behavior\"\"\"\r\n        # This test would verify actual fallback between services\r\n        pass\r\n```\r\n\r\n---\r\n\r\n## Test Configuration & CLI Integration\r\n\r\n### Test Runner Configuration\r\n\r\n**FARM Test Configuration:**\r\n\r\n```typescript\r\n// farm.config.ts - Testing configuration\r\nexport default defineConfig({\r\n  testing: {\r\n    // Framework testing (for FARM development)\r\n    framework: {\r\n      enabled: true,\r\n      runner: \"jest\",\r\n      coverage: {\r\n        threshold: 80,\r\n        exclude: [\"tests/**\", \"**/*.test.ts\"],\r\n      },\r\n    },\r\n\r\n    // Application testing (for user projects)\r\n    application: {\r\n      enabled: true,\r\n      autoGenerate: true,\r\n      runners: {\r\n        backend: \"pytest\",\r\n        frontend: \"jest\",\r\n        e2e: \"playwright\",\r\n      },\r\n    },\r\n\r\n    // AI-specific testing\r\n    ai: {\r\n      enabled: true,\r\n      mockProviders: true,\r\n      performanceTesting: true,\r\n      integrationTesting: {\r\n        enabled: false, // Disabled by default\r\n        providers: [\"ollama\"], // Only test available providers\r\n      },\r\n    },\r\n\r\n    // Test generation\r\n    generation: {\r\n      models: true, // Generate model tests\r\n      api: true, // Generate API tests\r\n      components: true, // Generate component tests\r\n      hooks: true, // Generate hook tests\r\n      e2e: false, // E2E tests not auto-generated\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n### CLI Test Commands\r\n\r\n**Comprehensive Test CLI:**\r\n\r\n```bash\r\n# Run all tests\r\nfarm test\r\n\r\n# Run specific test suites\r\nfarm test --unit                 # Unit tests only\r\nfarm test --integration          # Integration tests only\r\nfarm test --e2e                  # E2E tests only\r\nfarm test --ai                   # AI-specific tests only\r\n\r\n# Test generation\r\nfarm test:generate               # Generate all missing tests\r\nfarm test:generate --models      # Generate model tests only\r\nfarm test:generate --api         # Generate API tests only\r\nfarm test:generate --components  # Generate component tests only\r\n\r\n# AI testing\r\nfarm test:ai                     # Run AI provider tests\r\nfarm test:ai --provider ollama   # Test specific provider\r\nfarm test:ai --performance      # Run AI performance tests\r\nfarm test:ai --integration      # Test real AI services (if available)\r\n\r\n# Coverage and reporting\r\nfarm test --coverage             # Run with coverage report\r\nfarm test --watch                # Watch mode for development\r\nfarm test --verbose             # Detailed output\r\n\r\n# Cross-stack testing\r\nfarm test:types                  # Test type consistency\r\nfarm test:contracts             # Test API contracts\r\nfarm test:pipeline              # Test code generation pipeline\r\n```\r\n\r\n### Test Configuration Examples\r\n\r\n**Backend Test Configuration:**\r\n\r\n```python\r\n# apps/api/pytest.ini\r\n[tool:pytest]\r\ntestpaths = tests\r\npython_files = test_*.py\r\npython_classes = Test*\r\npython_functions = test_*\r\naddopts =\r\n    --verbose\r\n    --tb=short\r\n    --strict-markers\r\n    --disable-warnings\r\n    --cov=src\r\n    --cov-report=html\r\n    --cov-report=term-missing\r\n    --cov-fail-under=80\r\n\r\nmarkers =\r\n    unit: Unit tests\r\n    integration: Integration tests\r\n    ai: AI-specific tests\r\n    performance: Performance tests\r\n    slow: Slow tests (skipped in CI)\r\n```\r\n\r\n**Frontend Test Configuration:**\r\n\r\n```javascript\r\n// apps/web/jest.config.js\r\nmodule.exports = {\r\n  testEnvironment: \"jsdom\",\r\n  setupFilesAfterEnv: [\"<rootDir>/tests/setup.ts\"],\r\n  testMatch: [\r\n    \"<rootDir>/src/**/__tests__/**/*.{js,jsx,ts,tsx}\",\r\n    \"<rootDir>/src/**/*.{test,spec}.{js,jsx,ts,tsx}\",\r\n  ],\r\n  collectCoverageFrom: [\r\n    \"src/**/*.{ts,tsx}\",\r\n    \"!src/**/*.d.ts\",\r\n    \"!src/types/**/*\", // Generated types excluded\r\n    \"!src/services/**/*\", // Generated API client excluded\r\n  ],\r\n  coverageThreshold: {\r\n    global: {\r\n      branches: 80,\r\n      functions: 80,\r\n      lines: 80,\r\n      statements: 80,\r\n    },\r\n  },\r\n  moduleNameMapping: {\r\n    \"^@/(.*)$\": \"<rootDir>/src/$1\",\r\n  },\r\n  transform: {\r\n    \"^.+\\\\.(ts|tsx)$\": \"ts-jest\",\r\n  },\r\n};\r\n```\r\n\r\n---\r\n\r\n## Continuous Integration Integration\r\n\r\n### GitHub Actions Test Workflow\r\n\r\n```yaml\r\n# .github/workflows/test.yml\r\nname: FARM Test Suite\r\n\r\non:\r\n  push:\r\n    branches: [main, develop]\r\n  pull_request:\r\n    branches: [main]\r\n\r\njobs:\r\n  framework-tests:\r\n    runs-on: ubuntu-latest\r\n    name: Framework Core Tests\r\n\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n\r\n      - name: Setup Node.js\r\n        uses: actions/setup-node@v3\r\n        with:\r\n          node-version: \"18\"\r\n          cache: \"npm\"\r\n\r\n      - name: Setup Python\r\n        uses: actions/setup-python@v4\r\n        with:\r\n          python-version: \"3.11\"\r\n\r\n      - name: Install dependencies\r\n        run: |\r\n          npm ci\r\n          pip install -r requirements.txt\r\n\r\n      - name: Run framework tests\r\n        run: |\r\n          npm test -- --coverage\r\n          pytest --cov=src --cov-report=xml\r\n\r\n      - name: Upload coverage\r\n        uses: codecov/codecov-action@v3\r\n\r\n  ai-integration-tests:\r\n    runs-on: ubuntu-latest\r\n    name: AI Integration Tests\r\n\r\n    services:\r\n      ollama:\r\n        image: ollama/ollama:latest\r\n        ports:\r\n          - 11434:11434\r\n\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n\r\n      - name: Setup test environment\r\n        run: |\r\n          # Wait for Ollama to be ready\r\n          until curl -f http://localhost:11434/api/tags; do sleep 5; done\r\n\r\n          # Pull test model\r\n          curl -X POST http://localhost:11434/api/pull -d '{\"name\": \"llama3.1\"}'\r\n\r\n      - name: Run AI tests\r\n        run: |\r\n          farm test:ai --integration\r\n        env:\r\n          OLLAMA_URL: http://localhost:11434\r\n          INTEGRATION_TESTS: true\r\n\r\n  e2e-tests:\r\n    runs-on: ubuntu-latest\r\n    name: End-to-End Tests\r\n\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n\r\n      - name: Setup environment\r\n        run: |\r\n          docker-compose up -d\r\n          npm ci\r\n          npx playwright install\r\n\r\n      - name: Run E2E tests\r\n        run: |\r\n          npm run test:e2e\r\n\r\n      - name: Upload test results\r\n        uses: actions/upload-artifact@v3\r\n        if: failure()\r\n        with:\r\n          name: playwright-report\r\n          path: playwright-report/\r\n```\r\n\r\n---\r\n\r\n_Status: ✅ Completed - Ready for implementation_\r\n",
      "excerpt": "The FARM testing strategy encompasses three layers: framework-level testing (testing FARM itself), auto-generated application testing (testing user code), and A...",
      "category": "architectural-sketches-detailed/phase3",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "farm",
        "typescript",
        "python"
      ],
      "lastModified": "2025-06-12T21:57:32.784Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase3",
        "Testing_strategy_architecture"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Testing Strategy Architecture",
          "id": "testing-strategy-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "Multi-Layer Testing Architecture",
          "id": "multi-layer-testing-architecture"
        },
        {
          "level": 2,
          "text": "Core Testing Components",
          "id": "core-testing-components"
        },
        {
          "level": 3,
          "text": "1. Framework-Level Testing Suite",
          "id": "1-framework-level-testing-suite"
        },
        {
          "level": 3,
          "text": "2. Auto-Generated Application Testing",
          "id": "2-auto-generated-application-testing"
        },
        {
          "level": 3,
          "text": "3. AI-Specific Testing Framework",
          "id": "3-ai-specific-testing-framework"
        },
        {
          "level": 1,
          "text": "apps/api/tests/ai/mocks/providers.py",
          "id": "appsapitestsaimocksproviderspy"
        },
        {
          "level": 1,
          "text": "apps/api/tests/ai/test_provider_integration.py",
          "id": "appsapitestsaitest_provider_integrationpy"
        },
        {
          "level": 3,
          "text": "4. Cross-Stack Integration Testing",
          "id": "4-cross-stack-integration-testing"
        },
        {
          "level": 3,
          "text": "5. End-to-End Testing Framework",
          "id": "5-end-to-end-testing-framework"
        },
        {
          "level": 2,
          "text": "Test Generation System",
          "id": "test-generation-system"
        },
        {
          "level": 3,
          "text": "1. Model-Based Test Generation",
          "id": "1-model-based-test-generation"
        },
        {
          "level": 1,
          "text": "tools/codegen/test_generator.py",
          "id": "toolscodegentest_generatorpy"
        },
        {
          "level": 3,
          "text": "2. API Route Test Generation",
          "id": "2-api-route-test-generation"
        },
        {
          "level": 1,
          "text": "tools/codegen/api_test_generator.py",
          "id": "toolscodegenapi_test_generatorpy"
        },
        {
          "level": 3,
          "text": "3. Frontend Test Generation",
          "id": "3-frontend-test-generation"
        },
        {
          "level": 2,
          "text": "AI Testing Infrastructure",
          "id": "ai-testing-infrastructure"
        },
        {
          "level": 3,
          "text": "1. AI Provider Mock Framework",
          "id": "1-ai-provider-mock-framework"
        },
        {
          "level": 1,
          "text": "packages/farm-testing/src/ai_mocks.py",
          "id": "packagesfarm-testingsrcai_mockspy"
        },
        {
          "level": 3,
          "text": "2. Performance Testing Framework",
          "id": "2-performance-testing-framework"
        },
        {
          "level": 1,
          "text": "packages/farm-testing/src/performance_testing.py",
          "id": "packagesfarm-testingsrcperformance_testingpy"
        },
        {
          "level": 3,
          "text": "3. Integration Testing with Real AI Services",
          "id": "3-integration-testing-with-real-ai-services"
        },
        {
          "level": 1,
          "text": "apps/api/tests/integration/test_real_ai_services.py",
          "id": "appsapitestsintegrationtest_real_ai_servicespy"
        },
        {
          "level": 2,
          "text": "Test Configuration & CLI Integration",
          "id": "test-configuration-cli-integration"
        },
        {
          "level": 3,
          "text": "Test Runner Configuration",
          "id": "test-runner-configuration"
        },
        {
          "level": 3,
          "text": "CLI Test Commands",
          "id": "cli-test-commands"
        },
        {
          "level": 1,
          "text": "Run all tests",
          "id": "run-all-tests"
        },
        {
          "level": 1,
          "text": "Run specific test suites",
          "id": "run-specific-test-suites"
        },
        {
          "level": 1,
          "text": "Test generation",
          "id": "test-generation"
        },
        {
          "level": 1,
          "text": "AI testing",
          "id": "ai-testing"
        },
        {
          "level": 1,
          "text": "Coverage and reporting",
          "id": "coverage-and-reporting"
        },
        {
          "level": 1,
          "text": "Cross-stack testing",
          "id": "cross-stack-testing"
        },
        {
          "level": 3,
          "text": "Test Configuration Examples",
          "id": "test-configuration-examples"
        },
        {
          "level": 1,
          "text": "apps/api/pytest.ini",
          "id": "appsapipytestini"
        },
        {
          "level": 2,
          "text": "Continuous Integration Integration",
          "id": "continuous-integration-integration"
        },
        {
          "level": 3,
          "text": "GitHub Actions Test Workflow",
          "id": "github-actions-test-workflow"
        },
        {
          "level": 1,
          "text": ".github/workflows/test.yml",
          "id": "githubworkflowstestyml"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase4-phase4_community_ecosystem",
      "title": "Phase4_community_ecosystem",
      "url": "/architectural-sketches-detailed/phase4/phase4_community_ecosystem",
      "content": "# Community & Plugin Ecosystem Architecture\r\n\r\n## Overview\r\n\r\nThe FARM ecosystem combines a robust plugin architecture with community-driven development to create a self-sustaining platform. It provides tools for plugin development, marketplace distribution, community contribution, and ecosystem growth.\r\n\r\n---\r\n\r\n## Ecosystem Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                     FARM Ecosystem Platform                    │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │Plugin       │  │Community    │  │Marketplace  │  │Developer│ │\r\n│  │Registry     │  │Hub          │  │Platform     │  │Tools    │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │Quality      │  │Security     │  │Analytics    │  │Support  │ │\r\n│  │Assurance    │  │Scanner      │  │Engine       │  │System   │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│               Community Governance & Growth Engine              │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Plugin Architecture & Development Kit\r\n\r\n### 1. Plugin Development Kit (PDK)\r\n\r\n**Purpose:** Standardized toolkit for creating FARM plugins\r\n\r\n**Implementation:**\r\n```typescript\r\n// packages/plugin-development-kit/src/index.ts\r\nexport interface FarmPlugin {\r\n  name: string;\r\n  version: string;\r\n  description: string;\r\n  author: string;\r\n  license: string;\r\n  farmVersion: string;\r\n  \r\n  // Plugin capabilities\r\n  capabilities: PluginCapability[];\r\n  \r\n  // Lifecycle hooks\r\n  install?(context: PluginContext): Promise<void> | void;\r\n  activate?(context: PluginContext): Promise<void> | void;\r\n  deactivate?(context: PluginContext): Promise<void> | void;\r\n  uninstall?(context: PluginContext): Promise<void> | void;\r\n  \r\n  // Configuration schema\r\n  configSchema?: JSONSchema;\r\n  defaultConfig?: Record<string, any>;\r\n}\r\n\r\nexport interface PluginContext {\r\n  // Framework access\r\n  farm: FarmFramework;\r\n  \r\n  // Configuration\r\n  config: PluginConfig;\r\n  projectConfig: FarmConfig;\r\n  \r\n  // Utilities\r\n  logger: Logger;\r\n  fs: FileSystem;\r\n  process: ProcessManager;\r\n  \r\n  // Hooks system\r\n  hooks: HookSystem;\r\n  \r\n  // Plugin communication\r\n  plugins: PluginRegistry;\r\n}\r\n\r\nexport type PluginCapability = \r\n  | 'database-provider'\r\n  | 'ai-provider' \r\n  | 'authentication'\r\n  | 'ui-components'\r\n  | 'build-tools'\r\n  | 'deployment'\r\n  | 'testing'\r\n  | 'monitoring'\r\n  | 'analytics';\r\n\r\n// Plugin development utilities\r\nexport class PluginBuilder {\r\n  static create(name: string): PluginBuilder {\r\n    return new PluginBuilder(name);\r\n  }\r\n  \r\n  capability(capability: PluginCapability): this {\r\n    this.plugin.capabilities.push(capability);\r\n    return this;\r\n  }\r\n  \r\n  configSchema(schema: JSONSchema): this {\r\n    this.plugin.configSchema = schema;\r\n    return this;\r\n  }\r\n  \r\n  onInstall(handler: (context: PluginContext) => void): this {\r\n    this.plugin.install = handler;\r\n    return this;\r\n  }\r\n  \r\n  addRoute(path: string, handler: RouteHandler): this {\r\n    this.routes.push({ path, handler });\r\n    return this;\r\n  }\r\n  \r\n  addComponent(name: string, component: React.Component): this {\r\n    this.components.set(name, component);\r\n    return this;\r\n  }\r\n  \r\n  addCommand(name: string, command: CLICommand): this {\r\n    this.commands.set(name, command);\r\n    return this;\r\n  }\r\n  \r\n  build(): FarmPlugin {\r\n    return this.plugin;\r\n  }\r\n}\r\n```\r\n\r\n### 2. Plugin Registry System\r\n\r\n**Purpose:** Centralized plugin discovery and management\r\n\r\n**Implementation:**\r\n```typescript\r\n// packages/plugin-registry/src/registry.ts\r\nexport interface PluginMetadata {\r\n  id: string;\r\n  name: string;\r\n  version: string;\r\n  description: string;\r\n  author: PluginAuthor;\r\n  \r\n  // Metrics\r\n  downloads: number;\r\n  rating: number;\r\n  reviews: number;\r\n  \r\n  // Classification\r\n  category: PluginCategory;\r\n  tags: string[];\r\n  \r\n  // Compatibility\r\n  farmVersions: string[];\r\n  dependencies: string[];\r\n  \r\n  // Repository info\r\n  repository: string;\r\n  homepage?: string;\r\n  documentation?: string;\r\n  \r\n  // Security & Quality\r\n  verified: boolean;\r\n  securityScan: SecurityScanResult;\r\n  qualityScore: number;\r\n  \r\n  // Marketplace info\r\n  pricing: 'free' | 'paid' | 'freemium';\r\n  price?: number;\r\n  license: string;\r\n}\r\n\r\nexport class PluginRegistry {\r\n  private plugins = new Map<string, PluginMetadata>();\r\n  private categories = new Map<string, PluginCategory>();\r\n  \r\n  async searchPlugins(query: PluginSearchQuery): Promise<PluginSearchResult[]> {\r\n    const filters = {\r\n      text: query.text,\r\n      category: query.category,\r\n      tags: query.tags,\r\n      author: query.author,\r\n      farmVersion: query.farmVersion,\r\n      verified: query.verifiedOnly,\r\n      pricing: query.pricing\r\n    };\r\n    \r\n    const results = await this.elasticSearch.search({\r\n      index: 'farm-plugins',\r\n      body: {\r\n        query: this.buildSearchQuery(filters),\r\n        sort: this.buildSortCriteria(query.sortBy),\r\n        size: query.limit || 20,\r\n        from: query.offset || 0\r\n      }\r\n    });\r\n    \r\n    return results.hits.map(hit => this.formatSearchResult(hit));\r\n  }\r\n  \r\n  async publishPlugin(plugin: PluginPackage, author: PluginAuthor): Promise<string> {\r\n    // Validate plugin structure\r\n    const validation = await this.validatePlugin(plugin);\r\n    if (!validation.valid) {\r\n      throw new PluginValidationError(validation.errors);\r\n    }\r\n    \r\n    // Security scan\r\n    const securityScan = await this.securityScanner.scan(plugin);\r\n    if (securityScan.severity === 'critical') {\r\n      throw new SecurityError('Plugin failed security scan');\r\n    }\r\n    \r\n    // Quality assessment\r\n    const qualityScore = await this.qualityAssessor.assess(plugin);\r\n    \r\n    // Generate plugin ID\r\n    const pluginId = this.generatePluginId(plugin.name, author.username);\r\n    \r\n    // Store in registry\r\n    const metadata: PluginMetadata = {\r\n      id: pluginId,\r\n      name: plugin.name,\r\n      version: plugin.version,\r\n      description: plugin.description,\r\n      author,\r\n      downloads: 0,\r\n      rating: 0,\r\n      reviews: 0,\r\n      category: plugin.category,\r\n      tags: plugin.tags,\r\n      farmVersions: plugin.farmVersions,\r\n      dependencies: plugin.dependencies,\r\n      repository: plugin.repository,\r\n      verified: author.verified,\r\n      securityScan,\r\n      qualityScore,\r\n      pricing: plugin.pricing || 'free',\r\n      license: plugin.license\r\n    };\r\n    \r\n    await this.storePlugin(metadata);\r\n    await this.notifyMaintainers(metadata);\r\n    \r\n    return pluginId;\r\n  }\r\n}\r\n```\r\n\r\n### 3. Official Plugin Templates\r\n\r\n**Purpose:** Standardized plugin templates for common use cases\r\n\r\n**Templates Available:**\r\n```typescript\r\n// Plugin templates with built-in best practices\r\nexport const PLUGIN_TEMPLATES = {\r\n  'ai-provider': {\r\n    description: 'Add new AI provider support',\r\n    files: {\r\n      'src/provider.py': aiProviderTemplate,\r\n      'src/client.ts': aiClientTemplate,\r\n      'tests/test_provider.py': aiTestTemplate,\r\n      'README.md': aiProviderReadme\r\n    },\r\n    dependencies: ['httpx', 'pydantic'],\r\n    capabilities: ['ai-provider']\r\n  },\r\n  \r\n  'database-provider': {\r\n    description: 'Add new database support',\r\n    files: {\r\n      'src/connection.py': dbConnectionTemplate,\r\n      'src/models.py': dbModelsTemplate,\r\n      'src/migrations.py': dbMigrationTemplate\r\n    },\r\n    capabilities: ['database-provider']\r\n  },\r\n  \r\n  'ui-components': {\r\n    description: 'UI component library',\r\n    files: {\r\n      'src/components/index.ts': componentIndexTemplate,\r\n      'src/styles/index.css': componentStylesTemplate,\r\n      'stories/components.stories.tsx': storybookTemplate\r\n    },\r\n    capabilities: ['ui-components']\r\n  },\r\n  \r\n  'authentication': {\r\n    description: 'Authentication provider',\r\n    files: {\r\n      'src/auth.py': authBackendTemplate,\r\n      'src/hooks.ts': authHooksTemplate,\r\n      'src/components.tsx': authComponentsTemplate\r\n    },\r\n    capabilities: ['authentication']\r\n  }\r\n};\r\n\r\n// Generate plugin from template\r\nexport async function generatePlugin(template: string, name: string, options: PluginOptions): Promise<void> {\r\n  const templateConfig = PLUGIN_TEMPLATES[template];\r\n  if (!templateConfig) {\r\n    throw new Error(`Unknown template: ${template}`);\r\n  }\r\n  \r\n  const pluginDir = path.join(options.outputDir, name);\r\n  await fs.ensureDir(pluginDir);\r\n  \r\n  // Generate files from templates\r\n  for (const [filePath, template] of Object.entries(templateConfig.files)) {\r\n    const content = await renderTemplate(template, {\r\n      pluginName: name,\r\n      authorName: options.author,\r\n      description: options.description,\r\n      ...options.variables\r\n    });\r\n    \r\n    await fs.writeFile(path.join(pluginDir, filePath), content);\r\n  }\r\n  \r\n  // Generate package.json\r\n  const packageJson = {\r\n    name: `farm-plugin-${name}`,\r\n    version: '1.0.0',\r\n    description: options.description,\r\n    main: 'dist/index.js',\r\n    types: 'dist/index.d.ts',\r\n    farm: {\r\n      capabilities: templateConfig.capabilities,\r\n      farmVersion: '^1.0.0'\r\n    },\r\n    dependencies: templateConfig.dependencies || {},\r\n    devDependencies: {\r\n      '@farm/plugin-development-kit': '^1.0.0',\r\n      'typescript': '^5.0.0'\r\n    }\r\n  };\r\n  \r\n  await fs.writeJSON(path.join(pluginDir, 'package.json'), packageJson, { spaces: 2 });\r\n  \r\n  console.log(`✅ Plugin ${name} generated successfully!`);\r\n  console.log(`📁 Location: ${pluginDir}`);\r\n  console.log(`🚀 Next steps:`);\r\n  console.log(`   cd ${name}`);\r\n  console.log(`   npm install`);\r\n  console.log(`   npm run dev`);\r\n}\r\n```\r\n\r\n---\r\n\r\n## Community Platform & Governance\r\n\r\n### 1. Community Hub Architecture\r\n\r\n**Purpose:** Central platform for community interaction and contribution\r\n\r\n**Implementation:**\r\n```typescript\r\n// platforms/community-hub/src/types.ts\r\nexport interface CommunityMember {\r\n  id: string;\r\n  username: string;\r\n  displayName: string;\r\n  avatar: string;\r\n  \r\n  // Reputation system\r\n  reputation: number;\r\n  badges: Badge[];\r\n  level: CommunityLevel;\r\n  \r\n  // Contributions\r\n  plugins: PluginContribution[];\r\n  documentation: DocContribution[];\r\n  support: SupportContribution[];\r\n  \r\n  // Social\r\n  followers: number;\r\n  following: number;\r\n  \r\n  // Profile\r\n  bio: string;\r\n  location?: string;\r\n  website?: string;\r\n  github?: string;\r\n  twitter?: string;\r\n}\r\n\r\nexport interface CommunityPost {\r\n  id: string;\r\n  type: 'showcase' | 'help' | 'discussion' | 'announcement';\r\n  title: string;\r\n  content: string;\r\n  author: CommunityMember;\r\n  \r\n  // Engagement\r\n  upvotes: number;\r\n  downvotes: number;\r\n  comments: number;\r\n  views: number;\r\n  \r\n  // Classification\r\n  tags: string[];\r\n  category: string;\r\n  difficulty?: 'beginner' | 'intermediate' | 'advanced';\r\n  \r\n  // Status\r\n  resolved?: boolean;\r\n  featured: boolean;\r\n  pinned: boolean;\r\n  \r\n  // Timestamps\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n// Community platform with Discord integration\r\nexport class CommunityPlatform {\r\n  async createShowcasePost(showcase: ProjectShowcase): Promise<string> {\r\n    // Validate project\r\n    const validation = await this.validateShowcase(showcase);\r\n    if (!validation.valid) {\r\n      throw new ValidationError(validation.errors);\r\n    }\r\n    \r\n    // Create community post\r\n    const post = await this.createPost({\r\n      type: 'showcase',\r\n      title: showcase.title,\r\n      content: showcase.description,\r\n      author: showcase.author,\r\n      tags: showcase.tags,\r\n      category: 'showcase'\r\n    });\r\n    \r\n    // Auto-post to Discord\r\n    await this.discordIntegration.postShowcase(showcase);\r\n    \r\n    // Trigger social media sharing\r\n    await this.socialMediaBot.shareShowcase(showcase);\r\n    \r\n    return post.id;\r\n  }\r\n  \r\n  async moderateContent(contentId: string, action: ModerationAction): Promise<void> {\r\n    const content = await this.getContent(contentId);\r\n    \r\n    switch (action.type) {\r\n      case 'feature':\r\n        await this.featureContent(content);\r\n        await this.notifyAuthor(content.author, 'content_featured');\r\n        break;\r\n        \r\n      case 'remove':\r\n        await this.removeContent(content, action.reason);\r\n        await this.notifyAuthor(content.author, 'content_removed', action.reason);\r\n        break;\r\n        \r\n      case 'edit':\r\n        await this.editContent(content, action.changes);\r\n        await this.notifyAuthor(content.author, 'content_edited');\r\n        break;\r\n    }\r\n    \r\n    // Log moderation action\r\n    await this.logModerationAction(action, content);\r\n  }\r\n}\r\n```\r\n\r\n### 2. Reputation & Gamification System\r\n\r\n**Purpose:** Encourage quality contributions through gamification\r\n\r\n**Implementation:**\r\n```typescript\r\n// platforms/community-hub/src/reputation.ts\r\nexport interface ReputationSystem {\r\n  calculateReputation(member: CommunityMember): number;\r\n  awardBadge(memberId: string, badge: Badge): Promise<void>;\r\n  checkLevelUp(memberId: string): Promise<CommunityLevel | null>;\r\n}\r\n\r\nexport const REPUTATION_ACTIONS = {\r\n  // Plugin contributions\r\n  PLUGIN_PUBLISHED: 100,\r\n  PLUGIN_FEATURED: 250,\r\n  PLUGIN_VERIFIED: 500,\r\n  PLUGIN_DOWNLOAD: 1, // per download\r\n  \r\n  // Documentation\r\n  DOCS_CONTRIBUTION: 50,\r\n  DOCS_MAJOR_EDIT: 20,\r\n  DOCS_TYPO_FIX: 5,\r\n  \r\n  // Community engagement\r\n  HELPFUL_ANSWER: 25,\r\n  ANSWER_ACCEPTED: 50,\r\n  POST_UPVOTED: 2,\r\n  POST_FEATURED: 100,\r\n  \r\n  // Mentoring\r\n  MENTOR_SESSION: 75,\r\n  NEWCOMER_HELP: 30,\r\n  CODE_REVIEW: 15,\r\n  \r\n  // Events\r\n  EVENT_SPEAKER: 200,\r\n  EVENT_ORGANIZER: 300,\r\n  HACKATHON_WINNER: 400\r\n};\r\n\r\nexport const COMMUNITY_LEVELS = [\r\n  { name: 'Seedling', minReputation: 0, perks: ['Basic forum access'] },\r\n  { name: 'Sprout', minReputation: 100, perks: ['Plugin publishing'] },\r\n  { name: 'Growth', minReputation: 500, perks: ['Documentation editing'] },\r\n  { name: 'Bloom', minReputation: 1000, perks: ['Community moderation'] },\r\n  { name: 'Harvest', minReputation: 2500, perks: ['Beta testing access'] },\r\n  { name: 'Ecosystem', minReputation: 5000, perks: ['Direct maintainer access'] }\r\n];\r\n\r\nexport const COMMUNITY_BADGES = [\r\n  // Contribution badges\r\n  { id: 'first-plugin', name: 'First Plugin', description: 'Published your first plugin' },\r\n  { id: 'verified-dev', name: 'Verified Developer', description: 'Verified plugin author' },\r\n  { id: 'documentation-hero', name: 'Documentation Hero', description: '50+ documentation contributions' },\r\n  \r\n  // Achievement badges\r\n  { id: 'ai-pioneer', name: 'AI Pioneer', description: 'Built innovative AI applications' },\r\n  { id: 'community-champion', name: 'Community Champion', description: 'Exceptional community support' },\r\n  { id: 'open-source-advocate', name: 'Open Source Advocate', description: 'Significant open source contributions' },\r\n  \r\n  // Special recognition\r\n  { id: 'core-contributor', name: 'Core Contributor', description: 'Contributed to FARM core' },\r\n  { id: 'founding-member', name: 'Founding Member', description: 'Early FARM community member' },\r\n  { id: 'conference-speaker', name: 'Conference Speaker', description: 'Spoke about FARM at conferences' }\r\n];\r\n\r\nexport class ReputationManager {\r\n  async awardReputation(memberId: string, action: keyof typeof REPUTATION_ACTIONS, multiplier: number = 1): Promise<void> {\r\n    const points = REPUTATION_ACTIONS[action] * multiplier;\r\n    const member = await this.getMember(memberId);\r\n    \r\n    // Update reputation\r\n    const newReputation = member.reputation + points;\r\n    await this.updateMemberReputation(memberId, newReputation);\r\n    \r\n    // Check for level up\r\n    const newLevel = this.calculateLevel(newReputation);\r\n    if (newLevel > member.level) {\r\n      await this.levelUpMember(memberId, newLevel);\r\n      await this.notifyLevelUp(member, newLevel);\r\n    }\r\n    \r\n    // Check for badge awards\r\n    await this.checkBadgeEligibility(memberId);\r\n    \r\n    // Activity feed\r\n    await this.addActivityFeedItem({\r\n      type: 'reputation_earned',\r\n      memberId,\r\n      points,\r\n      action,\r\n      timestamp: new Date()\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Plugin Marketplace Platform\r\n\r\n### 1. Marketplace Architecture\r\n\r\n**Purpose:** Discovery, distribution, and monetization platform for plugins\r\n\r\n**Implementation:**\r\n```typescript\r\n// platforms/marketplace/src/marketplace.ts\r\nexport interface MarketplacePlugin extends PluginMetadata {\r\n  // Marketplace specific\r\n  screenshots: string[];\r\n  demo?: string;\r\n  documentation: string;\r\n  \r\n  // Pricing\r\n  pricing: PluginPricing;\r\n  subscription?: SubscriptionPlan;\r\n  \r\n  // Reviews & ratings\r\n  averageRating: number;\r\n  totalReviews: number;\r\n  recentReviews: PluginReview[];\r\n  \r\n  // Analytics\r\n  weeklyDownloads: number;\r\n  monthlyDownloads: number;\r\n  totalDownloads: number;\r\n  \r\n  // Support\r\n  supportEmail?: string;\r\n  discordServer?: string;\r\n  issueTracker: string;\r\n}\r\n\r\nexport interface PluginPricing {\r\n  type: 'free' | 'one-time' | 'subscription';\r\n  price?: number;\r\n  currency?: string;\r\n  trial?: {\r\n    duration: number;\r\n    type: 'days' | 'projects';\r\n  };\r\n}\r\n\r\nexport class PluginMarketplace {\r\n  async discoverPlugins(filters: DiscoveryFilters): Promise<MarketplacePlugin[]> {\r\n    const searchQuery = {\r\n      bool: {\r\n        must: [\r\n          ...(filters.text ? [{ multi_match: { query: filters.text, fields: ['name', 'description', 'tags'] } }] : []),\r\n          ...(filters.category ? [{ term: { category: filters.category } }] : []),\r\n          ...(filters.pricing ? [{ term: { 'pricing.type': filters.pricing } }] : []),\r\n          ...(filters.verified ? [{ term: { verified: true } }] : [])\r\n        ],\r\n        filter: [\r\n          { range: { rating: { gte: filters.minRating || 0 } } },\r\n          { terms: { farmVersions: [filters.farmVersion] } }\r\n        ]\r\n      }\r\n    };\r\n    \r\n    const results = await this.elasticsearch.search({\r\n      index: 'marketplace-plugins',\r\n      body: {\r\n        query: searchQuery,\r\n        sort: this.buildSortCriteria(filters.sortBy),\r\n        size: filters.limit || 20\r\n      }\r\n    });\r\n    \r\n    return results.hits.map(hit => this.enhanceWithMarketplaceData(hit._source));\r\n  }\r\n  \r\n  async installPlugin(pluginId: string, userId: string): Promise<InstallationResult> {\r\n    const plugin = await this.getPlugin(pluginId);\r\n    const user = await this.getUser(userId);\r\n    \r\n    // Check licensing\r\n    if (plugin.pricing.type !== 'free') {\r\n      const license = await this.checkUserLicense(userId, pluginId);\r\n      if (!license.valid) {\r\n        throw new LicenseError('Valid license required');\r\n      }\r\n    }\r\n    \r\n    // Compatibility check\r\n    const compatibility = await this.checkCompatibility(plugin, user.farmVersion);\r\n    if (!compatibility.compatible) {\r\n      throw new CompatibilityError(compatibility.issues);\r\n    }\r\n    \r\n    // Security check\r\n    const securityCheck = await this.performSecurityCheck(plugin);\r\n    if (!securityCheck.safe) {\r\n      await this.warnUser(userId, securityCheck.warnings);\r\n    }\r\n    \r\n    // Generate installation package\r\n    const installationPackage = await this.generateInstallationPackage(plugin, user);\r\n    \r\n    // Track analytics\r\n    await this.trackInstallation(pluginId, userId);\r\n    \r\n    return {\r\n      package: installationPackage,\r\n      instructions: this.generateInstallationInstructions(plugin),\r\n      postInstallSteps: plugin.postInstallSteps || []\r\n    };\r\n  }\r\n  \r\n  async submitReview(pluginId: string, userId: string, review: PluginReview): Promise<void> {\r\n    // Validate user has actually used the plugin\r\n    const usage = await this.getPluginUsage(userId, pluginId);\r\n    if (!usage.hasUsed) {\r\n      throw new ValidationError('Must use plugin before reviewing');\r\n    }\r\n    \r\n    // Validate review content\r\n    const validation = await this.validateReview(review);\r\n    if (!validation.valid) {\r\n      throw new ValidationError(validation.errors);\r\n    }\r\n    \r\n    // Store review\r\n    await this.storeReview({\r\n      ...review,\r\n      pluginId,\r\n      userId,\r\n      timestamp: new Date(),\r\n      verified: usage.verified\r\n    });\r\n    \r\n    // Update plugin rating\r\n    await this.updatePluginRating(pluginId);\r\n    \r\n    // Notify plugin author\r\n    await this.notifyPluginAuthor(pluginId, review);\r\n  }\r\n}\r\n```\r\n\r\n### 2. Plugin Quality Assurance\r\n\r\n**Purpose:** Automated quality assessment and security scanning\r\n\r\n**Implementation:**\r\n```typescript\r\n// platforms/marketplace/src/quality_assurance.ts\r\nexport class PluginQualityAssurance {\r\n  async assessPlugin(plugin: PluginPackage): Promise<QualityAssessment> {\r\n    const assessments = await Promise.all([\r\n      this.codeQualityAssessment(plugin),\r\n      this.securityAssessment(plugin),\r\n      this.performanceAssessment(plugin),\r\n      this.documentationAssessment(plugin),\r\n      this.testCoverageAssessment(plugin)\r\n    ]);\r\n    \r\n    const overallScore = this.calculateOverallScore(assessments);\r\n    const recommendations = this.generateRecommendations(assessments);\r\n    \r\n    return {\r\n      score: overallScore,\r\n      breakdown: {\r\n        codeQuality: assessments[0].score,\r\n        security: assessments[1].score,\r\n        performance: assessments[2].score,\r\n        documentation: assessments[3].score,\r\n        testCoverage: assessments[4].score\r\n      },\r\n      recommendations,\r\n      issues: assessments.flatMap(a => a.issues),\r\n      autoFixes: assessments.flatMap(a => a.autoFixes)\r\n    };\r\n  }\r\n  \r\n  async securityAssessment(plugin: PluginPackage): Promise<SecurityAssessment> {\r\n    const checks = [\r\n      this.checkDependencyVulnerabilities(plugin),\r\n      this.checkCodeVulnerabilities(plugin),\r\n      this.checkPermissionRequests(plugin),\r\n      this.checkDataAccess(plugin),\r\n      this.checkNetworkAccess(plugin)\r\n    ];\r\n    \r\n    const results = await Promise.all(checks);\r\n    const severity = this.calculateMaxSeverity(results);\r\n    \r\n    return {\r\n      score: this.securityScoreFromSeverity(severity),\r\n      severity,\r\n      vulnerabilities: results.flatMap(r => r.vulnerabilities),\r\n      recommendations: results.flatMap(r => r.recommendations),\r\n      issues: results.flatMap(r => r.issues)\r\n    };\r\n  }\r\n  \r\n  async performanceAssessment(plugin: PluginPackage): Promise<PerformanceAssessment> {\r\n    // Static analysis\r\n    const staticAnalysis = await this.staticPerformanceAnalysis(plugin);\r\n    \r\n    // Bundle size analysis\r\n    const bundleAnalysis = await this.analyzeBundleSize(plugin);\r\n    \r\n    // Runtime simulation\r\n    const runtimeAnalysis = await this.simulateRuntimePerformance(plugin);\r\n    \r\n    return {\r\n      score: this.calculatePerformanceScore([staticAnalysis, bundleAnalysis, runtimeAnalysis]),\r\n      bundleSize: bundleAnalysis.size,\r\n      loadTime: runtimeAnalysis.loadTime,\r\n      memoryUsage: runtimeAnalysis.memoryUsage,\r\n      recommendations: [\r\n        ...staticAnalysis.recommendations,\r\n        ...bundleAnalysis.recommendations,\r\n        ...runtimeAnalysis.recommendations\r\n      ]\r\n    };\r\n  }\r\n}\r\n\r\n// Automated security scanning\r\nexport class SecurityScanner {\r\n  async scanPlugin(plugin: PluginPackage): Promise<SecurityScanResult> {\r\n    const scans = [\r\n      this.dependencyVulnerabilityScan(plugin),\r\n      this.codeVulnerabilityScan(plugin),\r\n      this.malwareDetection(plugin),\r\n      this.privacyAnalysis(plugin)\r\n    ];\r\n    \r\n    const results = await Promise.all(scans);\r\n    \r\n    return {\r\n      passed: results.every(r => r.passed),\r\n      severity: this.calculateMaxSeverity(results),\r\n      findings: results.flatMap(r => r.findings),\r\n      recommendations: results.flatMap(r => r.recommendations),\r\n      quarantined: results.some(r => r.severity === 'critical')\r\n    };\r\n  }\r\n  \r\n  async dependencyVulnerabilityScan(plugin: PluginPackage): Promise<ScanResult> {\r\n    // Use npm audit, snyk, or similar\r\n    const dependencies = await this.extractDependencies(plugin);\r\n    const vulnerabilities = [];\r\n    \r\n    for (const dep of dependencies) {\r\n      const vulns = await this.checkVulnerabilityDatabase(dep);\r\n      vulnerabilities.push(...vulns);\r\n    }\r\n    \r\n    return {\r\n      passed: vulnerabilities.length === 0,\r\n      severity: this.calculateSeverity(vulnerabilities),\r\n      findings: vulnerabilities,\r\n      recommendations: this.generateDependencyRecommendations(vulnerabilities)\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Community Growth & Engagement\r\n\r\n### 1. Discord Integration & Bot\r\n\r\n**Purpose:** Seamless community engagement through Discord\r\n\r\n**Implementation:**\r\n```typescript\r\n// integrations/discord/src/farm_bot.ts\r\nexport class FarmDiscordBot {\r\n  async setupCommunityServer(): Promise<void> {\r\n    // Create channel structure\r\n    await this.createChannels([\r\n      { name: 'welcome', type: 'text', category: 'Community' },\r\n      { name: 'general', type: 'text', category: 'Community' },\r\n      { name: 'showcase', type: 'text', category: 'Community' },\r\n      { name: 'help', type: 'text', category: 'Support' },\r\n      { name: 'plugin-dev', type: 'text', category: 'Development' },\r\n      { name: 'core-dev', type: 'text', category: 'Development' },\r\n      { name: 'ai-discussion', type: 'text', category: 'AI/ML' },\r\n      { name: 'voice-chat', type: 'voice', category: 'Community' }\r\n    ]);\r\n    \r\n    // Setup roles\r\n    await this.createRoles([\r\n      { name: 'Core Team', permissions: ['ADMINISTRATOR'] },\r\n      { name: 'Plugin Developer', permissions: ['MANAGE_MESSAGES'] },\r\n      { name: 'Community Moderator', permissions: ['MANAGE_MESSAGES'] },\r\n      { name: 'AI Enthusiast', permissions: [] },\r\n      { name: 'Newcomer', permissions: [] }\r\n    ]);\r\n    \r\n    // Setup bot commands\r\n    await this.registerCommands();\r\n  }\r\n  \r\n  @SlashCommand({ name: 'showcase', description: 'Share your FARM project' })\r\n  async showcaseProject(interaction: CommandInteraction, \r\n                       title: string, \r\n                       description: string, \r\n                       url?: string, \r\n                       github?: string): Promise<void> {\r\n    // Create showcase embed\r\n    const embed = new MessageEmbed()\r\n      .setTitle(`🌾 ${title}`)\r\n      .setDescription(description)\r\n      .setAuthor(interaction.user.username, interaction.user.avatarURL())\r\n      .setTimestamp();\r\n    \r\n    if (url) embed.setURL(url);\r\n    if (github) embed.addField('GitHub', github, true);\r\n    \r\n    // Post to showcase channel\r\n    const showcaseChannel = interaction.guild?.channels.cache.find(ch => ch.name === 'showcase');\r\n    await showcaseChannel?.send({ embeds: [embed] });\r\n    \r\n    // Cross-post to community hub\r\n    await this.communityHub.createShowcase({\r\n      title,\r\n      description,\r\n      author: await this.getMemberFromDiscord(interaction.user.id),\r\n      url,\r\n      github,\r\n      source: 'discord'\r\n    });\r\n    \r\n    await interaction.reply('Showcase posted! 🎉');\r\n  }\r\n  \r\n  @SlashCommand({ name: 'plugin', description: 'Search for plugins' })\r\n  async searchPlugins(interaction: CommandInteraction, query: string): Promise<void> {\r\n    const plugins = await this.marketplace.searchPlugins({ text: query, limit: 5 });\r\n    \r\n    if (plugins.length === 0) {\r\n      await interaction.reply(`No plugins found for \"${query}\"`);\r\n      return;\r\n    }\r\n    \r\n    const embed = new MessageEmbed()\r\n      .setTitle(`Plugin Search: ${query}`)\r\n      .setDescription(`Found ${plugins.length} plugins`);\r\n    \r\n    plugins.forEach(plugin => {\r\n      embed.addField(\r\n        `${plugin.name} (${plugin.version})`,\r\n        `${plugin.description}\\n⭐ ${plugin.rating} | 📦 ${plugin.downloads} downloads`,\r\n        false\r\n      );\r\n    });\r\n    \r\n    await interaction.reply({ embeds: [embed] });\r\n  }\r\n  \r\n  @SlashCommand({ name: 'help', description: 'Get help with FARM' })\r\n  async getHelp(interaction: CommandInteraction, topic?: string): Promise<void> {\r\n    if (!topic) {\r\n      const helpEmbed = new MessageEmbed()\r\n        .setTitle('FARM Help')\r\n        .setDescription('Choose a help topic:')\r\n        .addField('Getting Started', '`/help getting-started`', true)\r\n        .addField('AI Integration', '`/help ai`', true)\r\n        .addField('Plugin Development', '`/help plugins`', true)\r\n        .addField('Deployment', '`/help deploy`', true);\r\n      \r\n      await interaction.reply({ embeds: [helpEmbed] });\r\n      return;\r\n    }\r\n    \r\n    const helpContent = await this.documentationSystem.getHelpContent(topic);\r\n    const embed = new MessageEmbed()\r\n      .setTitle(`Help: ${topic}`)\r\n      .setDescription(helpContent.summary)\r\n      .addField('Quick Solution', helpContent.quickFix, false)\r\n      .addField('Learn More', `[Documentation](${helpContent.docsUrl})`, true);\r\n    \r\n    await interaction.reply({ embeds: [embed] });\r\n  }\r\n}\r\n```\r\n\r\n### 2. Community Events & Hackathons\r\n\r\n**Purpose:** Regular events to engage community and drive innovation\r\n\r\n**Implementation:**\r\n```typescript\r\n// events/community_events.ts\r\nexport interface CommunityEvent {\r\n  id: string;\r\n  type: 'hackathon' | 'workshop' | 'meetup' | 'webinar' | 'showcase';\r\n  title: string;\r\n  description: string;\r\n  \r\n  // Scheduling\r\n  startDate: Date;\r\n  endDate: Date;\r\n  timezone: string;\r\n  \r\n  // Logistics\r\n  format: 'virtual' | 'in-person' | 'hybrid';\r\n  location?: string;\r\n  maxParticipants?: number;\r\n  \r\n  // Content\r\n  agenda: EventAgenda[];\r\n  speakers: EventSpeaker[];\r\n  prizes?: EventPrize[];\r\n  \r\n  // Participation\r\n  registrations: EventRegistration[];\r\n  submissions?: EventSubmission[];\r\n  \r\n  // Community\r\n  discordChannel?: string;\r\n  liveStream?: string;\r\n  recordings?: string[];\r\n}\r\n\r\nexport class CommunityEventManager {\r\n  async scheduleQuarterlyHackathon(theme: string): Promise<CommunityEvent> {\r\n    const event: CommunityEvent = {\r\n      id: generateId(),\r\n      type: 'hackathon',\r\n      title: `FARM ${theme} Hackathon`,\r\n      description: `Build innovative AI applications using FARM Stack. Theme: ${theme}`,\r\n      \r\n      startDate: this.getNextQuarterStart(),\r\n      endDate: this.getHackathonEndDate(),\r\n      timezone: 'UTC',\r\n      \r\n      format: 'virtual',\r\n      maxParticipants: 500,\r\n      \r\n      agenda: [\r\n        { time: '2024-09-01T00:00:00Z', title: 'Registration Opens', type: 'milestone' },\r\n        { time: '2024-09-15T18:00:00Z', title: 'Kickoff & Team Formation', type: 'session' },\r\n        { time: '2024-09-16T00:00:00Z', title: 'Hacking Begins', type: 'milestone' },\r\n        { time: '2024-09-22T18:00:00Z', title: 'Submissions Due', type: 'deadline' },\r\n        { time: '2024-09-23T18:00:00Z', title: 'Demo Day & Awards', type: 'session' }\r\n      ],\r\n      \r\n      prizes: [\r\n        { place: 1, title: 'Grand Prize', description: '$5000 + Mentorship', value: 5000 },\r\n        { place: 2, title: 'AI Innovation', description: '$2500 + Cloud Credits', value: 2500 },\r\n        { place: 3, title: 'Community Choice', description: '$1000 + Swag', value: 1000 }\r\n      ],\r\n      \r\n      registrations: [],\r\n      submissions: []\r\n    };\r\n    \r\n    // Create Discord channel\r\n    event.discordChannel = await this.createEventChannel(event);\r\n    \r\n    // Setup registration form\r\n    await this.createRegistrationForm(event);\r\n    \r\n    // Schedule reminders\r\n    await this.scheduleEventReminders(event);\r\n    \r\n    return event;\r\n  }\r\n  \r\n  async organizeMonthlyWorkshop(topic: string, expert: EventSpeaker): Promise<CommunityEvent> {\r\n    const event: CommunityEvent = {\r\n      id: generateId(),\r\n      type: 'workshop',\r\n      title: `FARM Workshop: ${topic}`,\r\n      description: `Deep dive workshop on ${topic} with industry expert`,\r\n      \r\n      startDate: this.getNextWorkshopDate(),\r\n      endDate: this.addHours(this.getNextWorkshopDate(), 2),\r\n      timezone: 'UTC',\r\n      \r\n      format: 'virtual',\r\n      maxParticipants: 100,\r\n      \r\n      speakers: [expert],\r\n      \r\n      agenda: [\r\n        { time: 'T+0:00', title: 'Welcome & Introductions', type: 'session', duration: 15 },\r\n        { time: 'T+0:15', title: 'Core Concepts', type: 'session', duration: 30 },\r\n        { time: 'T+0:45', title: 'Hands-on Exercise', type: 'workshop', duration: 45 },\r\n        { time: 'T+1:30', title: 'Q&A & Discussion', type: 'session', duration: 30 }\r\n      ],\r\n      \r\n      registrations: []\r\n    };\r\n    \r\n    // Setup live streaming\r\n    event.liveStream = await this.setupLiveStream(event);\r\n    \r\n    // Create workshop materials\r\n    await this.createWorkshopMaterials(event, topic);\r\n    \r\n    return event;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Growth Metrics & Analytics\r\n\r\n### 1. Ecosystem Health Metrics\r\n\r\n**Purpose:** Track and optimize ecosystem growth\r\n\r\n**Implementation:**\r\n```typescript\r\n// analytics/ecosystem_metrics.ts\r\nexport interface EcosystemMetrics {\r\n  // Community growth\r\n  totalMembers: number;\r\n  activeMembers: number;\r\n  newMembersThisMonth: number;\r\n  retentionRate: number;\r\n  \r\n  // Plugin ecosystem\r\n  totalPlugins: number;\r\n  verifiedPlugins: number;\r\n  newPluginsThisMonth: number;\r\n  totalDownloads: number;\r\n  \r\n  // Engagement\r\n  forumPosts: number;\r\n  discordMessages: number;\r\n  githubContributions: number;\r\n  documentationViews: number;\r\n  \r\n  // Quality indicators\r\n  averagePluginRating: number;\r\n  supportResponseTime: number;\r\n  issueResolutionTime: number;\r\n  \r\n  // Framework adoption\r\n  projectsCreated: number;\r\n  activeProjects: number;\r\n  productionDeployments: number;\r\n}\r\n\r\nexport class EcosystemAnalytics {\r\n  async generateMonthlyReport(): Promise<EcosystemReport> {\r\n    const metrics = await this.collectMetrics();\r\n    const trends = await this.analyzeTrends(metrics);\r\n    const insights = await this.generateInsights(metrics, trends);\r\n    \r\n    return {\r\n      period: { start: this.getMonthStart(), end: this.getMonthEnd() },\r\n      metrics,\r\n      trends,\r\n      insights,\r\n      recommendations: await this.generateRecommendations(insights),\r\n      highlights: await this.extractHighlights(metrics),\r\n      concerns: await this.identifyConcerns(metrics)\r\n    };\r\n  }\r\n  \r\n  async trackPluginEcosystemHealth(): Promise<PluginEcosystemHealth> {\r\n    const plugins = await this.getAllPlugins();\r\n    \r\n    const health = {\r\n      totalCount: plugins.length,\r\n      activelyMaintained: plugins.filter(p => this.isActivelyMaintained(p)).length,\r\n      abandoned: plugins.filter(p => this.isAbandoned(p)).length,\r\n      qualityDistribution: this.analyzeQualityDistribution(plugins),\r\n      categoryDistribution: this.analyzeCategoryDistribution(plugins),\r\n      downloadTrends: await this.analyzeDownloadTrends(plugins),\r\n      authorDiversity: this.analyzeAuthorDiversity(plugins)\r\n    };\r\n    \r\n    // Identify ecosystem gaps\r\n    health.gaps = await this.identifyEcosystemGaps(plugins);\r\n    \r\n    // Recommend ecosystem improvements\r\n    health.recommendations = await this.recommendEcosystemImprovements(health);\r\n    \r\n    return health;\r\n  }\r\n  \r\n  async optimizeEcosystemGrowth(): Promise<GrowthOptimization> {\r\n    const currentMetrics = await this.collectMetrics();\r\n    const benchmarks = await this.getBenchmarkMetrics();\r\n    \r\n    const gaps = this.identifyGaps(currentMetrics, benchmarks);\r\n    const opportunities = await this.identifyGrowthOpportunities(gaps);\r\n    \r\n    return {\r\n      currentState: currentMetrics,\r\n      targetState: benchmarks,\r\n      gaps,\r\n      opportunities,\r\n      actionPlan: await this.generateActionPlan(opportunities),\r\n      timeline: this.createGrowthTimeline(opportunities)\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Success Metrics & KPIs\r\n\r\n### Ecosystem Health Indicators\r\n\r\n- **Plugin Ecosystem**: 500+ quality plugins within 12 months\r\n- **Community Size**: 10,000+ active community members within 18 months  \r\n- **Contribution Rate**: 50+ community contributions per month\r\n- **Plugin Quality**: Average 4.2+ star rating across marketplace\r\n- **Response Time**: &lt;4 hour average community support response time\r\n- **Retention**: 70%+ monthly active user retention\r\n\r\n### Growth Targets\r\n\r\n- **Quarter 1**: Foundation (100 plugins, 1000 members)\r\n- **Quarter 2**: Growth (250 plugins, 3000 members) \r\n- **Quarter 3**: Scale (400 plugins, 6000 members)\r\n- **Quarter 4**: Ecosystem (500+ plugins, 10000+ members)\r\n\r\n### Quality Benchmarks\r\n\r\n- **Plugin Standards**: 90%+ plugins pass quality assessment\r\n- **Security**: Zero critical security issues in verified plugins\r\n- **Documentation**: 95%+ documentation coverage for all APIs\r\n- **Support**: 85%+ user satisfaction with community support\r\n\r\n---\r\n\r\n*Status: ✅ Ready for implementation - Community ecosystem provides sustainable growth platform*\r\n",
      "excerpt": "The FARM ecosystem combines a robust plugin architecture with community-driven development to create a self-sustaining platform.",
      "category": "architectural-sketches-detailed/phase4",
      "type": "reference",
      "tags": [
        "react",
        "farm",
        "typescript",
        "authentication",
        "database"
      ],
      "lastModified": "2025-06-12T21:57:32.785Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase4",
        "Phase4_community_ecosystem"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Community & Plugin Ecosystem Architecture",
          "id": "community-plugin-ecosystem-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "Ecosystem Architecture",
          "id": "ecosystem-architecture"
        },
        {
          "level": 2,
          "text": "Plugin Architecture & Development Kit",
          "id": "plugin-architecture-development-kit"
        },
        {
          "level": 3,
          "text": "1. Plugin Development Kit (PDK)",
          "id": "1-plugin-development-kit-pdk"
        },
        {
          "level": 3,
          "text": "2. Plugin Registry System",
          "id": "2-plugin-registry-system"
        },
        {
          "level": 3,
          "text": "3. Official Plugin Templates",
          "id": "3-official-plugin-templates"
        },
        {
          "level": 2,
          "text": "Community Platform & Governance",
          "id": "community-platform-governance"
        },
        {
          "level": 3,
          "text": "1. Community Hub Architecture",
          "id": "1-community-hub-architecture"
        },
        {
          "level": 3,
          "text": "2. Reputation & Gamification System",
          "id": "2-reputation-gamification-system"
        },
        {
          "level": 2,
          "text": "Plugin Marketplace Platform",
          "id": "plugin-marketplace-platform"
        },
        {
          "level": 3,
          "text": "1. Marketplace Architecture",
          "id": "1-marketplace-architecture"
        },
        {
          "level": 3,
          "text": "2. Plugin Quality Assurance",
          "id": "2-plugin-quality-assurance"
        },
        {
          "level": 2,
          "text": "Community Growth & Engagement",
          "id": "community-growth-engagement"
        },
        {
          "level": 3,
          "text": "1. Discord Integration & Bot",
          "id": "1-discord-integration-bot"
        },
        {
          "level": 3,
          "text": "2. Community Events & Hackathons",
          "id": "2-community-events-hackathons"
        },
        {
          "level": 2,
          "text": "Growth Metrics & Analytics",
          "id": "growth-metrics-analytics"
        },
        {
          "level": 3,
          "text": "1. Ecosystem Health Metrics",
          "id": "1-ecosystem-health-metrics"
        },
        {
          "level": 2,
          "text": "Success Metrics & KPIs",
          "id": "success-metrics-kpis"
        },
        {
          "level": 3,
          "text": "Ecosystem Health Indicators",
          "id": "ecosystem-health-indicators"
        },
        {
          "level": 3,
          "text": "Growth Targets",
          "id": "growth-targets"
        },
        {
          "level": 3,
          "text": "Quality Benchmarks",
          "id": "quality-benchmarks"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase4-phase4_documentation_system",
      "title": "Phase4_documentation_system",
      "url": "/architectural-sketches-detailed/phase4/phase4_documentation_system",
      "content": "# Documentation System Design Architecture\r\n\r\n## Overview\r\n\r\nThe FARM documentation system provides comprehensive, auto-generated documentation that stays current with code changes. It combines traditional documentation with interactive examples, live code playground, and community-driven content to create the best-in-class developer experience.\r\n\r\n---\r\n\r\n## Documentation Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Documentation System                    │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │Auto-Generated│  │Interactive  │  │Live Code    │  │Community│ │\r\n│  │API Docs      │  │Guides       │  │Playground   │  │Content  │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │Code         │  │Version      │  │Search &     │  │Analytics│ │\r\n│  │Extractor    │  │Manager      │  │Navigation   │  │Tracker  │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│               Static Site Generator & Deployment                │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Core Components\r\n\r\n### 1. Auto-Generated API Documentation\r\n\r\n**Purpose:** Automatically generate comprehensive API documentation from FastAPI applications\r\n\r\n**Implementation:**\r\n```python\r\n# tools/docs/api_extractor.py\r\nfrom fastapi import FastAPI\r\nfrom fastapi.openapi.utils import get_openapi\r\nimport json\r\nfrom typing import Dict, Any\r\nfrom pathlib import Path\r\n\r\nclass APIDocumentationExtractor:\r\n    def __init__(self, app: FastAPI):\r\n        self.app = app\r\n        \r\n    def extract_openapi_schema(self) -> Dict[str, Any]:\r\n        \"\"\"Extract OpenAPI schema with enhanced metadata\"\"\"\r\n        return get_openapi(\r\n            title=f\"{self.app.title} API\",\r\n            version=self.app.version,\r\n            description=self.app.description,\r\n            routes=self.app.routes,\r\n            tags=self.app.openapi_tags or []\r\n        )\r\n    \r\n    def generate_route_documentation(self) -> Dict[str, Any]:\r\n        \"\"\"Generate detailed route documentation with examples\"\"\"\r\n        routes_docs = {}\r\n        \r\n        for route in self.app.routes:\r\n            if hasattr(route, 'path') and hasattr(route, 'methods'):\r\n                route_info = {\r\n                    'path': route.path,\r\n                    'methods': list(route.methods),\r\n                    'description': getattr(route, 'description', ''),\r\n                    'examples': self.extract_route_examples(route),\r\n                    'parameters': self.extract_route_parameters(route),\r\n                    'responses': self.extract_route_responses(route)\r\n                }\r\n                routes_docs[route.path] = route_info\r\n                \r\n        return routes_docs\r\n    \r\n    def extract_model_documentation(self) -> Dict[str, Any]:\r\n        \"\"\"Extract Pydantic model documentation\"\"\"\r\n        models_docs = {}\r\n        \r\n        # Scan for Pydantic models in the application\r\n        for name, model in self.discover_pydantic_models().items():\r\n            models_docs[name] = {\r\n                'fields': self.extract_model_fields(model),\r\n                'schema': model.model_json_schema(),\r\n                'examples': self.extract_model_examples(model),\r\n                'relationships': self.extract_model_relationships(model)\r\n            }\r\n            \r\n        return models_docs\r\n```\r\n\r\n### 2. Interactive Documentation Generator\r\n\r\n**Purpose:** Create interactive guides with executable code examples\r\n\r\n**Implementation:**\r\n```typescript\r\n// tools/docs/interactive_generator.ts\r\nimport { MDXBundler } from 'mdx-bundler';\r\nimport { CodeBlock, InteractiveExample } from './components';\r\n\r\ninterface InteractiveGuide {\r\n  title: string;\r\n  slug: string;\r\n  category: string;\r\n  content: string;\r\n  examples: CodeExample[];\r\n  prerequisites: string[];\r\n  difficulty: 'beginner' | 'intermediate' | 'advanced';\r\n}\r\n\r\nclass InteractiveDocumentationGenerator {\r\n  async generateGuide(guide: InteractiveGuide): Promise<string> {\r\n    const { code, frontmatter } = await MDXBundler.bundleFromFile(guide.content, {\r\n      globals: {\r\n        '@farm/components': {\r\n          CodeBlock,\r\n          InteractiveExample,\r\n          AIProviderExample,\r\n          DatabaseExample\r\n        }\r\n      }\r\n    });\r\n    \r\n    return this.renderGuideWithNavigation(code, guide);\r\n  }\r\n  \r\n  generateQuickStartGuide(): InteractiveGuide {\r\n    return {\r\n      title: \"FARM Quick Start\",\r\n      slug: \"quick-start\",\r\n      category: \"getting-started\",\r\n      content: `\r\n# Get Started with FARM in 5 Minutes\r\n\r\nFARM makes building AI-powered full-stack applications incredibly simple.\r\n\r\n## Step 1: Create Your Project\r\n\r\n\\`\\`\\`bash\r\nnpx create-farm-app my-ai-app --template ai-chat\r\ncd my-ai-app\r\n\\`\\`\\`\r\n\r\n<InteractiveExample \r\n  type=\"cli\"\r\n  command=\"npx create-farm-app\"\r\n  description=\"Try the CLI with different templates\"\r\n/>\r\n\r\n## Step 2: Start Development Server\r\n\r\n\\`\\`\\`bash\r\nfarm dev\r\n\\`\\`\\`\r\n\r\nThis starts:\r\n- ✅ MongoDB database\r\n- ✅ FastAPI backend (http://localhost:8000)\r\n- ✅ React frontend (http://localhost:3000)\r\n- ✅ Ollama AI service (http://localhost:11434)\r\n\r\n<InteractiveExample\r\n  type=\"development\"\r\n  services={['mongodb', 'fastapi', 'react', 'ollama']}\r\n  description=\"See the development server in action\"\r\n/>\r\n\r\n## Step 3: Build Your First AI Feature\r\n\r\nAdd a simple chat endpoint:\r\n\r\n\\`\\`\\`python\r\n# apps/api/src/routes/chat.py\r\nfrom farm.ai import AIProvider\r\n\r\n@router.post(\"/chat\")\r\nasync def chat(request: ChatRequest):\r\n    ai = AIProvider.get_default()  # Uses Ollama in development\r\n    response = await ai.chat(request.messages, model=\"llama3.1\")\r\n    return {\"response\": response}\r\n\\`\\`\\`\r\n\r\n<AIProviderExample\r\n  endpoint=\"/api/chat\"\r\n  provider=\"ollama\"\r\n  model=\"llama3.1\"\r\n  interactive={true}\r\n/>\r\n\r\n## Step 4: Use in Frontend\r\n\r\nThe TypeScript types and API client are automatically generated:\r\n\r\n\\`\\`\\`typescript\r\nimport { useStreamingChat } from '@farm/hooks';\r\n\r\nfunction ChatComponent() {\r\n  const { messages, sendMessage, isStreaming } = useStreamingChat({\r\n    provider: 'ollama',\r\n    model: 'llama3.1'\r\n  });\r\n  \r\n  return (\r\n    <div>\r\n      <Messages messages={messages} />\r\n      <ChatInput onSend={sendMessage} disabled={isStreaming} />\r\n    </div>\r\n  );\r\n}\r\n\\`\\`\\`\r\n\r\n<InteractiveExample\r\n  type=\"react\"\r\n  component=\"ChatComponent\"\r\n  live={true}\r\n  description=\"Try the chat component live\"\r\n/>\r\n\r\nThat's it! You now have a working AI chat application with:\r\n- 🔄 Auto-generated TypeScript types\r\n- 🤖 Local AI inference with Ollama\r\n- ⚡ Hot reload across the entire stack\r\n- 🎯 Type-safe API calls\r\n      `,\r\n      examples: [],\r\n      prerequisites: ['Node.js 18+', 'Docker'],\r\n      difficulty: 'beginner'\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n### 3. Live Code Playground\r\n\r\n**Purpose:** Embedded code playground for testing FARM concepts\r\n\r\n**Implementation:**\r\n```typescript\r\n// tools/docs/playground.tsx\r\nimport React, { useState, useEffect } from 'react';\r\nimport { SandpackProvider, SandpackLayout, SandpackCodeEditor, SandpackPreview } from '@codesandbox/sandpack-react';\r\n\r\ninterface PlaygroundProps {\r\n  type: 'fullstack' | 'frontend' | 'backend' | 'ai';\r\n  initialCode: Record<string, string>;\r\n  template: string;\r\n  showPreview?: boolean;\r\n  allowEditing?: boolean;\r\n}\r\n\r\nexport function FarmPlayground({ type, initialCode, template, showPreview = true }: PlaygroundProps) {\r\n  const [files, setFiles] = useState(initialCode);\r\n  \r\n  const getTemplate = () => {\r\n    switch (type) {\r\n      case 'fullstack':\r\n        return {\r\n          files: {\r\n            '/farm.config.ts': farmConfigTemplate,\r\n            '/apps/api/src/main.py': fastApiTemplate,\r\n            '/apps/web/src/App.tsx': reactTemplate,\r\n            ...files\r\n          },\r\n          dependencies: {\r\n            '@farm/core': 'latest',\r\n            '@farm/ai-hooks': 'latest',\r\n            'react': '^18.0.0',\r\n            'typescript': '^5.0.0'\r\n          },\r\n          devDependencies: {\r\n            '@types/react': '^18.0.0',\r\n            'vite': '^4.0.0'\r\n          },\r\n          template: 'vite-react-ts'\r\n        };\r\n      \r\n      case 'ai':\r\n        return {\r\n          files: {\r\n            '/chat-example.py': aiBackendTemplate,\r\n            '/ChatComponent.tsx': aiReactTemplate,\r\n            ...files\r\n          },\r\n          dependencies: {\r\n            '@farm/ai-client': 'latest',\r\n            'react': '^18.0.0'\r\n          },\r\n          template: 'react-ts'\r\n        };\r\n        \r\n      default:\r\n        return { files, template };\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <div className=\"playground-container\">\r\n      <SandpackProvider {...getTemplate()}>\r\n        <SandpackLayout>\r\n          <SandpackCodeEditor \r\n            showTabs\r\n            showLineNumbers\r\n            showInlineErrors\r\n            wrapContent\r\n          />\r\n          {showPreview && (\r\n            <SandpackPreview \r\n              showOpenInCodeSandbox={false}\r\n              showRefreshButton={true}\r\n            />\r\n          )}\r\n        </SandpackLayout>\r\n      </SandpackProvider>\r\n      \r\n      <div className=\"playground-actions\">\r\n        <button onClick={() => downloadProject()}>\r\n          Download as FARM Project\r\n        </button>\r\n        <button onClick={() => deployToVercel()}>\r\n          Deploy to Vercel\r\n        </button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst farmConfigTemplate = `\r\nimport { defineConfig } from '@farm/core';\r\n\r\nexport default defineConfig({\r\n  template: 'ai-chat',\r\n  features: ['auth', 'ai'],\r\n  ai: {\r\n    providers: {\r\n      ollama: {\r\n        enabled: true,\r\n        models: ['llama3.1'],\r\n        defaultModel: 'llama3.1'\r\n      }\r\n    }\r\n  }\r\n});\r\n`;\r\n```\r\n\r\n### 4. Community Content Management\r\n\r\n**Purpose:** Enable community-driven documentation contributions\r\n\r\n**Implementation:**\r\n```typescript\r\n// tools/docs/community_content.ts\r\ninterface CommunityContent {\r\n  id: string;\r\n  type: 'guide' | 'example' | 'tutorial' | 'tip';\r\n  title: string;\r\n  author: string;\r\n  content: string;\r\n  tags: string[];\r\n  difficulty: 'beginner' | 'intermediate' | 'advanced';\r\n  upvotes: number;\r\n  status: 'draft' | 'review' | 'published';\r\n  farmVersion: string;\r\n}\r\n\r\nclass CommunityContentManager {\r\n  async submitContent(content: Omit<CommunityContent, 'id' | 'upvotes' | 'status'>): Promise<string> {\r\n    // Validate content format\r\n    const validation = await this.validateContent(content);\r\n    if (!validation.valid) {\r\n      throw new Error(`Content validation failed: ${validation.errors.join(', ')}`);\r\n    }\r\n    \r\n    // Create GitHub PR for community review\r\n    const prUrl = await this.createPullRequest(content);\r\n    \r\n    // Add to content database with 'review' status\r\n    const contentId = await this.saveContent({\r\n      ...content,\r\n      id: generateId(),\r\n      upvotes: 0,\r\n      status: 'review'\r\n    });\r\n    \r\n    return contentId;\r\n  }\r\n  \r\n  async moderateContent(contentId: string, action: 'approve' | 'reject', feedback?: string): Promise<void> {\r\n    const content = await this.getContent(contentId);\r\n    \r\n    if (action === 'approve') {\r\n      // Merge GitHub PR\r\n      await this.mergePullRequest(content.prUrl);\r\n      \r\n      // Update status to published\r\n      await this.updateContentStatus(contentId, 'published');\r\n      \r\n      // Trigger documentation rebuild\r\n      await this.triggerRebuild();\r\n    } else {\r\n      // Close PR with feedback\r\n      await this.closePullRequest(content.prUrl, feedback);\r\n      await this.updateContentStatus(contentId, 'rejected');\r\n    }\r\n  }\r\n  \r\n  generateContributionGuide(): string {\r\n    return `\r\n# Contributing to FARM Documentation\r\n\r\n## Content Types\r\n\r\n- **Guides**: Step-by-step tutorials (15-30 min read)\r\n- **Examples**: Code samples with explanations (5-10 min)\r\n- **Tips**: Quick productivity tips (2-5 min)\r\n- **Tutorials**: Comprehensive project walkthroughs (30+ min)\r\n\r\n## Submission Process\r\n\r\n1. **Draft**: Write your content using our template\r\n2. **Submit**: Use the community portal to submit for review\r\n3. **Review**: Community and maintainers provide feedback\r\n4. **Publish**: Approved content goes live automatically\r\n\r\n## Content Standards\r\n\r\n- Must work with latest FARM version\r\n- Include working code examples\r\n- Test all examples before submission\r\n- Follow writing style guide\r\n- Include difficulty level and time estimate\r\n\r\n## Recognition\r\n\r\n- Author bylines on all published content\r\n- Community contributor badge\r\n- Annual community awards\r\n- Direct feedback from FARM maintainers\r\n    `;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Documentation Site Architecture\r\n\r\n### Static Site Generation\r\n\r\n```typescript\r\n// tools/docs/site_generator.ts\r\nimport { NextJS } from 'next';\r\nimport { MDX } from '@mdx-js/loader';\r\n\r\nclass DocumentationSiteGenerator {\r\n  async generateSite(): Promise<void> {\r\n    const config = {\r\n      // Auto-generated content\r\n      apiDocs: await this.generateAPIDocumentation(),\r\n      guides: await this.generateInteractiveGuides(),\r\n      examples: await this.generateCodeExamples(),\r\n      \r\n      // Community content\r\n      communityGuides: await this.fetchCommunityContent(),\r\n      showcase: await this.generateShowcase(),\r\n      \r\n      // Version management\r\n      versions: await this.generateVersionedDocs(),\r\n      \r\n      // Search index\r\n      searchIndex: await this.buildSearchIndex()\r\n    };\r\n    \r\n    await this.buildStaticSite(config);\r\n    await this.deployToVercel();\r\n  }\r\n  \r\n  async generateAPIDocumentation(): Promise<APIDocumentation> {\r\n    // Extract from all FARM projects\r\n    const farmCore = await this.extractFromProject('@farm/core');\r\n    const farmAI = await this.extractFromProject('@farm/ai');\r\n    const farmCLI = await this.extractFromProject('@farm/cli');\r\n    \r\n    return {\r\n      core: farmCore,\r\n      ai: farmAI,\r\n      cli: farmCLI,\r\n      plugins: await this.extractPluginAPIs()\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n### Version Management\r\n\r\n```typescript\r\n// tools/docs/version_manager.ts\r\nclass DocumentationVersionManager {\r\n  async generateVersionedDocs(version: string): Promise<void> {\r\n    const versionConfig = {\r\n      version,\r\n      branch: `docs-v${version}`,\r\n      baseUrl: `/docs/v${version}`,\r\n      deprecationDate: this.calculateDeprecationDate(version),\r\n      migrationGuide: await this.generateMigrationGuide(version)\r\n    };\r\n    \r\n    // Generate docs for specific version\r\n    await this.generateDocsForVersion(versionConfig);\r\n    \r\n    // Update version selector\r\n    await this.updateVersionSelector(version);\r\n    \r\n    // Add deprecation notices for old versions\r\n    await this.addDeprecationNotices();\r\n  }\r\n  \r\n  async generateMigrationGuide(fromVersion: string, toVersion: string): Promise<string> {\r\n    const changes = await this.analyzeBreakingChanges(fromVersion, toVersion);\r\n    \r\n    return this.generateMigrationContent({\r\n      fromVersion,\r\n      toVersion,\r\n      breakingChanges: changes.breaking,\r\n      newFeatures: changes.features,\r\n      deprecations: changes.deprecations,\r\n      automatedMigration: changes.canAutoMigrate\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Search & Navigation System\r\n\r\n### Advanced Search Implementation\r\n\r\n```typescript\r\n// tools/docs/search_system.ts\r\nimport { FlexSearch } from 'flexsearch';\r\nimport { Algolia } from 'algoliasearch';\r\n\r\nclass DocumentationSearchSystem {\r\n  private flexSearch: FlexSearch.Index;\r\n  private algolia: Algolia;\r\n  \r\n  async buildSearchIndex(): Promise<void> {\r\n    // Local search with FlexSearch\r\n    this.flexSearch = new FlexSearch.Index({\r\n      tokenize: 'forward',\r\n      cache: true,\r\n      worker: true\r\n    });\r\n    \r\n    // Cloud search with Algolia\r\n    this.algolia = new Algolia('app-id', 'api-key');\r\n    \r\n    const documents = await this.collectAllDocuments();\r\n    \r\n    for (const doc of documents) {\r\n      // Add to local index\r\n      this.flexSearch.add(doc.id, this.prepareForSearch(doc));\r\n      \r\n      // Add to cloud index\r\n      await this.algolia.saveObject({\r\n        objectID: doc.id,\r\n        title: doc.title,\r\n        content: doc.content,\r\n        type: doc.type,\r\n        category: doc.category,\r\n        difficulty: doc.difficulty,\r\n        version: doc.version,\r\n        url: doc.url\r\n      });\r\n    }\r\n  }\r\n  \r\n  async search(query: string, filters?: SearchFilters): Promise<SearchResult[]> {\r\n    // Try local search first (faster)\r\n    const localResults = await this.flexSearch.search(query);\r\n    \r\n    if (localResults.length > 0) {\r\n      return this.formatResults(localResults);\r\n    }\r\n    \r\n    // Fallback to cloud search (more comprehensive)\r\n    const cloudResults = await this.algolia.search(query, {\r\n      filters: this.formatFilters(filters),\r\n      attributesToHighlight: ['title', 'content'],\r\n      hitsPerPage: 20\r\n    });\r\n    \r\n    return this.formatResults(cloudResults.hits);\r\n  }\r\n  \r\n  generateSearchInterface(): React.Component {\r\n    return `\r\n      <SearchProvider>\r\n        <SearchInput \r\n          placeholder=\"Search FARM docs...\"\r\n          suggestions={true}\r\n          shortcut=\"cmd+k\"\r\n        />\r\n        <SearchFilters>\r\n          <FilterGroup title=\"Content Type\">\r\n            <Filter value=\"guide\">Guides</Filter>\r\n            <Filter value=\"api\">API Reference</Filter>\r\n            <Filter value=\"example\">Examples</Filter>\r\n          </FilterGroup>\r\n          <FilterGroup title=\"Difficulty\">\r\n            <Filter value=\"beginner\">Beginner</Filter>\r\n            <Filter value=\"intermediate\">Intermediate</Filter>\r\n            <Filter value=\"advanced\">Advanced</Filter>\r\n          </FilterGroup>\r\n        </SearchFilters>\r\n        <SearchResults />\r\n      </SearchProvider>\r\n    `;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Analytics & Performance Tracking\r\n\r\n### Documentation Analytics\r\n\r\n```typescript\r\n// tools/docs/analytics.ts\r\nclass DocumentationAnalytics {\r\n  async trackUserJourney(): Promise<void> {\r\n    // Track common documentation paths\r\n    const journeys = [\r\n      'Landing → Quick Start → First Project',\r\n      'Search → API Reference → Code Example',\r\n      'Guide → Playground → Download Project'\r\n    ];\r\n    \r\n    for (const journey of journeys) {\r\n      await this.analyzeJourneyConversion(journey);\r\n    }\r\n  }\r\n  \r\n  async generateContentInsights(): Promise<ContentInsights> {\r\n    return {\r\n      // Most popular content\r\n      topGuides: await this.getTopContent('guide'),\r\n      topExamples: await this.getTopContent('example'),\r\n      \r\n      // Content gaps\r\n      searchWithNoResults: await this.getFailedSearches(),\r\n      requestedContent: await this.getContentRequests(),\r\n      \r\n      // Performance metrics\r\n      averageTimeOnPage: await this.getAverageTimeOnPage(),\r\n      bounceRate: await this.getBounceRate(),\r\n      conversionToDownload: await this.getConversionRate()\r\n    };\r\n  }\r\n  \r\n  async improveContentBasedOnAnalytics(): Promise<void> {\r\n    const insights = await this.generateContentInsights();\r\n    \r\n    // Auto-generate missing content\r\n    for (const gap of insights.searchWithNoResults) {\r\n      if (gap.frequency > 100) {\r\n        await this.suggestContentCreation(gap.query);\r\n      }\r\n    }\r\n    \r\n    // Optimize low-performing content\r\n    for (const page of insights.lowPerformingPages) {\r\n      await this.suggestContentImprovement(page);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Integration with FARM Development\r\n\r\n### Development-Time Documentation\r\n\r\n```python\r\n# Integration with FARM CLI\r\nclass FarmDocumentationIntegration:\r\n    def generate_project_docs(self, project_path: str) -> None:\r\n        \"\"\"Generate documentation for a FARM project\"\"\"\r\n        \r\n        # Extract API documentation\r\n        api_docs = self.extract_fastapi_docs(project_path)\r\n        \r\n        # Extract component documentation\r\n        component_docs = self.extract_react_docs(project_path)\r\n        \r\n        # Extract AI model documentation\r\n        ai_docs = self.extract_ai_docs(project_path)\r\n        \r\n        # Generate project README\r\n        readme = self.generate_project_readme({\r\n            'api': api_docs,\r\n            'components': component_docs,\r\n            'ai': ai_docs,\r\n            'config': self.extract_config_docs(project_path)\r\n        })\r\n        \r\n        # Write documentation files\r\n        self.write_docs_to_project(project_path, {\r\n            'README.md': readme,\r\n            'docs/api.md': api_docs,\r\n            'docs/components.md': component_docs,\r\n            'docs/ai.md': ai_docs\r\n        })\r\n    \r\n    def extract_fastapi_docs(self, project_path: str) -> str:\r\n        \"\"\"Extract FastAPI documentation with examples\"\"\"\r\n        # Analyze FastAPI routes and models\r\n        # Generate markdown with code examples\r\n        # Include AI provider examples\r\n        pass\r\n    \r\n    def extract_react_docs(self, project_path: str) -> str:\r\n        \"\"\"Extract React component documentation\"\"\"\r\n        # Analyze React components\r\n        # Extract prop types and usage examples\r\n        # Include AI hook documentation\r\n        pass\r\n```\r\n\r\n---\r\n\r\n## Deployment & CDN Strategy\r\n\r\n### Global Documentation Deployment\r\n\r\n```yaml\r\n# .github/workflows/docs-deploy.yml\r\nname: Deploy Documentation\r\n\r\non:\r\n  push:\r\n    branches: [main]\r\n    paths: ['docs/**', 'tools/docs/**']\r\n  \r\n  # Deploy on new releases\r\n  release:\r\n    types: [published]\r\n\r\njobs:\r\n  build-and-deploy:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      \r\n      - name: Setup Node.js\r\n        uses: actions/setup-node@v3\r\n        with:\r\n          node-version: '18'\r\n          \r\n      - name: Install dependencies\r\n        run: npm install\r\n        \r\n      - name: Extract API documentation\r\n        run: npm run docs:extract-api\r\n        \r\n      - name: Generate interactive guides\r\n        run: npm run docs:generate-guides\r\n        \r\n      - name: Build search index\r\n        run: npm run docs:build-search\r\n        \r\n      - name: Build documentation site\r\n        run: npm run docs:build\r\n        \r\n      - name: Deploy to Vercel\r\n        uses: vercel/action@v1\r\n        with:\r\n          vercel-token: ${{ secrets.VERCEL_TOKEN }}\r\n          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}\r\n          \r\n      - name: Update Algolia search index\r\n        run: npm run docs:update-search\r\n        env:\r\n          ALGOLIA_APP_ID: ${{ secrets.ALGOLIA_APP_ID }}\r\n          ALGOLIA_API_KEY: ${{ secrets.ALGOLIA_API_KEY }}\r\n          \r\n      - name: Notify Discord\r\n        run: npm run docs:notify-deploy\r\n        env:\r\n          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}\r\n```\r\n\r\n---\r\n\r\n## Success Metrics & KPIs\r\n\r\n### Documentation Effectiveness Metrics\r\n\r\n- **Developer Onboarding Speed**: Time from landing page to first working project\r\n- **Content Quality**: Community upvotes, time spent reading, bounce rate\r\n- **Search Effectiveness**: Search success rate, zero-result queries\r\n- **Community Engagement**: Contributions, discussions, feedback quality\r\n- **Framework Adoption**: Correlation between docs usage and framework adoption\r\n\r\n### Target Benchmarks\r\n\r\n- **Quick Start Completion**: &lt;10 minutes average\r\n- **Search Success Rate**: >90% of searches find relevant results\r\n- **Community Contributions**: 50+ community guides within 6 months\r\n- **Documentation Coverage**: 100% API coverage, 80% use case coverage\r\n- **Performance**: &lt;2s page load time globally\r\n\r\n---\r\n\r\n*Status: ✅ Ready for implementation - Documentation system provides comprehensive developer experience*\r\n",
      "excerpt": "The FARM documentation system provides comprehensive, auto-generated documentation that stays current with code changes.",
      "category": "architectural-sketches-detailed/phase4",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.785Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase4",
        "Phase4_documentation_system"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Documentation System Design Architecture",
          "id": "documentation-system-design-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "Documentation Architecture",
          "id": "documentation-architecture"
        },
        {
          "level": 2,
          "text": "Core Components",
          "id": "core-components"
        },
        {
          "level": 3,
          "text": "1. Auto-Generated API Documentation",
          "id": "1-auto-generated-api-documentation"
        },
        {
          "level": 1,
          "text": "tools/docs/api_extractor.py",
          "id": "toolsdocsapi_extractorpy"
        },
        {
          "level": 3,
          "text": "2. Interactive Documentation Generator",
          "id": "2-interactive-documentation-generator"
        },
        {
          "level": 1,
          "text": "Get Started with FARM in 5 Minutes",
          "id": "get-started-with-farm-in-5-minutes"
        },
        {
          "level": 2,
          "text": "Step 1: Create Your Project",
          "id": "step-1-create-your-project"
        },
        {
          "level": 2,
          "text": "Step 2: Start Development Server",
          "id": "step-2-start-development-server"
        },
        {
          "level": 2,
          "text": "Step 3: Build Your First AI Feature",
          "id": "step-3-build-your-first-ai-feature"
        },
        {
          "level": 1,
          "text": "apps/api/src/routes/chat.py",
          "id": "appsapisrcrouteschatpy"
        },
        {
          "level": 2,
          "text": "Step 4: Use in Frontend",
          "id": "step-4-use-in-frontend"
        },
        {
          "level": 3,
          "text": "3. Live Code Playground",
          "id": "3-live-code-playground"
        },
        {
          "level": 3,
          "text": "4. Community Content Management",
          "id": "4-community-content-management"
        },
        {
          "level": 1,
          "text": "Contributing to FARM Documentation",
          "id": "contributing-to-farm-documentation"
        },
        {
          "level": 2,
          "text": "Content Types",
          "id": "content-types"
        },
        {
          "level": 2,
          "text": "Submission Process",
          "id": "submission-process"
        },
        {
          "level": 2,
          "text": "Content Standards",
          "id": "content-standards"
        },
        {
          "level": 2,
          "text": "Recognition",
          "id": "recognition"
        },
        {
          "level": 2,
          "text": "Documentation Site Architecture",
          "id": "documentation-site-architecture"
        },
        {
          "level": 3,
          "text": "Static Site Generation",
          "id": "static-site-generation"
        },
        {
          "level": 3,
          "text": "Version Management",
          "id": "version-management"
        },
        {
          "level": 2,
          "text": "Search & Navigation System",
          "id": "search-navigation-system"
        },
        {
          "level": 3,
          "text": "Advanced Search Implementation",
          "id": "advanced-search-implementation"
        },
        {
          "level": 2,
          "text": "Analytics & Performance Tracking",
          "id": "analytics-performance-tracking"
        },
        {
          "level": 3,
          "text": "Documentation Analytics",
          "id": "documentation-analytics"
        },
        {
          "level": 2,
          "text": "Integration with FARM Development",
          "id": "integration-with-farm-development"
        },
        {
          "level": 3,
          "text": "Development-Time Documentation",
          "id": "development-time-documentation"
        },
        {
          "level": 1,
          "text": "Integration with FARM CLI",
          "id": "integration-with-farm-cli"
        },
        {
          "level": 2,
          "text": "Deployment & CDN Strategy",
          "id": "deployment-cdn-strategy"
        },
        {
          "level": 3,
          "text": "Global Documentation Deployment",
          "id": "global-documentation-deployment"
        },
        {
          "level": 1,
          "text": ".github/workflows/docs-deploy.yml",
          "id": "githubworkflowsdocs-deployyml"
        },
        {
          "level": 2,
          "text": "Success Metrics & KPIs",
          "id": "success-metrics-kpis"
        },
        {
          "level": 3,
          "text": "Documentation Effectiveness Metrics",
          "id": "documentation-effectiveness-metrics"
        },
        {
          "level": 3,
          "text": "Target Benchmarks",
          "id": "target-benchmarks"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "architectural-sketches-detailed-phase4-phase4_migration_upgrade",
      "title": "Phase4_migration_upgrade",
      "url": "/architectural-sketches-detailed/phase4/phase4_migration_upgrade",
      "content": "# Migration & Upgrade Strategy Architecture\r\n\r\n## Overview\r\n\r\nThe FARM migration and upgrade strategy ensures seamless framework evolution while maintaining backward compatibility and providing automated migration tools. This system enables confident long-term adoption by minimizing breaking changes and automating upgrade processes.\r\n\r\n---\r\n\r\n## Migration Architecture\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Migration System                       │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │Version      │  │Migration    │  │Compatibility│  │Automated│ │\r\n│  │Detection    │  │Engine       │  │Matrix       │  │Upgrades │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │\r\n│  │Breaking     │  │Deprecation  │  │Rollback     │  │Testing  │ │\r\n│  │Change       │  │Manager      │  │System       │  │Suite    │ │\r\n│  │Analyzer     │  │             │  │             │  │         │ │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│               Validation & Safety Systems                       │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Semantic Versioning Strategy\r\n\r\n### 1. FARM Versioning Schema\r\n\r\n**Purpose:** Clear, predictable versioning aligned with semantic versioning\r\n\r\n**Implementation:**\r\n```typescript\r\n// packages/core/src/version/versioning.ts\r\nexport interface FarmVersion {\r\n  major: number;      // Breaking changes\r\n  minor: number;      // New features (backward compatible)\r\n  patch: number;      // Bug fixes (backward compatible)\r\n  prerelease?: string; // alpha, beta, rc\r\n  build?: string;     // Build metadata\r\n}\r\n\r\nexport enum ChangeType {\r\n  BREAKING = 'breaking',\r\n  FEATURE = 'feature',\r\n  IMPROVEMENT = 'improvement',\r\n  FIX = 'fix',\r\n  SECURITY = 'security',\r\n  DEPRECATION = 'deprecation'\r\n}\r\n\r\nexport interface VersionChange {\r\n  type: ChangeType;\r\n  component: 'core' | 'cli' | 'ai' | 'database' | 'plugins';\r\n  description: string;\r\n  impact: 'low' | 'medium' | 'high';\r\n  migrationRequired: boolean;\r\n  automatedMigration: boolean;\r\n  deprecationDate?: Date;\r\n  removalDate?: Date;\r\n}\r\n\r\nexport class FarmVersionManager {\r\n  private static readonly VERSION_PATTERN = /^(\\d+)\\.(\\d+)\\.(\\d+)(?:-([a-zA-Z0-9\\-\\.]+))?(?:\\+([a-zA-Z0-9\\-\\.]+))?$/;\r\n  \r\n  static parseVersion(versionString: string): FarmVersion {\r\n    const match = this.VERSION_PATTERN.exec(versionString);\r\n    if (!match) {\r\n      throw new Error(`Invalid version format: ${versionString}`);\r\n    }\r\n    \r\n    return {\r\n      major: parseInt(match[1], 10),\r\n      minor: parseInt(match[2], 10),\r\n      patch: parseInt(match[3], 10),\r\n      prerelease: match[4],\r\n      build: match[5]\r\n    };\r\n  }\r\n  \r\n  static compareVersions(a: FarmVersion, b: FarmVersion): number {\r\n    // Major version comparison\r\n    if (a.major !== b.major) return a.major - b.major;\r\n    \r\n    // Minor version comparison\r\n    if (a.minor !== b.minor) return a.minor - b.minor;\r\n    \r\n    // Patch version comparison\r\n    if (a.patch !== b.patch) return a.patch - b.patch;\r\n    \r\n    // Prerelease comparison\r\n    if (a.prerelease && !b.prerelease) return -1;\r\n    if (!a.prerelease && b.prerelease) return 1;\r\n    if (a.prerelease && b.prerelease) {\r\n      return a.prerelease.localeCompare(b.prerelease);\r\n    }\r\n    \r\n    return 0;\r\n  }\r\n  \r\n  static isCompatible(currentVersion: FarmVersion, requiredVersion: string): boolean {\r\n    const required = this.parseVersion(requiredVersion);\r\n    \r\n    // Major version must match\r\n    if (currentVersion.major !== required.major) return false;\r\n    \r\n    // Current minor version must be >= required\r\n    if (currentVersion.minor < required.minor) return false;\r\n    \r\n    // If minor versions match, patch must be >= required\r\n    if (currentVersion.minor === required.minor && currentVersion.patch < required.patch) {\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n}\r\n```\r\n\r\n### 2. Release Planning & Change Management\r\n\r\n**Purpose:** Structured approach to managing breaking changes and releases\r\n\r\n**Implementation:**\r\n```typescript\r\n// tools/release/release_planner.ts\r\nexport interface ReleasePlan {\r\n  version: FarmVersion;\r\n  type: 'major' | 'minor' | 'patch';\r\n  changes: VersionChange[];\r\n  timeline: ReleaseTimeline;\r\n  compatibility: CompatibilityAssessment;\r\n  migration: MigrationPlan;\r\n  communication: CommunicationPlan;\r\n}\r\n\r\nexport interface ReleaseTimeline {\r\n  developmentStart: Date;\r\n  featureFreeze: Date;\r\n  betaRelease: Date;\r\n  rcRelease: Date;\r\n  finalRelease: Date;\r\n  supportEnd: Date;\r\n}\r\n\r\nexport class ReleasePlanner {\r\n  async planMajorRelease(targetVersion: FarmVersion, proposedChanges: VersionChange[]): Promise<ReleasePlan> {\r\n    // Analyze breaking changes\r\n    const breakingChanges = proposedChanges.filter(c => c.type === ChangeType.BREAKING);\r\n    \r\n    // Assess impact\r\n    const impact = await this.assessImpact(breakingChanges);\r\n    \r\n    // Create migration plan\r\n    const migrationPlan = await this.createMigrationPlan(breakingChanges);\r\n    \r\n    // Plan deprecation timeline\r\n    const deprecationPlan = await this.planDeprecations(proposedChanges);\r\n    \r\n    // Create communication strategy\r\n    const communicationPlan = await this.createCommunicationPlan(breakingChanges, impact);\r\n    \r\n    return {\r\n      version: targetVersion,\r\n      type: 'major',\r\n      changes: proposedChanges,\r\n      timeline: this.calculateTimeline('major', impact.severity),\r\n      compatibility: await this.assessCompatibility(targetVersion, proposedChanges),\r\n      migration: migrationPlan,\r\n      communication: communicationPlan\r\n    };\r\n  }\r\n  \r\n  async assessImpact(changes: VersionChange[]): Promise<ImpactAssessment> {\r\n    const assessment = {\r\n      severity: 'low' as 'low' | 'medium' | 'high',\r\n      affectedProjects: 0,\r\n      estimatedMigrationTime: '< 1 hour',\r\n      automationPossible: true,\r\n      riskLevel: 'low' as 'low' | 'medium' | 'high'\r\n    };\r\n    \r\n    // Analyze each breaking change\r\n    for (const change of changes) {\r\n      const usage = await this.analyzeFeatureUsage(change);\r\n      assessment.affectedProjects += usage.projectCount;\r\n      \r\n      if (change.impact === 'high' || !change.automatedMigration) {\r\n        assessment.severity = 'high';\r\n        assessment.riskLevel = 'high';\r\n        assessment.automationPossible = false;\r\n      }\r\n    }\r\n    \r\n    // Calculate migration time estimate\r\n    if (assessment.severity === 'high') {\r\n      assessment.estimatedMigrationTime = '4-8 hours';\r\n    } else if (assessment.severity === 'medium') {\r\n      assessment.estimatedMigrationTime = '1-4 hours';\r\n    }\r\n    \r\n    return assessment;\r\n  }\r\n  \r\n  async planDeprecations(changes: VersionChange[]): Promise<DeprecationPlan> {\r\n    const deprecations = changes.filter(c => c.type === ChangeType.DEPRECATION);\r\n    \r\n    const plan: DeprecationPlan = {\r\n      items: [],\r\n      timeline: this.createDeprecationTimeline(),\r\n      warningStrategy: 'progressive'\r\n    };\r\n    \r\n    for (const deprecation of deprecations) {\r\n      plan.items.push({\r\n        feature: deprecation.description,\r\n        deprecatedIn: this.getCurrentVersion(),\r\n        warningStartDate: new Date(),\r\n        removalDate: this.addVersions(this.getCurrentVersion(), { major: 2 }),\r\n        replacement: await this.findReplacement(deprecation),\r\n        migrationGuide: await this.createDeprecationMigrationGuide(deprecation)\r\n      });\r\n    }\r\n    \r\n    return plan;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Migration Engine\r\n\r\n### 1. Automated Migration System\r\n\r\n**Purpose:** Automatically upgrade projects to new FARM versions\r\n\r\n**Implementation:**\r\n```typescript\r\n// tools/migration/migration_engine.ts\r\nexport interface MigrationRule {\r\n  id: string;\r\n  name: string;\r\n  fromVersion: string;\r\n  toVersion: string;\r\n  component: string;\r\n  type: 'codemod' | 'config' | 'dependency' | 'file-rename' | 'manual';\r\n  automated: boolean;\r\n  description: string;\r\n  instructions?: string;\r\n  transform?: (content: string) => string;\r\n  filePattern?: string;\r\n}\r\n\r\nexport class MigrationEngine {\r\n  private rules: Map<string, MigrationRule[]> = new Map();\r\n  \r\n  async migrate(projectPath: string, targetVersion: string): Promise<MigrationResult> {\r\n    const currentVersion = await this.detectProjectVersion(projectPath);\r\n    const migrationPath = await this.planMigrationPath(currentVersion, targetVersion);\r\n    \r\n    const result: MigrationResult = {\r\n      success: false,\r\n      appliedMigrations: [],\r\n      skippedMigrations: [],\r\n      errors: [],\r\n      warnings: [],\r\n      manualSteps: [],\r\n      backupPath: ''\r\n    };\r\n    \r\n    try {\r\n      // Create backup\r\n      result.backupPath = await this.createBackup(projectPath);\r\n      \r\n      // Apply migrations in order\r\n      for (const step of migrationPath) {\r\n        const stepResult = await this.applyMigrationStep(projectPath, step);\r\n        \r\n        if (stepResult.success) {\r\n          result.appliedMigrations.push(step);\r\n        } else {\r\n          result.errors.push(...stepResult.errors);\r\n          if (!stepResult.canContinue) {\r\n            throw new MigrationError(`Critical migration failed: ${step.name}`);\r\n          }\r\n        }\r\n        \r\n        result.warnings.push(...stepResult.warnings);\r\n        result.manualSteps.push(...stepResult.manualSteps);\r\n      }\r\n      \r\n      // Validate migration\r\n      const validation = await this.validateMigration(projectPath, targetVersion);\r\n      if (!validation.valid) {\r\n        throw new MigrationError(`Migration validation failed: ${validation.errors.join(', ')}`);\r\n      }\r\n      \r\n      result.success = true;\r\n      \r\n    } catch (error) {\r\n      result.errors.push(error.message);\r\n      \r\n      // Attempt rollback\r\n      await this.rollback(projectPath, result.backupPath);\r\n      result.success = false;\r\n    }\r\n    \r\n    return result;\r\n  }\r\n  \r\n  async applyMigrationStep(projectPath: string, step: MigrationRule): Promise<MigrationStepResult> {\r\n    switch (step.type) {\r\n      case 'codemod':\r\n        return await this.applyCodemod(projectPath, step);\r\n        \r\n      case 'config':\r\n        return await this.migrateConfig(projectPath, step);\r\n        \r\n      case 'dependency':\r\n        return await this.migrateDependencies(projectPath, step);\r\n        \r\n      case 'file-rename':\r\n        return await this.renameFiles(projectPath, step);\r\n        \r\n      case 'manual':\r\n        return {\r\n          success: true,\r\n          canContinue: true,\r\n          errors: [],\r\n          warnings: [],\r\n          manualSteps: [step.instructions!]\r\n        };\r\n        \r\n      default:\r\n        throw new Error(`Unknown migration type: ${step.type}`);\r\n    }\r\n  }\r\n  \r\n  async applyCodemod(projectPath: string, step: MigrationRule): Promise<MigrationStepResult> {\r\n    const files = await this.findMatchingFiles(projectPath, step.filePattern!);\r\n    const result: MigrationStepResult = {\r\n      success: true,\r\n      canContinue: true,\r\n      errors: [],\r\n      warnings: [],\r\n      manualSteps: []\r\n    };\r\n    \r\n    for (const file of files) {\r\n      try {\r\n        const content = await fs.readFile(file, 'utf8');\r\n        const transformed = step.transform!(content);\r\n        \r\n        if (transformed !== content) {\r\n          await fs.writeFile(file, transformed, 'utf8');\r\n          console.log(`✅ Migrated: ${path.relative(projectPath, file)}`);\r\n        }\r\n      } catch (error) {\r\n        result.errors.push(`Failed to migrate ${file}: ${error.message}`);\r\n        result.success = false;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\n// Example migration rules\r\nexport const FARM_MIGRATION_RULES: MigrationRule[] = [\r\n  {\r\n    id: 'v1-to-v2-config',\r\n    name: 'Update farm.config.ts format',\r\n    fromVersion: '1.x',\r\n    toVersion: '2.0.0',\r\n    component: 'core',\r\n    type: 'codemod',\r\n    automated: true,\r\n    description: 'Update configuration format for FARM 2.0',\r\n    filePattern: 'farm.config.{ts,js}',\r\n    transform: (content: string) => {\r\n      // Transform v1 config to v2 format\r\n      return content\r\n        .replace(/export default {/, 'export default defineConfig({')\r\n        .replace(/import.*farm.*/, 'import { defineConfig } from \"@farm/core\";');\r\n    }\r\n  },\r\n  \r\n  {\r\n    id: 'v1-to-v2-ai-providers',\r\n    name: 'Update AI provider configuration',\r\n    fromVersion: '1.x',\r\n    toVersion: '2.0.0',\r\n    component: 'ai',\r\n    type: 'codemod',\r\n    automated: true,\r\n    description: 'Update AI provider configuration structure',\r\n    filePattern: 'farm.config.{ts,js}',\r\n    transform: (content: string) => {\r\n      // Update AI provider structure\r\n      return content.replace(\r\n        /ai:\\s*{([^}]+)}/g,\r\n        (match, providers) => {\r\n          return `ai: {\r\n  providers: {${providers}},\r\n  routing: {\r\n    development: 'ollama',\r\n    production: 'openai'\r\n  }\r\n}`;\r\n        }\r\n      );\r\n    }\r\n  },\r\n  \r\n  {\r\n    id: 'v1-to-v2-imports',\r\n    name: 'Update import statements',\r\n    fromVersion: '1.x',\r\n    toVersion: '2.0.0',\r\n    component: 'core',\r\n    type: 'codemod',\r\n    automated: true,\r\n    description: 'Update import paths for FARM 2.0',\r\n    filePattern: '**/*.{ts,tsx,js,jsx}',\r\n    transform: (content: string) => {\r\n      return content\r\n        .replace(/from ['\"]@farm\\/([^'\"]+)['\"]/g, 'from \"@farm/core/$1\"')\r\n        .replace(/import.*@farm\\/ai-hooks.*/g, 'import { useAI } from \"@farm/hooks\";');\r\n    }\r\n  }\r\n];\r\n```\r\n\r\n### 2. Configuration Migration\r\n\r\n**Purpose:** Automatically update configuration files between versions\r\n\r\n**Implementation:**\r\n```typescript\r\n// tools/migration/config_migrator.ts\r\nexport interface ConfigMigration {\r\n  fromVersion: string;\r\n  toVersion: string;\r\n  transformations: ConfigTransformation[];\r\n}\r\n\r\nexport interface ConfigTransformation {\r\n  type: 'rename' | 'restructure' | 'add' | 'remove' | 'merge';\r\n  path: string;\r\n  newPath?: string;\r\n  defaultValue?: any;\r\n  customTransform?: (value: any) => any;\r\n}\r\n\r\nexport class ConfigMigrator {\r\n  private migrations: ConfigMigration[] = [\r\n    {\r\n      fromVersion: '1.0.0',\r\n      toVersion: '2.0.0',\r\n      transformations: [\r\n        {\r\n          type: 'restructure',\r\n          path: 'ai',\r\n          customTransform: (ai: any) => ({\r\n            providers: ai,\r\n            routing: {\r\n              development: 'ollama',\r\n              production: 'openai'\r\n            },\r\n            features: {\r\n              streaming: true,\r\n              caching: false\r\n            }\r\n          })\r\n        },\r\n        {\r\n          type: 'rename',\r\n          path: 'database.mongodb',\r\n          newPath: 'database'\r\n        },\r\n        {\r\n          type: 'add',\r\n          path: 'development.hotReload',\r\n          defaultValue: {\r\n            enabled: true,\r\n            typeGeneration: true,\r\n            aiModels: true\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  ];\r\n  \r\n  async migrateConfig(configPath: string, targetVersion: string): Promise<ConfigMigrationResult> {\r\n    const config = await this.loadConfig(configPath);\r\n    const currentVersion = config.version || '1.0.0';\r\n    \r\n    const applicableMigrations = this.findApplicableMigrations(currentVersion, targetVersion);\r\n    \r\n    let migratedConfig = { ...config };\r\n    const warnings: string[] = [];\r\n    \r\n    for (const migration of applicableMigrations) {\r\n      for (const transformation of migration.transformations) {\r\n        try {\r\n          migratedConfig = await this.applyTransformation(migratedConfig, transformation);\r\n        } catch (error) {\r\n          warnings.push(`Failed to apply transformation at ${transformation.path}: ${error.message}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Update version\r\n    migratedConfig.version = targetVersion;\r\n    \r\n    // Validate new config\r\n    const validation = await this.validateConfig(migratedConfig);\r\n    if (!validation.valid) {\r\n      throw new ConfigMigrationError(`Invalid configuration after migration: ${validation.errors}`);\r\n    }\r\n    \r\n    // Write migrated config\r\n    await this.writeConfig(configPath, migratedConfig);\r\n    \r\n    return {\r\n      success: true,\r\n      warnings,\r\n      backup: await this.createConfigBackup(configPath),\r\n      changes: this.summarizeChanges(config, migratedConfig)\r\n    };\r\n  }\r\n  \r\n  private async applyTransformation(config: any, transformation: ConfigTransformation): Promise<any> {\r\n    const result = { ...config };\r\n    \r\n    switch (transformation.type) {\r\n      case 'rename':\r\n        const value = this.getValueAtPath(result, transformation.path);\r\n        this.setValueAtPath(result, transformation.newPath!, value);\r\n        this.deleteValueAtPath(result, transformation.path);\r\n        break;\r\n        \r\n      case 'restructure':\r\n        const currentValue = this.getValueAtPath(result, transformation.path);\r\n        const newValue = transformation.customTransform!(currentValue);\r\n        this.setValueAtPath(result, transformation.path, newValue);\r\n        break;\r\n        \r\n      case 'add':\r\n        if (!this.hasValueAtPath(result, transformation.path)) {\r\n          this.setValueAtPath(result, transformation.path, transformation.defaultValue);\r\n        }\r\n        break;\r\n        \r\n      case 'remove':\r\n        this.deleteValueAtPath(result, transformation.path);\r\n        break;\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Compatibility Management\r\n\r\n### 1. Compatibility Matrix\r\n\r\n**Purpose:** Track and manage compatibility across FARM ecosystem\r\n\r\n**Implementation:**\r\n```typescript\r\n// tools/compatibility/compatibility_matrix.ts\r\nexport interface CompatibilityMatrix {\r\n  farmVersion: string;\r\n  nodeVersions: VersionRange[];\r\n  pythonVersions: VersionRange[];\r\n  plugins: PluginCompatibility[];\r\n  databases: DatabaseCompatibility[];\r\n  aiProviders: AIProviderCompatibility[];\r\n}\r\n\r\nexport interface PluginCompatibility {\r\n  pluginName: string;\r\n  supportedVersions: VersionRange[];\r\n  lastTestedVersion: string;\r\n  knownIssues: KnownIssue[];\r\n  migrationAvailable: boolean;\r\n}\r\n\r\nexport class CompatibilityManager {\r\n  private matrix: Map<string, CompatibilityMatrix> = new Map();\r\n  \r\n  async checkProjectCompatibility(projectPath: string, targetVersion: string): Promise<CompatibilityReport> {\r\n    const project = await this.analyzeProject(projectPath);\r\n    const targetMatrix = await this.getCompatibilityMatrix(targetVersion);\r\n    \r\n    const report: CompatibilityReport = {\r\n      compatible: true,\r\n      warnings: [],\r\n      blockers: [],\r\n      recommendations: []\r\n    };\r\n    \r\n    // Check Node.js version\r\n    const nodeCompatibility = this.checkNodeCompatibility(project.nodeVersion, targetMatrix.nodeVersions);\r\n    if (!nodeCompatibility.compatible) {\r\n      report.blockers.push({\r\n        type: 'runtime',\r\n        component: 'Node.js',\r\n        current: project.nodeVersion,\r\n        required: targetMatrix.nodeVersions,\r\n        severity: 'critical',\r\n        resolution: 'Update Node.js to a supported version'\r\n      });\r\n      report.compatible = false;\r\n    }\r\n    \r\n    // Check Python version\r\n    const pythonCompatibility = this.checkPythonCompatibility(project.pythonVersion, targetMatrix.pythonVersions);\r\n    if (!pythonCompatibility.compatible) {\r\n      report.blockers.push({\r\n        type: 'runtime',\r\n        component: 'Python',\r\n        current: project.pythonVersion,\r\n        required: targetMatrix.pythonVersions,\r\n        severity: 'critical',\r\n        resolution: 'Update Python to a supported version'\r\n      });\r\n      report.compatible = false;\r\n    }\r\n    \r\n    // Check plugins\r\n    for (const plugin of project.plugins) {\r\n      const pluginCompatibility = this.checkPluginCompatibility(plugin, targetMatrix);\r\n      if (!pluginCompatibility.compatible) {\r\n        if (pluginCompatibility.migrationAvailable) {\r\n          report.warnings.push({\r\n            type: 'plugin',\r\n            component: plugin.name,\r\n            current: plugin.version,\r\n            issue: 'Plugin migration required',\r\n            severity: 'warning',\r\n            resolution: `Run: farm migrate plugin ${plugin.name}`\r\n          });\r\n        } else {\r\n          report.blockers.push({\r\n            type: 'plugin',\r\n            component: plugin.name,\r\n            current: plugin.version,\r\n            issue: 'Plugin not compatible',\r\n            severity: 'critical',\r\n            resolution: 'Remove plugin or find alternative'\r\n          });\r\n          report.compatible = false;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return report;\r\n  }\r\n  \r\n  async generateCompatibilityMatrix(farmVersion: string): Promise<CompatibilityMatrix> {\r\n    // Test against different runtime versions\r\n    const nodeVersions = await this.testNodeCompatibility(farmVersion);\r\n    const pythonVersions = await this.testPythonCompatibility(farmVersion);\r\n    \r\n    // Test plugin ecosystem\r\n    const plugins = await this.testPluginCompatibility(farmVersion);\r\n    \r\n    // Test database integrations\r\n    const databases = await this.testDatabaseCompatibility(farmVersion);\r\n    \r\n    // Test AI providers\r\n    const aiProviders = await this.testAIProviderCompatibility(farmVersion);\r\n    \r\n    return {\r\n      farmVersion,\r\n      nodeVersions,\r\n      pythonVersions,\r\n      plugins,\r\n      databases,\r\n      aiProviders\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n### 2. Deprecation Management\r\n\r\n**Purpose:** Manage feature deprecations with clear timelines and migration paths\r\n\r\n**Implementation:**\r\n```typescript\r\n// tools/deprecation/deprecation_manager.ts\r\nexport interface DeprecationNotice {\r\n  feature: string;\r\n  component: string;\r\n  deprecatedIn: string;\r\n  removedIn: string;\r\n  replacement?: string;\r\n  migrationGuide: string;\r\n  reason: string;\r\n  impact: 'low' | 'medium' | 'high';\r\n  automated: boolean;\r\n}\r\n\r\nexport class DeprecationManager {\r\n  private deprecations: Map<string, DeprecationNotice> = new Map();\r\n  \r\n  async addDeprecation(deprecation: DeprecationNotice): Promise<void> {\r\n    // Validate deprecation timeline\r\n    this.validateDeprecationTimeline(deprecation);\r\n    \r\n    // Store deprecation\r\n    this.deprecations.set(deprecation.feature, deprecation);\r\n    \r\n    // Generate migration guide\r\n    await this.generateMigrationGuide(deprecation);\r\n    \r\n    // Schedule warnings\r\n    await this.scheduleDeprecationWarnings(deprecation);\r\n    \r\n    // Update documentation\r\n    await this.updateDocumentation(deprecation);\r\n  }\r\n  \r\n  async scanForDeprecatedUsage(projectPath: string): Promise<DeprecationScanResult> {\r\n    const usage: DeprecatedFeatureUsage[] = [];\r\n    \r\n    // Scan code files\r\n    const files = await this.findCodeFiles(projectPath);\r\n    \r\n    for (const file of files) {\r\n      const content = await fs.readFile(file, 'utf8');\r\n      \r\n      for (const [feature, deprecation] of this.deprecations) {\r\n        const matches = this.findDeprecatedUsage(content, feature);\r\n        \r\n        for (const match of matches) {\r\n          usage.push({\r\n            feature,\r\n            file: path.relative(projectPath, file),\r\n            line: match.line,\r\n            column: match.column,\r\n            context: match.context,\r\n            deprecation,\r\n            fixAvailable: deprecation.automated\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Scan configuration\r\n    const configUsage = await this.scanConfigForDeprecations(projectPath);\r\n    usage.push(...configUsage);\r\n    \r\n    return {\r\n      usage,\r\n      summary: this.summarizeDeprecationUsage(usage),\r\n      migrationEstimate: this.estimateMigrationEffort(usage)\r\n    };\r\n  }\r\n  \r\n  async generateWarnings(projectPath: string): Promise<DeprecationWarning[]> {\r\n    const scan = await this.scanForDeprecatedUsage(projectPath);\r\n    const warnings: DeprecationWarning[] = [];\r\n    \r\n    for (const usage of scan.usage) {\r\n      const timeUntilRemoval = this.calculateTimeUntilRemoval(usage.deprecation);\r\n      \r\n      warnings.push({\r\n        message: this.formatWarningMessage(usage, timeUntilRemoval),\r\n        severity: this.calculateWarningSeverity(timeUntilRemoval, usage.deprecation.impact),\r\n        file: usage.file,\r\n        line: usage.line,\r\n        feature: usage.feature,\r\n        replacement: usage.deprecation.replacement,\r\n        migrationGuide: usage.deprecation.migrationGuide,\r\n        automated: usage.fixAvailable\r\n      });\r\n    }\r\n    \r\n    return warnings.sort((a, b) => this.compareSeverity(a.severity, b.severity));\r\n  }\r\n  \r\n  private calculateWarningSeverity(timeUntilRemoval: Duration, impact: string): 'info' | 'warning' | 'error' {\r\n    if (timeUntilRemoval.months <= 3) {\r\n      return impact === 'high' ? 'error' : 'warning';\r\n    } else if (timeUntilRemoval.months <= 6) {\r\n      return impact === 'high' ? 'warning' : 'info';\r\n    } else {\r\n      return 'info';\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Automated Testing & Validation\r\n\r\n### 1. Migration Testing Framework\r\n\r\n**Purpose:** Ensure migrations work correctly across different project types\r\n\r\n**Implementation:**\r\n```typescript\r\n// tools/testing/migration_testing.ts\r\nexport interface MigrationTestSuite {\r\n  name: string;\r\n  fromVersion: string;\r\n  toVersion: string;\r\n  testCases: MigrationTestCase[];\r\n}\r\n\r\nexport interface MigrationTestCase {\r\n  name: string;\r\n  description: string;\r\n  projectTemplate: string;\r\n  setup: () => Promise<void>;\r\n  validate: (migratedProject: string) => Promise<TestResult>;\r\n  cleanup: () => Promise<void>;\r\n}\r\n\r\nexport class MigrationTester {\r\n  async runMigrationTests(suite: MigrationTestSuite): Promise<MigrationTestResult> {\r\n    const results: TestCaseResult[] = [];\r\n    \r\n    for (const testCase of suite.testCases) {\r\n      const result = await this.runTestCase(testCase, suite.fromVersion, suite.toVersion);\r\n      results.push(result);\r\n    }\r\n    \r\n    return {\r\n      suite: suite.name,\r\n      fromVersion: suite.fromVersion,\r\n      toVersion: suite.toVersion,\r\n      totalTests: results.length,\r\n      passed: results.filter(r => r.passed).length,\r\n      failed: results.filter(r => !r.passed).length,\r\n      results\r\n    };\r\n  }\r\n  \r\n  async runTestCase(testCase: MigrationTestCase, fromVersion: string, toVersion: string): Promise<TestCaseResult> {\r\n    const testDir = await this.createTestEnvironment(testCase.name);\r\n    \r\n    try {\r\n      // Setup test project\r\n      await this.createTestProject(testDir, testCase.projectTemplate, fromVersion);\r\n      await testCase.setup();\r\n      \r\n      // Run migration\r\n      const migrationResult = await this.runMigration(testDir, toVersion);\r\n      \r\n      if (!migrationResult.success) {\r\n        return {\r\n          name: testCase.name,\r\n          passed: false,\r\n          error: `Migration failed: ${migrationResult.errors.join(', ')}`,\r\n          duration: migrationResult.duration\r\n        };\r\n      }\r\n      \r\n      // Validate result\r\n      const validationResult = await testCase.validate(testDir);\r\n      \r\n      if (!validationResult.passed) {\r\n        return {\r\n          name: testCase.name,\r\n          passed: false,\r\n          error: `Validation failed: ${validationResult.message}`,\r\n          duration: validationResult.duration\r\n        };\r\n      }\r\n      \r\n      // Test that project still works\r\n      const functionalTest = await this.runFunctionalTests(testDir);\r\n      \r\n      return {\r\n        name: testCase.name,\r\n        passed: functionalTest.passed,\r\n        error: functionalTest.error,\r\n        duration: functionalTest.duration,\r\n        migrationDetails: migrationResult\r\n      };\r\n      \r\n    } finally {\r\n      await testCase.cleanup();\r\n      await this.cleanupTestEnvironment(testDir);\r\n    }\r\n  }\r\n  \r\n  async createTestProject(dir: string, template: string, version: string): Promise<void> {\r\n    // Create project using specific FARM version\r\n    await this.runCommand(`npm install @farm/cli@${version}`, { cwd: dir });\r\n    await this.runCommand(`npx farm create test-project --template ${template}`, { cwd: dir });\r\n  }\r\n  \r\n  async runFunctionalTests(projectDir: string): Promise<TestResult> {\r\n    try {\r\n      // Install dependencies\r\n      await this.runCommand('npm install', { cwd: projectDir });\r\n      \r\n      // Run type checking\r\n      await this.runCommand('npm run type-check', { cwd: projectDir });\r\n      \r\n      // Run tests\r\n      await this.runCommand('npm test', { cwd: projectDir });\r\n      \r\n      // Build project\r\n      await this.runCommand('npm run build', { cwd: projectDir });\r\n      \r\n      return { passed: true, duration: 0 };\r\n    } catch (error) {\r\n      return { \r\n        passed: false, \r\n        error: error.message,\r\n        duration: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Example migration test suites\r\nexport const MIGRATION_TEST_SUITES: MigrationTestSuite[] = [\r\n  {\r\n    name: 'Basic Project Migration',\r\n    fromVersion: '1.0.0',\r\n    toVersion: '2.0.0',\r\n    testCases: [\r\n      {\r\n        name: 'AI Chat Template',\r\n        description: 'Test migration of AI chat application',\r\n        projectTemplate: 'ai-chat',\r\n        setup: async () => {\r\n          // Add custom AI configuration\r\n        },\r\n        validate: async (dir) => {\r\n          // Verify AI configuration migrated correctly\r\n          const config = await this.loadConfig(path.join(dir, 'farm.config.ts'));\r\n          return {\r\n            passed: config.ai?.providers?.ollama?.enabled === true,\r\n            duration: 0\r\n          };\r\n        },\r\n        cleanup: async () => {}\r\n      }\r\n    ]\r\n  }\r\n];\r\n```\r\n\r\n### 2. Rollback System\r\n\r\n**Purpose:** Safe rollback mechanism when migrations fail\r\n\r\n**Implementation:**\r\n```typescript\r\n// tools/migration/rollback_system.ts\r\nexport interface RollbackPoint {\r\n  id: string;\r\n  version: string;\r\n  timestamp: Date;\r\n  backupPath: string;\r\n  metadata: ProjectMetadata;\r\n  checksums: Map<string, string>;\r\n}\r\n\r\nexport class RollbackSystem {\r\n  private rollbackPoints: Map<string, RollbackPoint> = new Map();\r\n  \r\n  async createRollbackPoint(projectPath: string, version: string): Promise<string> {\r\n    const rollbackId = this.generateRollbackId();\r\n    const backupPath = await this.createFullBackup(projectPath);\r\n    const metadata = await this.extractProjectMetadata(projectPath);\r\n    const checksums = await this.calculateChecksums(projectPath);\r\n    \r\n    const rollbackPoint: RollbackPoint = {\r\n      id: rollbackId,\r\n      version,\r\n      timestamp: new Date(),\r\n      backupPath,\r\n      metadata,\r\n      checksums\r\n    };\r\n    \r\n    this.rollbackPoints.set(rollbackId, rollbackPoint);\r\n    await this.persistRollbackPoint(rollbackPoint);\r\n    \r\n    return rollbackId;\r\n  }\r\n  \r\n  async rollback(projectPath: string, rollbackId?: string): Promise<RollbackResult> {\r\n    const rollbackPoint = rollbackId \r\n      ? this.rollbackPoints.get(rollbackId)\r\n      : this.getLatestRollbackPoint(projectPath);\r\n    \r\n    if (!rollbackPoint) {\r\n      throw new RollbackError('No rollback point available');\r\n    }\r\n    \r\n    try {\r\n      // Verify backup integrity\r\n      await this.verifyBackupIntegrity(rollbackPoint);\r\n      \r\n      // Clear current project\r\n      await this.clearProject(projectPath);\r\n      \r\n      // Restore from backup\r\n      await this.restoreFromBackup(rollbackPoint.backupPath, projectPath);\r\n      \r\n      // Verify restoration\r\n      const verification = await this.verifyRestoration(projectPath, rollbackPoint.checksums);\r\n      \r\n      if (!verification.valid) {\r\n        throw new RollbackError(`Rollback verification failed: ${verification.errors.join(', ')}`);\r\n      }\r\n      \r\n      return {\r\n        success: true,\r\n        restoredVersion: rollbackPoint.version,\r\n        restoredFiles: verification.fileCount,\r\n        warnings: verification.warnings\r\n      };\r\n      \r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        restoredVersion: rollbackPoint.version,\r\n        restoredFiles: 0,\r\n        warnings: []\r\n      };\r\n    }\r\n  }\r\n  \r\n  async listRollbackPoints(projectPath: string): Promise<RollbackPoint[]> {\r\n    const projectId = this.getProjectId(projectPath);\r\n    \r\n    return Array.from(this.rollbackPoints.values())\r\n      .filter(point => point.metadata.projectId === projectId)\r\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\r\n  }\r\n  \r\n  async cleanupOldRollbackPoints(maxAge: Duration = { days: 30 }): Promise<void> {\r\n    const cutoffDate = new Date(Date.now() - this.durationToMs(maxAge));\r\n    \r\n    for (const [id, point] of this.rollbackPoints) {\r\n      if (point.timestamp < cutoffDate) {\r\n        await this.deleteBackup(point.backupPath);\r\n        this.rollbackPoints.delete(id);\r\n        await this.removePersistedRollbackPoint(id);\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## CLI Integration\r\n\r\n### 1. Migration Commands\r\n\r\n**Purpose:** User-friendly CLI commands for migration operations\r\n\r\n**Implementation:**\r\n```bash\r\n# Migration CLI commands\r\nfarm migrate --to 2.0.0              # Migrate to specific version\r\nfarm migrate --check                 # Check compatibility without migrating\r\nfarm migrate --dry-run               # Show what would be migrated\r\nfarm migrate --rollback              # Rollback last migration\r\nfarm migrate --list-rollbacks        # List available rollback points\r\n\r\n# Deprecation commands\r\nfarm deprecations scan               # Scan for deprecated usage\r\nfarm deprecations fix                # Auto-fix deprecated usage\r\nfarm deprecations report             # Generate deprecation report\r\n\r\n# Version commands\r\nfarm version check                   # Check current version compatibility\r\nfarm version upgrade                 # Upgrade to latest version\r\nfarm version list                    # List available versions\r\n```\r\n\r\n**CLI Implementation:**\r\n```typescript\r\n// packages/cli/src/commands/migrate.ts\r\nexport class MigrateCommand {\r\n  async run(options: MigrateOptions): Promise<void> {\r\n    const projectPath = process.cwd();\r\n    \r\n    // Version compatibility check\r\n    if (options.check) {\r\n      await this.checkCompatibility(projectPath, options.to);\r\n      return;\r\n    }\r\n    \r\n    // Dry run\r\n    if (options.dryRun) {\r\n      await this.showMigrationPlan(projectPath, options.to);\r\n      return;\r\n    }\r\n    \r\n    // Rollback\r\n    if (options.rollback) {\r\n      await this.performRollback(projectPath, options.rollbackId);\r\n      return;\r\n    }\r\n    \r\n    // Actual migration\r\n    await this.performMigration(projectPath, options.to);\r\n  }\r\n  \r\n  private async performMigration(projectPath: string, targetVersion: string): Promise<void> {\r\n    const migrationEngine = new MigrationEngine();\r\n    \r\n    console.log(`🌾 Starting FARM migration to ${targetVersion}...`);\r\n    \r\n    // Pre-migration checks\r\n    const compatibility = await migrationEngine.checkCompatibility(projectPath, targetVersion);\r\n    if (!compatibility.compatible) {\r\n      console.error('❌ Migration cannot proceed due to compatibility issues:');\r\n      compatibility.blockers.forEach(blocker => {\r\n        console.error(`   • ${blocker.component}: ${blocker.issue}`);\r\n        console.error(`     Resolution: ${blocker.resolution}`);\r\n      });\r\n      process.exit(1);\r\n    }\r\n    \r\n    // Show warnings\r\n    if (compatibility.warnings.length > 0) {\r\n      console.warn('⚠️  Migration warnings:');\r\n      compatibility.warnings.forEach(warning => {\r\n        console.warn(`   • ${warning.component}: ${warning.issue}`);\r\n      });\r\n      \r\n      const proceed = await this.promptForConfirmation('Continue with migration?');\r\n      if (!proceed) {\r\n        console.log('Migration cancelled');\r\n        process.exit(0);\r\n      }\r\n    }\r\n    \r\n    // Perform migration\r\n    const result = await migrationEngine.migrate(projectPath, targetVersion);\r\n    \r\n    if (result.success) {\r\n      console.log('✅ Migration completed successfully!');\r\n      console.log(`📦 Applied ${result.appliedMigrations.length} migrations`);\r\n      \r\n      if (result.manualSteps.length > 0) {\r\n        console.log('\\n📝 Manual steps required:');\r\n        result.manualSteps.forEach((step, i) => {\r\n          console.log(`   ${i + 1}. ${step}`);\r\n        });\r\n      }\r\n      \r\n      if (result.warnings.length > 0) {\r\n        console.log('\\n⚠️  Warnings:');\r\n        result.warnings.forEach(warning => {\r\n          console.warn(`   • ${warning}`);\r\n        });\r\n      }\r\n      \r\n      console.log(`\\n🔄 Backup created at: ${result.backupPath}`);\r\n    } else {\r\n      console.error('❌ Migration failed:');\r\n      result.errors.forEach(error => {\r\n        console.error(`   • ${error}`);\r\n      });\r\n      console.log(`\\n🔄 Project rolled back to original state`);\r\n      process.exit(1);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Success Metrics & KPIs\r\n\r\n### Migration Success Metrics\r\n\r\n- **Migration Success Rate**: >95% of automated migrations complete successfully\r\n- **Rollback Rate**: &lt;5% of migrations require rollback\r\n- **Migration Time**: &lt;30 minutes for typical project migration\r\n- **Manual Intervention**: &lt;10% of migrations require manual steps\r\n- **Breaking Change Impact**: &lt;15% of projects affected by breaking changes\r\n\r\n### Compatibility Targets\r\n\r\n- **Node.js Support**: Support latest LTS and previous LTS versions\r\n- **Python Support**: Support Python 3.9+ (aligned with AI/ML ecosystem)\r\n- **Plugin Compatibility**: >90% of plugins compatible within 30 days of major release\r\n- **Database Support**: Maintain backward compatibility for database schemas\r\n\r\n### Developer Experience Metrics\r\n\r\n- **Migration Documentation**: 100% of breaking changes have migration guides\r\n- **Warning Lead Time**: 6+ months warning before feature removal\r\n- **Community Feedback**: &lt;24 hour response time for migration issues\r\n- **Enterprise Support**: Dedicated migration assistance for enterprise users\r\n\r\n---\r\n\r\n*Status: ✅ Ready for implementation - Migration strategy ensures smooth framework evolution*\r\n",
      "excerpt": "The FARM migration and upgrade strategy ensures seamless framework evolution while maintaining backward compatibility and providing automated migration tools.",
      "category": "architectural-sketches-detailed/phase4",
      "type": "reference",
      "tags": [
        "mongodb",
        "farm",
        "typescript",
        "python",
        "database"
      ],
      "lastModified": "2025-06-12T21:57:32.786Z",
      "breadcrumbs": [
        "Architectural Sketches Detailed",
        "Phase4",
        "Phase4_migration_upgrade"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Migration & Upgrade Strategy Architecture",
          "id": "migration-upgrade-strategy-architecture"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 2,
          "text": "Migration Architecture",
          "id": "migration-architecture"
        },
        {
          "level": 2,
          "text": "Semantic Versioning Strategy",
          "id": "semantic-versioning-strategy"
        },
        {
          "level": 3,
          "text": "1. FARM Versioning Schema",
          "id": "1-farm-versioning-schema"
        },
        {
          "level": 3,
          "text": "2. Release Planning & Change Management",
          "id": "2-release-planning-change-management"
        },
        {
          "level": 2,
          "text": "Migration Engine",
          "id": "migration-engine"
        },
        {
          "level": 3,
          "text": "1. Automated Migration System",
          "id": "1-automated-migration-system"
        },
        {
          "level": 3,
          "text": "2. Configuration Migration",
          "id": "2-configuration-migration"
        },
        {
          "level": 2,
          "text": "Compatibility Management",
          "id": "compatibility-management"
        },
        {
          "level": 3,
          "text": "1. Compatibility Matrix",
          "id": "1-compatibility-matrix"
        },
        {
          "level": 3,
          "text": "2. Deprecation Management",
          "id": "2-deprecation-management"
        },
        {
          "level": 2,
          "text": "Automated Testing & Validation",
          "id": "automated-testing-validation"
        },
        {
          "level": 3,
          "text": "1. Migration Testing Framework",
          "id": "1-migration-testing-framework"
        },
        {
          "level": 3,
          "text": "2. Rollback System",
          "id": "2-rollback-system"
        },
        {
          "level": 2,
          "text": "CLI Integration",
          "id": "cli-integration"
        },
        {
          "level": 3,
          "text": "1. Migration Commands",
          "id": "1-migration-commands"
        },
        {
          "level": 1,
          "text": "Migration CLI commands",
          "id": "migration-cli-commands"
        },
        {
          "level": 1,
          "text": "Deprecation commands",
          "id": "deprecation-commands"
        },
        {
          "level": 1,
          "text": "Version commands",
          "id": "version-commands"
        },
        {
          "level": 2,
          "text": "Success Metrics & KPIs",
          "id": "success-metrics-kpis"
        },
        {
          "level": 3,
          "text": "Migration Success Metrics",
          "id": "migration-success-metrics"
        },
        {
          "level": 3,
          "text": "Compatibility Targets",
          "id": "compatibility-targets"
        },
        {
          "level": 3,
          "text": "Developer Experience Metrics",
          "id": "developer-experience-metrics"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "blog",
      "title": "Blog",
      "url": "/blog",
      "content": "# FARM Framework Blog\n\nStay updated with the latest news, tutorials, and insights from the FARM Framework team.\n\n## Latest Posts\n\n### FARM Framework 2.0 Released: What's New\n\n_Posted on June 1, 2025_\n\nWe're excited to announce the release of FARM Framework 2.0 with major performance improvements, new features, and enhanced developer experience.\n\n**Key highlights:**\n\n- 40% faster build times\n- Improved TypeScript integration\n- New authentication system\n- Enhanced MongoDB ODM\n\n[Read full post →](/blog/farm-2-0-released)\n\n---\n\n### Building a Production-Ready SaaS with FARM\n\n_Posted on May 28, 2025_\n\nLearn how TechStartup built their multi-tenant SaaS application using FARM Framework, handling 10M+ requests per day.\n\n**Topics covered:**\n\n- Multi-tenancy architecture\n- Performance optimization\n- Security best practices\n- Scaling strategies\n\n[Read full post →](/blog/production-saas-case-study)\n\n---\n\n### Contributing to FARM Framework: A Developer's Guide\n\n_Posted on May 24, 2025_\n\nWant to contribute to FARM Framework? This comprehensive guide will help you get started with contributing code, documentation, and community support.\n\n**What you'll learn:**\n\n- Setting up the development environment\n- Understanding the codebase structure\n- Contribution workflow and guidelines\n- Community collaboration tips\n\n[Read full post →](/blog/contributing-guide)\n\n---\n\n### FARM vs Other Full-Stack Frameworks: A Comparison\n\n_Posted on May 20, 2025_\n\nAn in-depth comparison of FARM Framework with other popular full-stack solutions like Next.js, Django, and Rails.\n\n**Frameworks compared:**\n\n- Performance benchmarks\n- Developer experience\n- Ecosystem and community\n- Use case recommendations\n\n[Read full post →](/blog/framework-comparison)\n\n## Categories\n\n- **Announcements** - Framework updates and releases\n- **Tutorials** - Step-by-step guides and how-tos\n- **Case Studies** - Real-world implementation stories\n- **Community** - Developer spotlights and contributions\n\n## Subscribe\n\nStay updated with the latest FARM Framework news and tutorials.\n\n<Callout type=\"info\">\n  Subscribe to our newsletter to get weekly updates delivered to your inbox.\n</Callout>\n",
      "excerpt": "Stay updated with the latest news, tutorials, and insights from the FARM Framework team.",
      "category": "General",
      "type": "blog",
      "tags": [
        "mongodb",
        "farm",
        "typescript",
        "authentication"
      ],
      "lastModified": "2025-06-12T21:57:32.786Z",
      "breadcrumbs": [
        "Blog"
      ],
      "headings": [
        {
          "level": 1,
          "text": "FARM Framework Blog",
          "id": "farm-framework-blog"
        },
        {
          "level": 2,
          "text": "Latest Posts",
          "id": "latest-posts"
        },
        {
          "level": 3,
          "text": "FARM Framework 2.0 Released: What's New",
          "id": "farm-framework-20-released-whats-new"
        },
        {
          "level": 3,
          "text": "Building a Production-Ready SaaS with FARM",
          "id": "building-a-production-ready-saas-with-farm"
        },
        {
          "level": 3,
          "text": "Contributing to FARM Framework: A Developer's Guide",
          "id": "contributing-to-farm-framework-a-developers-guide"
        },
        {
          "level": 3,
          "text": "FARM vs Other Full-Stack Frameworks: A Comparison",
          "id": "farm-vs-other-full-stack-frameworks-a-comparison"
        },
        {
          "level": 2,
          "text": "Categories",
          "id": "categories"
        },
        {
          "level": 2,
          "text": "Subscribe",
          "id": "subscribe"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "changelog",
      "title": "Changelog",
      "url": "/changelog",
      "content": "# Changelog\n\nAll notable changes to FARM Framework will be documented in this page.\n\n## [2.0.0] - 2025-06-01\n\n### Added\n\n- 🚀 **New Authentication System** - Built-in OAuth2, JWT, and session management\n- 📊 **Advanced MongoDB ODM** - Improved query builder and relationship handling\n- 🔧 **CLI Enhancements** - New commands for project scaffolding and migration\n- 🌐 **Real-time WebSocket Support** - Built-in WebSocket server with React hooks\n- 📱 **Mobile-First Templates** - Responsive templates optimized for mobile devices\n- 🧪 **Testing Utilities** - Comprehensive testing helpers and fixtures\n\n### Improved\n\n- ⚡ **40% faster build times** - Optimized Vite configuration and bundling\n- 🎯 **Enhanced TypeScript support** - Better type inference and autocompletion\n- 🛡️ **Security hardening** - Updated dependencies and security best practices\n- 📚 **Documentation overhaul** - Comprehensive guides and API references\n\n### Fixed\n\n- 🐛 Fixed memory leak in development server hot reload\n- 🔧 Resolved TypeScript compilation issues with strict mode\n- 📦 Fixed package resolution issues with monorepo setups\n- 🎨 Corrected CSS import order causing style conflicts\n\n### Breaking Changes\n\n- ⚠️ Updated Node.js requirement to v18+\n- ⚠️ Changed default database connection configuration\n- ⚠️ Renamed `createApp()` to `createFarmApp()` for clarity\n\n---\n\n## [1.5.2] - 2025-05-15\n\n### Fixed\n\n- 🐛 Fixed hot reload not working with MDX files\n- 🔧 Resolved CORS issues in development mode\n- 📦 Updated vulnerable dependencies\n\n### Improved\n\n- 📚 Enhanced error messages for better debugging\n- 🎯 Improved MongoDB connection handling\n\n---\n\n## [1.5.1] - 2025-05-01\n\n### Added\n\n- 🎨 New UI component library integration\n- 📊 Built-in analytics and monitoring tools\n\n### Fixed\n\n- 🐛 Fixed deployment issues with Docker containers\n- 🔧 Resolved file watching issues on Windows\n\n---\n\n## [1.5.0] - 2025-04-20\n\n### Added\n\n- 🚀 **Plugin System** - Extensible architecture for custom functionality\n- 📱 **Progressive Web App (PWA) support** - Service worker and offline capabilities\n- 🎨 **Theme system** - Built-in dark/light mode with custom theme support\n- 📈 **Performance monitoring** - Built-in performance metrics and reporting\n\n### Improved\n\n- ⚡ Faster development server startup time\n- 🎯 Better error handling and developer feedback\n- 📚 Expanded documentation with video tutorials\n\n### Fixed\n\n- 🐛 Fixed routing issues with nested dynamic routes\n- 🔧 Resolved build optimization problems\n- 📦 Fixed package installation issues on Apple Silicon\n\n---\n\n## [1.4.0] - 2025-03-15\n\n### Added\n\n- 🔐 **Enhanced Security Features** - CSRF protection, XSS prevention\n- 📊 **Database Migrations** - Automated schema versioning\n- 🌍 **Internationalization (i18n)** - Multi-language support\n\n### Improved\n\n- 🎯 Better TypeScript integration\n- 📱 Improved mobile responsiveness\n- ⚡ Optimized bundle sizes\n\n## Migration Guides\n\n- [Migrating from v1.x to v2.0](/docs/migration/v2-migration-guide)\n- [Migrating from v1.4 to v1.5](/docs/migration/v1-5-migration-guide)\n\n<Callout type=\"info\">\n  For detailed migration instructions and breaking change information, please\n  refer to our [migration guides](/docs/migration).\n</Callout>\n",
      "excerpt": "All notable changes to FARM Framework will be documented in this page.",
      "category": "General",
      "type": "changelog",
      "tags": [
        "react",
        "mongodb",
        "farm",
        "typescript",
        "authentication"
      ],
      "lastModified": "2025-06-12T21:57:32.787Z",
      "breadcrumbs": [
        "Changelog"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Changelog",
          "id": "changelog"
        },
        {
          "level": 2,
          "text": "[2.0.0] - 2025-06-01",
          "id": "200---2025-06-01"
        },
        {
          "level": 3,
          "text": "Added",
          "id": "added"
        },
        {
          "level": 3,
          "text": "Improved",
          "id": "improved"
        },
        {
          "level": 3,
          "text": "Fixed",
          "id": "fixed"
        },
        {
          "level": 3,
          "text": "Breaking Changes",
          "id": "breaking-changes"
        },
        {
          "level": 2,
          "text": "[1.5.2] - 2025-05-15",
          "id": "152---2025-05-15"
        },
        {
          "level": 3,
          "text": "Fixed",
          "id": "fixed"
        },
        {
          "level": 3,
          "text": "Improved",
          "id": "improved"
        },
        {
          "level": 2,
          "text": "[1.5.1] - 2025-05-01",
          "id": "151---2025-05-01"
        },
        {
          "level": 3,
          "text": "Added",
          "id": "added"
        },
        {
          "level": 3,
          "text": "Fixed",
          "id": "fixed"
        },
        {
          "level": 2,
          "text": "[1.5.0] - 2025-04-20",
          "id": "150---2025-04-20"
        },
        {
          "level": 3,
          "text": "Added",
          "id": "added"
        },
        {
          "level": 3,
          "text": "Improved",
          "id": "improved"
        },
        {
          "level": 3,
          "text": "Fixed",
          "id": "fixed"
        },
        {
          "level": 2,
          "text": "[1.4.0] - 2025-03-15",
          "id": "140---2025-03-15"
        },
        {
          "level": 3,
          "text": "Added",
          "id": "added"
        },
        {
          "level": 3,
          "text": "Improved",
          "id": "improved"
        },
        {
          "level": 2,
          "text": "Migration Guides",
          "id": "migration-guides"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "community",
      "title": "Community",
      "url": "/community",
      "content": "# Community\n\nJoin our thriving community of FARM Framework developers worldwide.\n\n## Get Involved\n\n### Discord Community\n\nJoin over 2,500 developers in our Discord server for real-time discussions, help, and collaboration.\n\n**Discord Server:** [Join the FARM Discord](https://discord.gg/JmeShQtv)  \n**Active Channels:**\n\n- #general - General discussions\n- #help - Get help with your projects\n- #showcase - Share your creations\n- #announcements - Latest updates\n\n### GitHub Community\n\nContribute to FARM Framework development and stay updated with the latest changes.\n\n**GitHub Repository:** [farm-framework/farm](https://github.com/cstannahill/farm-framework)  \n**Ways to contribute:**\n\n- Report bugs and issues\n- Submit feature requests\n- Contribute code improvements\n- Help with documentation\n\n### Community Events\n\n#### Monthly Meetups\n\nVirtual meetups held every first Friday of the month at 7 PM EST.\n\n- **Next Meetup:** July 4, 2025\n- **Topic:** Building Real-time Applications with FARM\n- **Speaker:** Sarah Chen, Senior Developer at TechCorp\n\n#### Annual Conference\n\n**FARM Summit 2025** - Join us for our annual conference!\n\n- **Date:** September 15-17, 2025\n- **Location:** San Francisco, CA + Virtual\n- **Speakers:** Core team members and industry experts\n- **Sessions:** Workshops, talks, and networking\n\n## Community Guidelines\n\nWe strive to maintain a welcoming and inclusive environment for all community members.\n\n### Our Values\n\n- **Respect** - Treat everyone with kindness and respect\n- **Collaboration** - Help each other grow and learn\n- **Innovation** - Share ideas and push boundaries together\n- **Inclusivity** - Welcome developers of all backgrounds and skill levels\n\n### Code of Conduct\n\nAll community members are expected to follow our [Code of Conduct](https://github.com/cstannahill/farm-framework/farm/blob/main/CODE_OF_CONDUCT.md).\n\n<Callout type=\"success\">\n  Ready to connect? Join our Discord server and introduce yourself in the\n  #general channel!\n</Callout>\n",
      "excerpt": "Join our thriving community of FARM Framework developers worldwide.",
      "category": "General",
      "type": "reference",
      "tags": [
        "farm"
      ],
      "lastModified": "2025-06-12T21:57:32.787Z",
      "breadcrumbs": [
        "Community"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Community",
          "id": "community"
        },
        {
          "level": 2,
          "text": "Get Involved",
          "id": "get-involved"
        },
        {
          "level": 3,
          "text": "Discord Community",
          "id": "discord-community"
        },
        {
          "level": 3,
          "text": "GitHub Community",
          "id": "github-community"
        },
        {
          "level": 3,
          "text": "Community Events",
          "id": "community-events"
        },
        {
          "level": 4,
          "text": "Monthly Meetups",
          "id": "monthly-meetups"
        },
        {
          "level": 4,
          "text": "Annual Conference",
          "id": "annual-conference"
        },
        {
          "level": 2,
          "text": "Community Guidelines",
          "id": "community-guidelines"
        },
        {
          "level": 3,
          "text": "Our Values",
          "id": "our-values"
        },
        {
          "level": 3,
          "text": "Code of Conduct",
          "id": "code-of-conduct"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-advanced-architecture",
      "title": "Architecture",
      "url": "/docs/advanced/architecture",
      "content": "# Advanced Architecture\n\n<Callout type=\"warning\" title=\"Advanced Topic\">\n  This section covers advanced architectural patterns for large-scale FARM applications. Most developers can skip this unless building enterprise-scale systems.\n</Callout>\n\n## Enterprise Scaling Patterns\n\n### Microservices Architecture\n\nAs your FARM application grows, you can decompose it into microservices using the plugin architecture:\n\n<CodeTabs examples={[\n  {\n    language: \"plaintext\",\n    label: \"Microservices Structure\",\n    code: `farm-enterprise/\n├── services/\n│   ├── user-service/           # User management microservice\n│   │   ├── apps/api/\n│   │   └── farm.config.ts\n│   ├── ai-service/             # AI/ML inference microservice\n│   │   ├── apps/api/\n│   │   └── farm.config.ts\n│   ├── content-service/        # Content management microservice\n│   │   ├── apps/api/\n│   │   └── farm.config.ts\n│   └── notification-service/   # Notification microservice\n│       ├── apps/api/\n│       └── farm.config.ts\n├── gateways/\n│   ├── api-gateway/           # Main API gateway\n│   └── admin-gateway/         # Admin-specific gateway\n├── shared/\n│   ├── types/                 # Shared type definitions\n│   ├── events/                # Event schemas\n│   └── auth/                  # Shared authentication\n└── frontend/\n    ├── user-app/              # User-facing application\n    ├── admin-app/             # Admin dashboard\n    └── mobile-app/            # Mobile application`\n  }\n]} />\n\n### Service Communication Patterns\n\n<FeatureList features={[\n  {\n    title: \"Event-Driven Architecture\",\n    description: \"Services communicate via events using Redis Streams or Apache Kafka\",\n    icon: \"📡\"\n  },\n  {\n    title: \"API Gateway Pattern\",\n    description: \"Central gateway for routing, authentication, and rate limiting\",\n    icon: \"🚪\"\n  },\n  {\n    title: \"Service Mesh\",\n    description: \"Istio integration for service-to-service communication\",\n    icon: \"🕸️\"\n  },\n  {\n    title: \"Circuit Breaker\",\n    description: \"Resilience patterns for handling service failures\",\n    icon: \"🔌\"\n  }\n]} />\n\n### Event-Driven Communication\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"Event Publisher\",\n    code: `# Service A publishes events\nfrom farm.events import EventPublisher\n\nclass UserService:\n    def __init__(self):\n        self.events = EventPublisher(\"user-service\")\n    \n    async def create_user(self, user_data: dict):\n        user = await self.db.users.create(user_data)\n        \n        # Publish user created event\n        await self.events.publish(\"user.created\", {\n            \"user_id\": user.id,\n            \"email\": user.email,\n            \"created_at\": user.created_at.isoformat()\n        })\n        \n        return user`\n  },\n  {\n    language: \"python\",\n    label: \"Event Consumer\",\n    code: `# Service B consumes events\nfrom farm.events import EventConsumer\n\nclass NotificationService:\n    def __init__(self):\n        self.events = EventConsumer(\"notification-service\")\n        \n    async def setup_listeners(self):\n        # Listen for user events\n        await self.events.subscribe(\"user.created\", self.handle_user_created)\n        await self.events.subscribe(\"user.updated\", self.handle_user_updated)\n    \n    async def handle_user_created(self, event_data: dict):\n        # Send welcome email\n        await self.send_welcome_email(\n            email=event_data[\"email\"],\n            user_id=event_data[\"user_id\"]\n        )`\n  }\n]} />\n\n## High-Availability Patterns\n\n### Database Clustering\n\n<CodeTabs examples={[\n  {\n    language: \"yaml\",\n    label: \"MongoDB Replica Set\",\n    code: `# MongoDB replica set configuration\nversion: '3.8'\nservices:\n  mongo-primary:\n    image: mongo:7\n    command: mongod --replSet rs0 --bind_ip_all\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: admin\n      MONGO_INITDB_ROOT_PASSWORD: password\n    ports:\n      - \"27017:27017\"\n    volumes:\n      - mongo-primary:/data/db\n\n  mongo-secondary1:\n    image: mongo:7  \n    command: mongod --replSet rs0 --bind_ip_all\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: admin\n      MONGO_INITDB_ROOT_PASSWORD: password\n    ports:\n      - \"27018:27017\"\n    volumes:\n      - mongo-secondary1:/data/db\n\n  mongo-secondary2:\n    image: mongo:7\n    command: mongod --replSet rs0 --bind_ip_all\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: admin \n      MONGO_INITDB_ROOT_PASSWORD: password\n    ports:\n      - \"27019:27017\"\n    volumes:\n      - mongo-secondary2:/data/db\n\nvolumes:\n  mongo-primary:\n  mongo-secondary1:\n  mongo-secondary2:`\n  },\n  {\n    language: \"python\",\n    label: \"Connection Configuration\",\n    code: `# High-availability database connection\nfrom motor.motor_asyncio import AsyncIOMotorClient\n\nDATABASE_CONFIG = {\n    \"connection_string\": (\n        \"mongodb://admin:password@\"\n        \"mongo-primary:27017,\"\n        \"mongo-secondary1:27017,\"\n        \"mongo-secondary2:27017/\"\n        \"farmapp?replicaSet=rs0&\"\n        \"readPreference=primaryPreferred&\"\n        \"retryWrites=true&\"\n        \"w=majority\"\n    ),\n    \"options\": {\n        \"maxPoolSize\": 50,\n        \"minPoolSize\": 5,\n        \"maxIdleTimeMS\": 30000,\n        \"waitQueueTimeoutMS\": 5000,\n        \"serverSelectionTimeoutMS\": 5000\n    }\n}`\n  }\n]} />\n\n### Load Balancing & Auto-Scaling\n\n<CodeTabs examples={[\n  {\n    language: \"yaml\",\n    label: \"Kubernetes Deployment\",\n    code: `# Kubernetes deployment with auto-scaling\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: farm-api\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: farm-api\n  template:\n    metadata:\n      labels:\n        app: farm-api\n    spec:\n      containers:\n      - name: api\n        image: farm-app:latest\n        ports:\n        - containerPort: 8000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: db-secret\n              key: url\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"200m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: farm-api-service\nspec:\n  selector:\n    app: farm-api\n  ports:\n  - port: 80\n    targetPort: 8000\n  type: LoadBalancer\n\n---\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: farm-api-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: farm-api\n  minReplicas: 3\n  maxReplicas: 20\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80`\n  }\n]} />\n\n## Caching Strategies\n\n### Multi-Layer Caching\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"Caching Middleware\",\n    code: `# Multi-layer caching implementation\nfrom farm.cache import CacheManager, RedisCache, MemoryCache\n\nclass FarmCacheManager:\n    def __init__(self):\n        # L1: In-memory cache (fastest)\n        self.l1_cache = MemoryCache(max_size=1000, ttl=60)\n        \n        # L2: Redis cache (shared across instances)\n        self.l2_cache = RedisCache(url=\"redis://localhost:6379\")\n        \n        # L3: Database (slowest)\n        self.db = get_database()\n    \n    async def get(self, key: str, factory=None):\n        # Try L1 cache first\n        value = await self.l1_cache.get(key)\n        if value is not None:\n            return value\n            \n        # Try L2 cache\n        value = await self.l2_cache.get(key)\n        if value is not None:\n            # Populate L1 cache\n            await self.l1_cache.set(key, value)\n            return value\n            \n        # Generate value if factory provided\n        if factory:\n            value = await factory()\n            # Populate both caches\n            await self.l1_cache.set(key, value)\n            await self.l2_cache.set(key, value, ttl=3600)\n            return value\n            \n        return None\n\n# Usage in API endpoints\n@cache_manager.cached(ttl=300, key_prefix=\"user\")\nasync def get_user(user_id: str):\n    return await db.users.find_one({\"_id\": user_id})`\n  }\n]} />\n\n### Cache Invalidation Patterns\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"Smart Cache Invalidation\",\n    code: `# Event-driven cache invalidation\nfrom farm.events import EventSubscriber\n\nclass CacheInvalidator(EventSubscriber):\n    def __init__(self, cache_manager: CacheManager):\n        self.cache = cache_manager\n        \n    async def setup(self):\n        # Listen for data change events\n        await self.subscribe(\"user.updated\", self.invalidate_user_cache)\n        await self.subscribe(\"post.created\", self.invalidate_post_cache)\n        \n    async def invalidate_user_cache(self, event_data):\n        user_id = event_data[\"user_id\"]\n        \n        # Invalidate specific user caches\n        await self.cache.delete(f\"user:{user_id}\")\n        await self.cache.delete(f\"user:profile:{user_id}\")\n        \n        # Invalidate related caches\n        await self.cache.delete_pattern(f\"user:{user_id}:*\")\n        await self.cache.delete_pattern(f\"feed:*\")  # User might appear in feeds\n        \n    async def invalidate_post_cache(self, event_data):\n        post_id = event_data[\"post_id\"] \n        author_id = event_data[\"author_id\"]\n        \n        # Invalidate post and author caches\n        await self.cache.delete(f\"post:{post_id}\")\n        await self.cache.delete_pattern(f\"posts:author:{author_id}\")\n        await self.cache.delete_pattern(f\"feed:*\")`\n  }\n]} />\n\n## Advanced AI/ML Patterns\n\n### Model Serving Architecture\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"Model Router\",\n    code: `# Advanced model routing and load balancing\nfrom farm.ai import ModelRouter, ModelInstance\n\nclass AdvancedModelRouter:\n    def __init__(self):\n        self.instances = {\n            \"gpu-1\": ModelInstance(\"gpu\", models=[\"llama3.1\", \"codestral\"]),\n            \"gpu-2\": ModelInstance(\"gpu\", models=[\"gpt-4\", \"claude-3\"]),\n            \"cpu-1\": ModelInstance(\"cpu\", models=[\"phi3\"]),\n        }\n        self.load_balancer = RoundRobinBalancer()\n        \n    async def route_request(self, model: str, request: dict):\n        # Find available instances for model\n        available_instances = [\n            instance for instance in self.instances.values()\n            if model in instance.models and instance.is_available()\n        ]\n        \n        if not available_instances:\n            # Fall back to CPU or queue request\n            return await self.fallback_strategy(model, request)\n            \n        # Select best instance based on load\n        instance = self.load_balancer.select(available_instances)\n        \n        # Route request with timeout and retry\n        try:\n            return await instance.inference(model, request, timeout=30)\n        except TimeoutError:\n            # Retry with different instance\n            return await self.retry_with_fallback(model, request, exclude=[instance])\n            \n    async def fallback_strategy(self, model: str, request: dict):\n        # Try similar models or queue for later\n        similar_models = self.find_similar_models(model)\n        for fallback_model in similar_models:\n            try:\n                return await self.route_request(fallback_model, request)\n            except Exception:\n                continue\n                \n        # Queue for when instances become available\n        await self.queue_request(model, request)\n        raise ServiceUnavailableError(f\"Model {model} temporarily unavailable\")`\n  }\n]} />\n\n### A/B Testing for AI Models\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"Model A/B Testing\",\n    code: `# A/B testing framework for AI models\nfrom farm.ai import ABTestManager\nfrom farm.analytics import track_event\n\nclass ModelABTester:\n    def __init__(self):\n        self.ab_manager = ABTestManager()\n        \n    async def get_model_for_user(self, user_id: str, feature: str):\n        # Define test configuration\n        test_config = {\n            \"test_name\": f\"{feature}_model_comparison\",\n            \"variants\": {\n                \"control\": {\"model\": \"gpt-3.5-turbo\", \"weight\": 50},\n                \"variant_a\": {\"model\": \"gpt-4\", \"weight\": 25}, \n                \"variant_b\": {\"model\": \"claude-3\", \"weight\": 25}\n            },\n            \"success_metrics\": [\"response_quality\", \"response_time\", \"user_satisfaction\"]\n        }\n        \n        # Get variant for user\n        variant = await self.ab_manager.get_variant(user_id, test_config)\n        \n        # Track assignment\n        await track_event(\"model_assigned\", {\n            \"user_id\": user_id,\n            \"feature\": feature,\n            \"variant\": variant[\"name\"],\n            \"model\": variant[\"model\"]\n        })\n        \n        return variant[\"model\"]\n        \n    async def track_model_performance(self, user_id: str, variant: str, metrics: dict):\n        # Track performance metrics\n        await track_event(\"model_performance\", {\n            \"user_id\": user_id,\n            \"variant\": variant,\n            \"response_time\": metrics[\"response_time\"],\n            \"response_quality\": metrics[\"quality_score\"],\n            \"user_rating\": metrics.get(\"user_rating\")\n        })\n        \n        # Update A/B test results\n        await self.ab_manager.record_conversion(user_id, variant, metrics)`\n  }\n]} />\n\n## Data Pipeline Architecture\n\n### Real-time Data Processing\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"Streaming Pipeline\",\n    code: `# Real-time data processing pipeline\nfrom farm.streaming import StreamProcessor, Pipeline\nfrom farm.ai import TextEmbedding, VectorStore\n\nclass ContentPipeline(Pipeline):\n    def __init__(self):\n        self.embedding_model = TextEmbedding(\"text-embedding-3-small\")\n        self.vector_store = VectorStore(\"pinecone\")\n        \n    async def process_user_content(self, content_event):\n        \"\"\"Process user-generated content in real-time\"\"\"\n        content = content_event[\"content\"]\n        user_id = content_event[\"user_id\"]\n        \n        # 1. Content moderation\n        moderation_result = await self.moderate_content(content)\n        if not moderation_result[\"approved\"]:\n            await self.handle_moderation_failure(content_event, moderation_result)\n            return\n            \n        # 2. Generate embeddings\n        embedding = await self.embedding_model.embed(content)\n        \n        # 3. Store in vector database for similarity search\n        await self.vector_store.upsert({\n            \"id\": content_event[\"content_id\"],\n            \"embedding\": embedding,\n            \"metadata\": {\n                \"user_id\": user_id,\n                \"created_at\": content_event[\"timestamp\"],\n                \"content_type\": content_event[\"type\"]\n            }\n        })\n        \n        # 4. Update user profile\n        await self.update_user_interests(user_id, content, embedding)\n        \n        # 5. Trigger recommendation refresh\n        await self.refresh_recommendations(user_id)\n        \n    async def moderate_content(self, content: str):\n        \"\"\"AI-powered content moderation\"\"\"\n        result = await self.ai_provider.moderate(\n            content=content,\n            categories=[\"hate\", \"violence\", \"spam\", \"adult\"]\n        )\n        return {\n            \"approved\": result[\"flagged\"] == False,\n            \"categories\": result.get(\"categories\", []),\n            \"confidence\": result.get(\"confidence\", 0)\n        }`\n  }\n]} />\n\n## Observability & Monitoring\n\n### Distributed Tracing\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"OpenTelemetry Integration\",\n    code: `# Distributed tracing with OpenTelemetry\nfrom opentelemetry import trace\nfrom opentelemetry.exporter.jaeger.thrift import JaegerExporter\nfrom farm.observability import setup_tracing\n\n# Setup tracing\ntracer = trace.get_tracer(__name__)\n\nclass UserService:\n    @tracer.start_as_current_span(\"create_user\")\n    async def create_user(self, user_data: dict):\n        span = trace.get_current_span()\n        span.set_attribute(\"user.email\", user_data[\"email\"])\n        \n        # Database operation\n        with tracer.start_as_current_span(\"db.insert_user\") as db_span:\n            db_span.set_attribute(\"db.operation\", \"insert\")\n            db_span.set_attribute(\"db.collection\", \"users\")\n            \n            user = await self.db.users.create(user_data)\n            db_span.set_attribute(\"db.result.id\", str(user.id))\n            \n        # AI operation for content analysis\n        with tracer.start_as_current_span(\"ai.analyze_profile\") as ai_span:\n            ai_span.set_attribute(\"ai.model\", \"gpt-3.5-turbo\")\n            ai_span.set_attribute(\"ai.operation\", \"profile_analysis\")\n            \n            profile_analysis = await self.ai_service.analyze_profile(user_data)\n            ai_span.set_attribute(\"ai.result.sentiment\", profile_analysis[\"sentiment\"])\n            \n        # Event publishing\n        with tracer.start_as_current_span(\"events.publish\") as event_span:\n            event_span.set_attribute(\"event.type\", \"user.created\")\n            event_span.set_attribute(\"event.user_id\", str(user.id))\n            \n            await self.events.publish(\"user.created\", {\"user_id\": str(user.id)})\n            \n        span.set_attribute(\"operation.result\", \"success\")\n        span.set_status(trace.Status(trace.StatusCode.OK))\n        \n        return user`\n  }\n]} />\n\n### Custom Metrics & Alerting\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"Prometheus Metrics\",\n    code: `# Custom metrics collection\nfrom prometheus_client import Counter, Histogram, Gauge\nfrom farm.monitoring import MetricsCollector\n\nclass FarmMetrics:\n    def __init__(self):\n        # Request metrics\n        self.request_count = Counter(\n            'farm_requests_total',\n            'Total requests',\n            ['method', 'endpoint', 'status']\n        )\n        \n        self.request_duration = Histogram(\n            'farm_request_duration_seconds',\n            'Request duration',\n            ['method', 'endpoint']\n        )\n        \n        # AI metrics\n        self.ai_requests = Counter(\n            'farm_ai_requests_total',\n            'AI requests',\n            ['provider', 'model', 'operation']\n        )\n        \n        self.ai_response_time = Histogram(\n            'farm_ai_response_time_seconds',\n            'AI response time',\n            ['provider', 'model']\n        )\n        \n        # Database metrics\n        self.db_connections = Gauge(\n            'farm_db_connections_active',\n            'Active database connections'\n        )\n        \n        self.db_query_duration = Histogram(\n            'farm_db_query_duration_seconds',\n            'Database query duration',\n            ['operation', 'collection']\n        )\n        \n    async def record_request(self, method: str, endpoint: str, status: int, duration: float):\n        self.request_count.labels(method=method, endpoint=endpoint, status=status).inc()\n        self.request_duration.labels(method=method, endpoint=endpoint).observe(duration)\n        \n    async def record_ai_request(self, provider: str, model: str, operation: str, duration: float):\n        self.ai_requests.labels(provider=provider, model=model, operation=operation).inc()\n        self.ai_response_time.labels(provider=provider, model=model).observe(duration)`\n  }\n]} />\n\n---\n\n<Warning>\nThese advanced patterns should only be implemented when you have specific scalability requirements. Start with the basic FARM architecture and evolve as needed.\n</Warning>",
      "excerpt": "<Callout type=\"warning\" title=\"Advanced Topic\">\n  This section covers advanced architectural patterns for large-scale FARM applications.",
      "category": "docs/advanced",
      "type": "reference",
      "tags": [
        "mongodb",
        "farm",
        "python",
        "authentication",
        "database"
      ],
      "lastModified": "2025-06-12T21:57:32.787Z",
      "breadcrumbs": [
        "Docs",
        "Advanced",
        "Architecture"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Advanced Architecture",
          "id": "advanced-architecture"
        },
        {
          "level": 2,
          "text": "Enterprise Scaling Patterns",
          "id": "enterprise-scaling-patterns"
        },
        {
          "level": 3,
          "text": "Microservices Architecture",
          "id": "microservices-architecture"
        },
        {
          "level": 3,
          "text": "Service Communication Patterns",
          "id": "service-communication-patterns"
        },
        {
          "level": 3,
          "text": "Event-Driven Communication",
          "id": "event-driven-communication"
        },
        {
          "level": 2,
          "text": "High-Availability Patterns",
          "id": "high-availability-patterns"
        },
        {
          "level": 3,
          "text": "Database Clustering",
          "id": "database-clustering"
        },
        {
          "level": 3,
          "text": "Load Balancing & Auto-Scaling",
          "id": "load-balancing-auto-scaling"
        },
        {
          "level": 2,
          "text": "Caching Strategies",
          "id": "caching-strategies"
        },
        {
          "level": 3,
          "text": "Multi-Layer Caching",
          "id": "multi-layer-caching"
        },
        {
          "level": 1,
          "text": "Usage in API endpoints",
          "id": "usage-in-api-endpoints"
        },
        {
          "level": 3,
          "text": "Cache Invalidation Patterns",
          "id": "cache-invalidation-patterns"
        },
        {
          "level": 2,
          "text": "Advanced AI/ML Patterns",
          "id": "advanced-aiml-patterns"
        },
        {
          "level": 3,
          "text": "Model Serving Architecture",
          "id": "model-serving-architecture"
        },
        {
          "level": 3,
          "text": "A/B Testing for AI Models",
          "id": "ab-testing-for-ai-models"
        },
        {
          "level": 2,
          "text": "Data Pipeline Architecture",
          "id": "data-pipeline-architecture"
        },
        {
          "level": 3,
          "text": "Real-time Data Processing",
          "id": "real-time-data-processing"
        },
        {
          "level": 2,
          "text": "Observability & Monitoring",
          "id": "observability-monitoring"
        },
        {
          "level": 3,
          "text": "Distributed Tracing",
          "id": "distributed-tracing"
        },
        {
          "level": 1,
          "text": "Setup tracing",
          "id": "setup-tracing"
        },
        {
          "level": 3,
          "text": "Custom Metrics & Alerting",
          "id": "custom-metrics-alerting"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-advanced-documentation-system",
      "title": "Documentation System",
      "url": "/docs/advanced/documentation-system",
      "content": "# Documentation System\r\n\r\nDocumentation is auto-generated from code and enriched with interactive examples. A live playground and community contributed guides ensure developers can quickly find what they need.\r\n",
      "excerpt": "Documentation is auto-generated from code and enriched with interactive examples.",
      "category": "docs/advanced",
      "type": "reference",
      "tags": [],
      "lastModified": "2025-06-12T21:57:32.787Z",
      "breadcrumbs": [
        "Docs",
        "Advanced",
        "Documentation System"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Documentation System",
          "id": "documentation-system"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-advanced-index",
      "title": "Index",
      "url": "/docs/advanced",
      "content": "# Advanced Topics\r\n\r\nDeep-dive guides on performance, security, testing, and other advanced aspects of FARM.\r\n",
      "excerpt": "Deep-dive guides on performance, security, testing, and other advanced aspects of FARM. .",
      "category": "docs/advanced",
      "type": "reference",
      "tags": [
        "farm"
      ],
      "lastModified": "2025-06-12T21:57:32.788Z",
      "breadcrumbs": [
        "Docs",
        "Advanced",
        "Index"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Advanced Topics",
          "id": "advanced-topics"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-advanced-performance",
      "title": "Performance",
      "url": "/docs/advanced/performance",
      "content": "# Performance & Monitoring\r\n\r\nInstrumentation tracks development workflows, GPU usage and production metrics. pnpm package management and intelligent caching keep build and reload times fast.\r\n",
      "excerpt": "Instrumentation tracks development workflows, GPU usage and production metrics. pnpm package management and intelligent caching keep build and reload times fast.",
      "category": "docs/advanced",
      "type": "reference",
      "tags": [],
      "lastModified": "2025-06-12T21:57:32.788Z",
      "breadcrumbs": [
        "Docs",
        "Advanced",
        "Performance"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Performance & Monitoring",
          "id": "performance-monitoring"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-advanced-security",
      "title": "Security",
      "url": "/docs/advanced/security",
      "content": "# Security Architecture\r\n\r\nDefense in depth covers AI provider security, secure code generation and cross-stack practices. Threat detection and secret management are built into the framework.\r\n",
      "excerpt": "Defense in depth covers AI provider security, secure code generation and cross-stack practices.",
      "category": "docs/advanced",
      "type": "reference",
      "tags": [],
      "lastModified": "2025-06-12T21:57:32.788Z",
      "breadcrumbs": [
        "Docs",
        "Advanced",
        "Security"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Security Architecture",
          "id": "security-architecture"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-advanced-testing",
      "title": "Testing",
      "url": "/docs/advanced/testing",
      "content": "# Testing Strategy\r\n\r\nTests span framework internals, generated application code and AI provider behaviors. Unit, API and end-to-end suites are orchestrated alongside an AI model mock manager and coverage analyzer.\r\n",
      "excerpt": "Tests span framework internals, generated application code and AI provider behaviors.",
      "category": "docs/advanced",
      "type": "reference",
      "tags": [
        "api"
      ],
      "lastModified": "2025-06-12T21:57:32.788Z",
      "breadcrumbs": [
        "Docs",
        "Advanced",
        "Testing"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Testing Strategy",
          "id": "testing-strategy"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-api-cli",
      "title": "Cli",
      "url": "/docs/api/cli",
      "content": "# CLI Reference\r\n\r\nThe FARM CLI provides a unified command interface for project creation, development, and deployment. Inspired by Next.js, it supports both quick interactive prompts and detailed non-interactive commands.\r\n\r\n<Callout type=\"info\" title=\"Philosophy\">\r\n  Respect both \"quick start\" developers and \"I know exactly what I want\"\r\n  developers with intelligent prompting and comprehensive arguments.\r\n</Callout>\r\n\r\n## Project Creation\r\n\r\n### `farm create`\r\n\r\nCreate a new FARM project with optional template and features.\r\n\r\n<ApiMethod method=\"CLI\" endpoint=\"farm create <project-name> [options]\" />\r\n\r\n#### Templates\r\n\r\nChoose from pre-built project templates:\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Basic Templates\",\r\n    code: `# Simple React + FastAPI + MongoDB\r\nfarm create my-app --template basic\r\n\r\n# Chat app with streaming AI responses\r\n\r\nfarm create my-app --template ai-chat\r\n\r\n# Data dashboard with ML insights\r\n\r\nfarm create my-app --template ai-dashboard`  },\r\n  {\r\n    language: \"bash\", \r\n    label: \"Specialized Templates\",\r\n    code:`# E-commerce platform with payments\r\nfarm create my-app --template ecommerce\r\n\r\n# Content management system\r\n\r\nfarm create my-app --template cms\r\n\r\n# FastAPI backend only (no React)\r\n\r\nfarm create my-app --template api-only\r\n\r\n# Custom template from URL/path\r\n\r\nfarm create my-app --template custom --url https://github.com/user/template`\r\n}\r\n]} />\r\n\r\n#### Features\r\n\r\nEnable optional features with the `--features` flag:\r\n\r\n<FeatureList\r\n  features={[\r\n    {\r\n      name: \"auth\",\r\n      description: \"JWT authentication + user management\",\r\n      icon: \"🔐\",\r\n    },\r\n    {\r\n      name: \"ai\",\r\n      description: \"AI/ML model serving + inference endpoints\",\r\n      icon: \"🤖\",\r\n    },\r\n    {\r\n      name: \"realtime\",\r\n      description: \"WebSocket support + real-time features\",\r\n      icon: \"⚡\",\r\n    },\r\n    {\r\n      name: \"payments\",\r\n      description: \"Stripe/PayPal integration\",\r\n      icon: \"💳\",\r\n    },\r\n    {\r\n      name: \"email\",\r\n      description: \"Email service integration\",\r\n      icon: \"📧\",\r\n    },\r\n    {\r\n      name: \"storage\",\r\n      description: \"File upload + cloud storage\",\r\n      icon: \"📁\",\r\n    },\r\n    {\r\n      name: \"search\",\r\n      description: \"Full-text search with MongoDB/Elasticsearch\",\r\n      icon: \"🔍\",\r\n    },\r\n    {\r\n      name: \"analytics\",\r\n      description: \"User analytics and tracking\",\r\n      icon: \"📊\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n<CodeTabs\r\n  examples={[\r\n    {\r\n      language: \"bash\",\r\n      label: \"Single Feature\",\r\n      code: `farm create my-app --features auth`,\r\n    },\r\n    {\r\n      language: \"bash\",\r\n      label: \"Multiple Features\",\r\n      code: `farm create my-app --features auth,ai,realtime`,\r\n    },\r\n    {\r\n      language: \"bash\",\r\n      label: \"No Features\",\r\n      code: `farm create my-app --no-features`,\r\n    },\r\n  ]}\r\n/>\r\n\r\n#### Database Options\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Document Databases\",\r\n    code: `# MongoDB (default)\r\nfarm create my-app --database mongodb`\r\n  },\r\n  {\r\n    language: \"bash\",\r\n    label: \"Relational Databases\", \r\n    code: `# PostgreSQL with SQLAlchemy\r\nfarm create my-app --database postgresql\r\n\r\n# MySQL with SQLAlchemy\r\n\r\nfarm create my-app --database mysql\r\n\r\n# SQLite for development\r\n\r\nfarm create my-app --database sqlite`\r\n}\r\n]} />\r\n\r\n#### Development Options\r\n\r\n<PropertyTable\r\n  properties={[\r\n    {\r\n      name: \"--typescript\",\r\n      type: \"boolean\",\r\n      default: \"true\",\r\n      description: \"Enable TypeScript (default: true)\",\r\n    },\r\n    {\r\n      name: \"--docker\",\r\n      type: \"boolean\",\r\n      default: \"true\",\r\n      description: \"Include Docker setup\",\r\n    },\r\n    {\r\n      name: \"--testing\",\r\n      type: \"boolean\",\r\n      default: \"true\",\r\n      description: \"Include test setup\",\r\n    },\r\n    {\r\n      name: \"--git\",\r\n      type: \"boolean\",\r\n      default: \"true\",\r\n      description: \"Initialize git repository\",\r\n    },\r\n    {\r\n      name: \"--install\",\r\n      type: \"boolean\",\r\n      default: \"true\",\r\n      description: \"Install dependencies after creation\",\r\n    },\r\n    {\r\n      name: \"--interactive\",\r\n      type: \"boolean\",\r\n      default: \"auto\",\r\n      description: \"Force interactive mode\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n## Development Commands\r\n\r\n### `farm dev`\r\n\r\nStart the development server with hot reload.\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Full Stack\",\r\n    code: `# Start both frontend and backend\r\nfarm dev\r\n\r\n# Start with specific port\r\n\r\nfarm dev --port 3000`  },\r\n  {\r\n    language: \"bash\",\r\n    label: \"Individual Services\",\r\n    code:`# Frontend only\r\nfarm dev --frontend-only\r\n\r\n# Backend only\r\n\r\nfarm dev --backend-only`\r\n}\r\n]} />\r\n\r\n### `farm generate`\r\n\r\nGenerate code components and boilerplate.\r\n\r\n<ApiMethod method=\"CLI\" endpoint=\"farm generate <type> <name> [options]\" />\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Models & APIs\",\r\n    code: `# Generate model + API + frontend types\r\nfarm generate model User\r\n\r\n# Generate authentication endpoints\r\n\r\nfarm generate api auth\r\n\r\n# Generate CRUD API for existing model\r\n\r\nfarm generate crud User`  },\r\n  {\r\n    language: \"bash\",\r\n    label: \"Frontend Components\",\r\n    code:`# Generate CRUD page with components\r\nfarm generate page users\r\n\r\n# Generate React component\r\n\r\nfarm generate component UserCard\r\n\r\n# Generate custom hook\r\n\r\nfarm generate hook useAuth`\r\n}\r\n]} />\r\n\r\n## Database Commands\r\n\r\n### `farm db`\r\n\r\nDatabase management and migrations.\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Migrations\",\r\n    code: `# Run database migrations\r\nfarm db migrate\r\n\r\n# Create new migration\r\n\r\nfarm db migrate create add_user_table\r\n\r\n# Rollback migration\r\n\r\nfarm db migrate rollback`  },\r\n  {\r\n    language: \"bash\", \r\n    label: \"Data Management\",\r\n    code:`# Seed database with sample data\r\nfarm db seed\r\n\r\n# Open database GUI\r\n\r\nfarm db studio\r\n\r\n# Reset database\r\n\r\nfarm db reset`\r\n}\r\n]} />\r\n\r\n## AI/ML Commands\r\n\r\n### `farm ml`\r\n\r\nAI model and provider management.\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Model Management\",\r\n    code: `# List available models\r\nfarm ml models list\r\n\r\n# List Ollama models specifically\r\n\r\nfarm ml models list --provider ollama\r\n\r\n# Download Ollama model\r\n\r\nfarm ml models pull llama3.2\r\n\r\n# Remove local model\r\n\r\nfarm ml models remove llama3.2`  },\r\n  {\r\n    language: \"bash\",\r\n    label: \"Interaction & Testing\", \r\n    code:`# Interactive chat session\r\nfarm ml chat\r\n\r\n# Chat with specific model\r\n\r\nfarm ml chat --model llama3.2 --provider ollama\r\n\r\n# Performance testing\r\n\r\nfarm ml benchmark llama3.2`\r\n}\r\n]} />\r\n\r\n## Build & Deployment\r\n\r\n### `farm build`\r\n\r\nBuild the project for production.\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Production Build\",\r\n    code: `# Build for production\r\nfarm build\r\n\r\n# Build with specific environment\r\n\r\nfarm build --env production`  },\r\n  {\r\n    language: \"bash\",\r\n    label: \"Docker\",\r\n    code:`# Build Docker containers\r\nfarm docker build\r\n\r\n# Build and push to registry\r\n\r\nfarm docker build --push\r\n\r\n# Build specific service\r\n\r\nfarm docker build --service api`\r\n}\r\n]} />\r\n\r\n### `farm deploy`\r\n\r\nDeploy to configured platforms.\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\", \r\n    label: \"Cloud Deployment\",\r\n    code: `# Deploy to configured platform\r\nfarm deploy\r\n\r\n# Deploy to specific environment\r\n\r\nfarm deploy --env staging\r\n\r\n# Deploy with preview URL\r\n\r\nfarm deploy --preview`\r\n}\r\n]} />\r\n\r\n## Interactive Mode\r\n\r\nWhen running `farm create my-app` without arguments, you'll see:\r\n\r\n```\r\n🌾 Welcome to FARM Stack Framework!\r\n\r\n? What template would you like to use?\r\n  ❯ Basic Web App\r\n    AI Chat Application\r\n    AI Dashboard\r\n    E-commerce Platform\r\n    Content Management System\r\n    API Only (Backend)\r\n    Custom Template\r\n\r\n? Which features would you like to enable? (Press <space> to select)\r\n  ✓ Authentication & User Management\r\n  ✓ AI/ML Integration\r\n  ○ Real-time Features (WebSocket)\r\n  ○ Payment Processing\r\n  ○ Email Service\r\n  ○ File Storage\r\n  ○ Full-text Search\r\n  ○ Analytics\r\n\r\n? Which database would you like to use?\r\n  ❯ MongoDB (Document database)\r\n    PostgreSQL (Relational database)\r\n    MySQL (Relational database)\r\n    SQLite (Development database)\r\n\r\n? Additional options:\r\n  ✓ TypeScript\r\n  ✓ Docker setup\r\n  ✓ Testing framework\r\n  ✓ Git repository\r\n  ✓ Install dependencies\r\n\r\n✨ Creating your FARM project...\r\n```\r\n\r\n<Note>\r\n  All interactive prompts can be skipped by providing the corresponding\r\n  command-line arguments.\r\n</Note>\r\n",
      "excerpt": "The FARM CLI provides a unified command interface for project creation, development, and deployment. Inspired by Next.",
      "category": "docs/api",
      "type": "api",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.788Z",
      "breadcrumbs": [
        "Docs",
        "Api",
        "Cli"
      ],
      "headings": [
        {
          "level": 1,
          "text": "CLI Reference",
          "id": "cli-reference"
        },
        {
          "level": 2,
          "text": "Project Creation",
          "id": "project-creation"
        },
        {
          "level": 3,
          "text": "`farm create`",
          "id": "farm-create"
        },
        {
          "level": 4,
          "text": "Templates",
          "id": "templates"
        },
        {
          "level": 1,
          "text": "Chat app with streaming AI responses",
          "id": "chat-app-with-streaming-ai-responses"
        },
        {
          "level": 1,
          "text": "Data dashboard with ML insights",
          "id": "data-dashboard-with-ml-insights"
        },
        {
          "level": 1,
          "text": "Content management system",
          "id": "content-management-system"
        },
        {
          "level": 1,
          "text": "FastAPI backend only (no React)",
          "id": "fastapi-backend-only-no-react"
        },
        {
          "level": 1,
          "text": "Custom template from URL/path",
          "id": "custom-template-from-urlpath"
        },
        {
          "level": 4,
          "text": "Features",
          "id": "features"
        },
        {
          "level": 4,
          "text": "Database Options",
          "id": "database-options"
        },
        {
          "level": 1,
          "text": "MySQL with SQLAlchemy",
          "id": "mysql-with-sqlalchemy"
        },
        {
          "level": 1,
          "text": "SQLite for development",
          "id": "sqlite-for-development"
        },
        {
          "level": 4,
          "text": "Development Options",
          "id": "development-options"
        },
        {
          "level": 2,
          "text": "Development Commands",
          "id": "development-commands"
        },
        {
          "level": 3,
          "text": "`farm dev`",
          "id": "farm-dev"
        },
        {
          "level": 1,
          "text": "Start with specific port",
          "id": "start-with-specific-port"
        },
        {
          "level": 1,
          "text": "Backend only",
          "id": "backend-only"
        },
        {
          "level": 3,
          "text": "`farm generate`",
          "id": "farm-generate"
        },
        {
          "level": 1,
          "text": "Generate authentication endpoints",
          "id": "generate-authentication-endpoints"
        },
        {
          "level": 1,
          "text": "Generate CRUD API for existing model",
          "id": "generate-crud-api-for-existing-model"
        },
        {
          "level": 1,
          "text": "Generate React component",
          "id": "generate-react-component"
        },
        {
          "level": 1,
          "text": "Generate custom hook",
          "id": "generate-custom-hook"
        },
        {
          "level": 2,
          "text": "Database Commands",
          "id": "database-commands"
        },
        {
          "level": 3,
          "text": "`farm db`",
          "id": "farm-db"
        },
        {
          "level": 1,
          "text": "Create new migration",
          "id": "create-new-migration"
        },
        {
          "level": 1,
          "text": "Rollback migration",
          "id": "rollback-migration"
        },
        {
          "level": 1,
          "text": "Open database GUI",
          "id": "open-database-gui"
        },
        {
          "level": 1,
          "text": "Reset database",
          "id": "reset-database"
        },
        {
          "level": 2,
          "text": "AI/ML Commands",
          "id": "aiml-commands"
        },
        {
          "level": 3,
          "text": "`farm ml`",
          "id": "farm-ml"
        },
        {
          "level": 1,
          "text": "List Ollama models specifically",
          "id": "list-ollama-models-specifically"
        },
        {
          "level": 1,
          "text": "Download Ollama model",
          "id": "download-ollama-model"
        },
        {
          "level": 1,
          "text": "Remove local model",
          "id": "remove-local-model"
        },
        {
          "level": 1,
          "text": "Chat with specific model",
          "id": "chat-with-specific-model"
        },
        {
          "level": 1,
          "text": "Performance testing",
          "id": "performance-testing"
        },
        {
          "level": 2,
          "text": "Build & Deployment",
          "id": "build-deployment"
        },
        {
          "level": 3,
          "text": "`farm build`",
          "id": "farm-build"
        },
        {
          "level": 1,
          "text": "Build with specific environment",
          "id": "build-with-specific-environment"
        },
        {
          "level": 1,
          "text": "Build and push to registry",
          "id": "build-and-push-to-registry"
        },
        {
          "level": 1,
          "text": "Build specific service",
          "id": "build-specific-service"
        },
        {
          "level": 3,
          "text": "`farm deploy`",
          "id": "farm-deploy"
        },
        {
          "level": 1,
          "text": "Deploy to specific environment",
          "id": "deploy-to-specific-environment"
        },
        {
          "level": 1,
          "text": "Deploy with preview URL",
          "id": "deploy-with-preview-url"
        },
        {
          "level": 2,
          "text": "Interactive Mode",
          "id": "interactive-mode"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-api-index",
      "title": "Index",
      "url": "/docs/api",
      "content": "# API Reference\r\n\r\nComprehensive reference documentation for the FARM Framework APIs, CLI tools, and programmatic interfaces.\r\n\r\n## CLI Reference\r\n\r\n<div className=\"grid grid-cols-1 md:grid-cols-2 gap-6 my-8\">\r\n\r\n<Card>\r\n<CardHeader>\r\n<CardTitle>🛠️ FARM CLI</CardTitle>\r\n</CardHeader>\r\n<CardContent>\r\nComplete command reference for the FARM command-line interface, including project creation, development, and deployment commands.\r\n\r\n[CLI Documentation →](/docs/api/cli)\r\n\r\n</CardContent>\r\n</Card>\r\n\r\n<Card>\r\n<CardHeader>\r\n<CardTitle>📦 Package APIs</CardTitle>\r\n</CardHeader>\r\n<CardContent>\r\nCore package APIs for extending FARM with custom functionality and integrations.\r\n\r\n[Package APIs →](/docs/api/packages)\r\n\r\n</CardContent>\r\n</Card>\r\n\r\n</div>\r\n\r\n## Core APIs\r\n\r\n### Configuration API\r\n\r\n<ApiMethod method=\"GET\" endpoint=\"/api/config\" description=\"Retrieve current configuration\">\r\n\r\n```typescript\r\nimport { getConfig } from \"@farm/core\";\r\n\r\nconst config = await getConfig();\r\nconsole.log(config.database.provider); // 'mongodb'\r\n```\r\n\r\n</ApiMethod>\r\n\r\n<ApiMethod method=\"POST\" endpoint=\"/api/config\" description=\"Update configuration\">\r\n\r\n```typescript\r\nimport { updateConfig } from \"@farm/core\";\r\n\r\nawait updateConfig({\r\n  ai: {\r\n    provider: \"openai\",\r\n    model: \"gpt-4\",\r\n  },\r\n});\r\n```\r\n\r\n</ApiMethod>\r\n\r\n### Database API\r\n\r\n<ApiMethod method=\"GET\" endpoint=\"/api/db/connect\" description=\"Establish database connection\">\r\n\r\n```typescript\r\nimport { connectDatabase } from \"@farm/database\";\r\n\r\nconst db = await connectDatabase({\r\n  provider: \"mongodb\",\r\n  url: process.env.DATABASE_URL,\r\n});\r\n```\r\n\r\n</ApiMethod>\r\n\r\n### AI Integration API\r\n\r\n<ApiMethod method=\"POST\" endpoint=\"/api/ai/generate\" description=\"Generate AI responses\">\r\n\r\n```typescript\r\nimport { generateResponse } from \"@farm/ai\";\r\n\r\nconst response = await generateResponse({\r\n  provider: \"ollama\",\r\n  model: \"llama3.2\",\r\n  prompt: \"Create a user model\",\r\n});\r\n```\r\n\r\n</ApiMethod>\r\n\r\n## Plugin APIs\r\n\r\n<PropertyTable\r\n  properties={[\r\n    {\r\n      name: \"register\",\r\n      type: \"function\",\r\n      required: true,\r\n      description: \"Register a new plugin with the FARM framework\",\r\n    },\r\n    {\r\n      name: \"unregister\",\r\n      type: \"function\",\r\n      required: false,\r\n      description: \"Remove a plugin from the active registry\",\r\n    },\r\n    {\r\n      name: \"listPlugins\",\r\n      type: \"function\",\r\n      required: false,\r\n      description: \"Get all registered plugins and their status\",\r\n    },\r\n    {\r\n      name: \"getPlugin\",\r\n      type: \"function\",\r\n      required: false,\r\n      description: \"Retrieve a specific plugin by name or ID\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n## WebSocket API\r\n\r\nReal-time communication APIs for live features:\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Client\",\r\n    code: `import { createWebSocketClient } from '@farm/websocket';\r\n\r\nconst client = createWebSocketClient({\r\nurl: 'ws://localhost:8000/ws',\r\nauth: {\r\ntoken: userToken\r\n}\r\n});\r\n\r\nclient.on('message', (data) => {\r\nconsole.log('Received:', data);\r\n});\r\n\r\nclient.send('chat', {\r\nmessage: 'Hello, world!',\r\nroom: 'general'\r\n});`  },\r\n  {\r\n    language: \"python\",\r\n    label: \"Server\",\r\n    code:`from farm.websocket import WebSocketManager\r\n\r\nasync def handle_chat_message(websocket, data):\r\nmessage = data.get('message')\r\nroom = data.get('room', 'general')\r\n\r\n    # Broadcast to all clients in room\r\n    await websocket_manager.broadcast(\r\n        room=room,\r\n        event='new_message',\r\n        data={\r\n            'message': message,\r\n            'user': websocket.user.id,\r\n            'timestamp': datetime.utcnow()\r\n        }\r\n    )`\r\n\r\n}\r\n]} />\r\n\r\n## REST API Endpoints\r\n\r\n### Authentication\r\n\r\n<div className=\"space-y-4\">\r\n\r\n<ApiMethod method=\"POST\" endpoint=\"/api/auth/login\" description=\"User authentication\">\r\n\r\n**Request Body:**\r\n\r\n```json\r\n{\r\n  \"email\": \"user@example.com\",\r\n  \"password\": \"secure_password\"\r\n}\r\n```\r\n\r\n**Response:**\r\n\r\n```json\r\n{\r\n  \"token\": \"jwt_token_here\",\r\n  \"user\": {\r\n    \"id\": \"user_id\",\r\n    \"email\": \"user@example.com\",\r\n    \"role\": \"user\"\r\n  }\r\n}\r\n```\r\n\r\n</ApiMethod>\r\n\r\n<ApiMethod method=\"POST\" endpoint=\"/api/auth/register\" description=\"User registration\">\r\n\r\n**Request Body:**\r\n\r\n```json\r\n{\r\n  \"email\": \"user@example.com\",\r\n  \"password\": \"secure_password\",\r\n  \"name\": \"User Name\"\r\n}\r\n```\r\n\r\n</ApiMethod>\r\n\r\n<ApiMethod method=\"POST\" endpoint=\"/api/auth/refresh\" description=\"Refresh authentication token\">\r\n\r\n**Headers:**\r\n\r\n```\r\nAuthorization: Bearer <refresh_token>\r\n```\r\n\r\n</ApiMethod>\r\n\r\n</div>\r\n\r\n### Data Management\r\n\r\n<div className=\"space-y-4\">\r\n\r\n<ApiMethod method=\"GET\" endpoint=\"/api/users\" description=\"List all users\">\r\n\r\n**Query Parameters:**\r\n\r\n- `page` (optional): Page number for pagination\r\n- `limit` (optional): Number of items per page\r\n- `search` (optional): Search term for filtering\r\n\r\n</ApiMethod>\r\n\r\n<ApiMethod method=\"POST\" endpoint=\"/api/users\" description=\"Create new user\">\r\n\r\n**Request Body:**\r\n\r\n```json\r\n{\r\n  \"name\": \"User Name\",\r\n  \"email\": \"user@example.com\",\r\n  \"role\": \"user\"\r\n}\r\n```\r\n\r\n</ApiMethod>\r\n\r\n<ApiMethod method=\"PUT\" endpoint=\"/api/users/{id}\" description=\"Update user by ID\">\r\n\r\n**Path Parameters:**\r\n\r\n- `id`: User ID\r\n\r\n**Request Body:**\r\n\r\n```json\r\n{\r\n  \"name\": \"Updated Name\",\r\n  \"role\": \"admin\"\r\n}\r\n```\r\n\r\n</ApiMethod>\r\n\r\n<ApiMethod method=\"DELETE\" endpoint=\"/api/users/{id}\" description=\"Delete user by ID\">\r\n\r\n**Path Parameters:**\r\n\r\n- `id`: User ID\r\n\r\n</ApiMethod>\r\n\r\n</div>\r\n\r\n## Error Handling\r\n\r\nAll API endpoints follow consistent error response format:\r\n\r\n```json\r\n{\r\n  \"error\": {\r\n    \"code\": \"VALIDATION_ERROR\",\r\n    \"message\": \"Invalid input parameters\",\r\n    \"details\": {\r\n      \"field\": \"email\",\r\n      \"issue\": \"Invalid email format\"\r\n    }\r\n  },\r\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\r\n  \"requestId\": \"req_123456789\"\r\n}\r\n```\r\n\r\n### Common Error Codes\r\n\r\n<PropertyTable\r\n  properties={[\r\n    {\r\n      name: \"VALIDATION_ERROR\",\r\n      type: \"400\",\r\n      description: \"Request validation failed - check input parameters\",\r\n    },\r\n    {\r\n      name: \"UNAUTHORIZED\",\r\n      type: \"401\",\r\n      description: \"Authentication required or token invalid\",\r\n    },\r\n    {\r\n      name: \"FORBIDDEN\",\r\n      type: \"403\",\r\n      description: \"Insufficient permissions for requested resource\",\r\n    },\r\n    {\r\n      name: \"NOT_FOUND\",\r\n      type: \"404\",\r\n      description: \"Requested resource does not exist\",\r\n    },\r\n    {\r\n      name: \"RATE_LIMITED\",\r\n      type: \"429\",\r\n      description: \"Too many requests - rate limit exceeded\",\r\n    },\r\n    {\r\n      name: \"INTERNAL_ERROR\",\r\n      type: \"500\",\r\n      description: \"Internal server error - check server logs\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n## SDK Integration\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Node.js SDK\",\r\n    code: `import { FarmClient } from '@farm/sdk';\r\n\r\nconst client = new FarmClient({\r\napiKey: process.env.FARM_API_KEY,\r\nbaseUrl: 'https://api.farm-framework.dev'\r\n});\r\n\r\n// Create user\r\nconst user = await client.users.create({\r\nname: 'John Doe',\r\nemail: 'john@example.com'\r\n});\r\n\r\n// Generate AI response\r\nconst response = await client.ai.generate({\r\nmodel: 'gpt-4',\r\nprompt: 'Create a user interface component'\r\n});`  },\r\n  {\r\n    language: \"python\",\r\n    label: \"Python SDK\",\r\n    code:`from farm_sdk import FarmClient\r\n\r\nclient = FarmClient(\r\napi_key=os.getenv('FARM_API_KEY'),\r\nbase_url='https://api.farm-framework.dev'\r\n)\r\n\r\n# Create user\r\n\r\nuser = client.users.create(\r\nname='John Doe',\r\nemail='john@example.com'\r\n)\r\n\r\n# Generate AI response\r\n\r\nresponse = client.ai.generate(\r\nmodel='gpt-4',\r\nprompt='Create a user interface component'\r\n)`\r\n}\r\n]} />\r\n\r\n<Note title=\"SDK Installation\">\r\nInstall the official FARM SDK for your preferred language:\r\n\r\n- **Node.js**: `npm install @farm/sdk`\r\n- **Python**: `pip install farm-framework-sdk`\r\n- **Go**: `go get github.com/farm-framework/go-sdk`\r\n\r\n</Note>\r\n",
      "excerpt": "Comprehensive reference documentation for the FARM Framework APIs, CLI tools, and programmatic interfaces.",
      "category": "docs/api",
      "type": "api",
      "tags": [
        "mongodb",
        "farm",
        "typescript",
        "python",
        "authentication"
      ],
      "lastModified": "2025-06-12T21:57:32.789Z",
      "breadcrumbs": [
        "Docs",
        "Api",
        "Index"
      ],
      "headings": [
        {
          "level": 1,
          "text": "API Reference",
          "id": "api-reference"
        },
        {
          "level": 2,
          "text": "CLI Reference",
          "id": "cli-reference"
        },
        {
          "level": 2,
          "text": "Core APIs",
          "id": "core-apis"
        },
        {
          "level": 3,
          "text": "Configuration API",
          "id": "configuration-api"
        },
        {
          "level": 3,
          "text": "Database API",
          "id": "database-api"
        },
        {
          "level": 3,
          "text": "AI Integration API",
          "id": "ai-integration-api"
        },
        {
          "level": 2,
          "text": "Plugin APIs",
          "id": "plugin-apis"
        },
        {
          "level": 2,
          "text": "WebSocket API",
          "id": "websocket-api"
        },
        {
          "level": 2,
          "text": "REST API Endpoints",
          "id": "rest-api-endpoints"
        },
        {
          "level": 3,
          "text": "Authentication",
          "id": "authentication"
        },
        {
          "level": 3,
          "text": "Data Management",
          "id": "data-management"
        },
        {
          "level": 2,
          "text": "Error Handling",
          "id": "error-handling"
        },
        {
          "level": 3,
          "text": "Common Error Codes",
          "id": "common-error-codes"
        },
        {
          "level": 2,
          "text": "SDK Integration",
          "id": "sdk-integration"
        },
        {
          "level": 1,
          "text": "Create user",
          "id": "create-user"
        },
        {
          "level": 1,
          "text": "Generate AI response",
          "id": "generate-ai-response"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-community-index",
      "title": "Index",
      "url": "/docs/community",
      "content": "# Community & Ecosystem\r\n\r\nA plugin registry, community hub and marketplace encourage ecosystem growth. Quality assurance and security scanning help maintain a trusted plugin ecosystem.\r\n",
      "excerpt": "A plugin registry, community hub and marketplace encourage ecosystem growth. Quality assurance and security scanning help maintain a trusted plugin ecosystem. .",
      "category": "docs/community",
      "type": "reference",
      "tags": [],
      "lastModified": "2025-06-12T21:57:32.789Z",
      "breadcrumbs": [
        "Docs",
        "Community",
        "Index"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Community & Ecosystem",
          "id": "community-ecosystem"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-community-README",
      "title": "README",
      "url": "/docs/community/README",
      "content": "# Community\r\n\r\nLearn how to contribute and participate in the FARM ecosystem.\r\n",
      "excerpt": "Learn how to contribute and participate in the FARM ecosystem. .",
      "category": "docs/community",
      "type": "reference",
      "tags": [
        "farm"
      ],
      "lastModified": "2025-06-12T21:57:32.789Z",
      "breadcrumbs": [
        "Docs",
        "Community",
        "README"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Community",
          "id": "community"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-components",
      "title": "Components",
      "url": "/docs/components",
      "content": "# Component Library\r\n\r\nComprehensive showcase of all available UI components and documentation elements in the FARM Framework.\r\n\r\n## Layout Components\r\n\r\n### Cards\r\n\r\n<div className=\"grid grid-cols-1 md:grid-cols-2 gap-6 my-8\">\r\n\r\n<Card>\r\n  <CardHeader>\r\n    <CardTitle>Basic Card</CardTitle>\r\n    <CardDescription>\r\n      Standard card component with header, content, and footer sections.\r\n    </CardDescription>\r\n  </CardHeader>\r\n  <CardContent>\r\n    This is the main content area of the card. You can place any content here\r\n    including text, images, forms, or other components.\r\n  </CardContent> <CardFooter>\r\n    <div className=\"text-sm text-muted-foreground\">\r\n      Card footer with additional information\r\n    </div>\r\n  </CardFooter>\r\n</Card>\r\n\r\n<Card>\r\n  <CardHeader>\r\n    <CardTitle>Interactive Card</CardTitle>\r\n    <CardDescription>\r\n      Cards can contain interactive elements like buttons and forms.\r\n    </CardDescription>\r\n  </CardHeader>\r\n  <CardContent>\r\n    <div className=\"space-y-4\">\r\n      <p>Cards are perfect for organizing related content and actions.</p>\r\n      <div className=\"flex gap-2\">\r\n        <button className=\"px-3 py-1 bg-primary text-primary-foreground rounded text-sm\">\r\n          Primary\r\n        </button>\r\n        <button className=\"px-3 py-1 border rounded text-sm\">Secondary</button>\r\n      </div>\r\n    </div>\r\n  </CardContent>\r\n</Card>\r\n\r\n</div>\r\n\r\n## Interactive Components\r\n\r\n### Accordion\r\n\r\nPerfect for organizing FAQ content or collapsible sections:\r\n\r\n<Accordion title=\"What is FARM Framework?\">\r\n  FARM is an AI-first full-stack framework that combines React, FastAPI, and\r\n  MongoDB with intelligent code generation, built-in AI integration, and modern\r\n  development tools.\r\n</Accordion>\r\n\r\n<Accordion title=\"How does the AI integration work?\">\r\n  FARM supports multiple AI providers including OpenAI, Ollama, and Hugging\r\n  Face. You can configure providers in your `farm.config.ts` file and use them\r\n  throughout your application for various tasks.\r\n</Accordion>\r\n\r\n<Accordion title=\"Is FARM suitable for production?\">\r\n  Yes! FARM includes enterprise-grade features like authentication, database\r\n  optimization, deployment automation, and monitoring tools that make it\r\n  production-ready.\r\n</Accordion>\r\n\r\n### Tabs\r\n\r\nOrganize related content with smooth tab transitions:\r\n\r\n<Tabs defaultValue=\"overview\" className=\"mt-6\">\r\n  <TabsList>\r\n    <TabsTrigger value=\"overview\">Overview</TabsTrigger>\r\n    <TabsTrigger value=\"features\">Features</TabsTrigger>\r\n    <TabsTrigger value=\"examples\">Examples</TabsTrigger>\r\n  </TabsList>\r\n  <TabsContent value=\"overview\">\r\n    <div className=\"space-y-4\">\r\n      <h4 className=\"text-lg font-semibold\">Framework Overview</h4>\r\n      <p>\r\n        FARM Framework provides a complete development experience with\r\n        AI-powered tools, automatic code generation, and enterprise-grade\r\n        features.\r\n      </p>\r\n    </div>\r\n  </TabsContent>\r\n  <TabsContent value=\"features\">\r\n    <div className=\"space-y-4\">\r\n      <h4 className=\"text-lg font-semibold\">Key Features</h4>\r\n      <ul className=\"space-y-2\">\r\n        <li>• AI-powered code generation</li>\r\n        <li>• Multi-provider AI integration</li>\r\n        <li>• Type-safe database layer</li>\r\n        <li>• Built-in authentication</li>\r\n        <li>• Production deployment automation</li>\r\n      </ul>\r\n    </div>\r\n  </TabsContent>\r\n  <TabsContent value=\"examples\">\r\n    <div className=\"space-y-4\">\r\n      <h4 className=\"text-lg font-semibold\">Usage Examples</h4>\r\n      <p>\r\n        Create a new project: <code>farm create my-app</code>\r\n      </p>\r\n      <p>\r\n        Generate components: <code>farm generate component UserCard</code>\r\n      </p>\r\n      <p>\r\n        Start development: <code>farm dev</code>\r\n      </p>\r\n    </div>\r\n  </TabsContent>\r\n</Tabs>\r\n\r\n## Code Display Components\r\n\r\n### Code Blocks\r\n\r\nSingle language code blocks with syntax highlighting:\r\n\r\n```typescript\r\n// TypeScript example\r\ninterface User {\r\n  id: string;\r\n  name: string;\r\n  email: string;\r\n  createdAt: Date;\r\n}\r\n\r\nconst createUser = async (userData: Partial<User>): Promise<User> => {\r\n  return await userRepository.create(userData);\r\n};\r\n```\r\n\r\n```python\r\n# Python example\r\nfrom farm.database import db\r\nfrom farm.models import User\r\n\r\nasync def create_user(user_data: dict) -> User:\r\n    user = User(**user_data)\r\n    await db.save(user)\r\n    return user\r\n```\r\n\r\n### Code Tabs\r\n\r\nMulti-language examples with tabbed interface:\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"React Hook\",\r\n    code: `import { useAI } from '@farm/ai-react';\r\n\r\nexport function ChatComponent() {\r\n  const { generate, loading, error } = useAI({\r\n    provider: 'ollama',\r\n    model: 'llama3.2'\r\n  });\r\n\r\nconst handleSubmit = async (message: string) => {\r\nconst response = await generate({\r\nprompt: message,\r\ntemperature: 0.7\r\n});\r\nsetMessages(prev => [...prev, response]);\r\n};\r\n\r\nreturn (\r\n\r\n<div className=\"chat-interface\">\r\n{/* Chat UI implementation */}\r\n</div>\r\n);\r\n}`  },\r\n  {\r\n    language: \"python\",\r\n    label: \"FastAPI Route\", \r\n    code:`from fastapi import APIRouter\r\nfrom farm.ai import get_ai_provider\r\n\r\nrouter = APIRouter()\r\n\r\n@router.post(\"/api/chat\")\r\nasync def chat_endpoint(message: str):\r\nai = get_ai_provider('ollama')\r\n\r\n    response = await ai.generate(\r\n        model='llama3.2',\r\n        prompt=message,\r\n        temperature=0.7\r\n    )\r\n\r\n    return {\"response\": response}`\r\n\r\n},\r\n{\r\nlanguage: \"bash\",\r\nlabel: \"CLI Usage\",\r\ncode: `# Create AI-enabled project\r\nfarm create my-chat-app --template ai-chat\r\n\r\n# Generate AI integration\r\n\r\nfarm generate ai-provider ollama\r\n\r\n# Start development server\r\n\r\nfarm dev\r\n\r\n# Deploy to production\r\n\r\nfarm deploy --platform vercel`\r\n}\r\n]} />\r\n\r\n## Documentation Components\r\n\r\n### Callouts\r\n\r\nHighlight important information with styled callouts:\r\n\r\n<Callout type=\"info\" title=\"Information\">\r\n  This is an informational callout that provides helpful context or additional\r\n  details about the topic being discussed.\r\n</Callout>\r\n\r\n<Callout type=\"warning\" title=\"Important Warning\">\r\n  This warning callout alerts users to potential issues, breaking changes, or\r\n  important considerations they should be aware of.\r\n</Callout>\r\n\r\n<Callout type=\"error\" title=\"Critical Error\">\r\n  Error callouts highlight critical issues, deprecated features, or actions that\r\n  could cause problems if not handled properly.\r\n</Callout>\r\n\r\n<Callout type=\"success\" title=\"Success\">\r\n  Success callouts celebrate achievements, confirm successful operations, or\r\n  highlight positive outcomes.\r\n</Callout>\r\n\r\n<Callout\r\n  className=\"gradient-callout-text\"\r\n  type=\"gradient\"\r\n  title=\"FARM Framework Integration\"\r\n>\r\n  This special gradient callout showcases the beautiful blend of technologies\r\n  that power FARM Framework - from Python's robust backend capabilities, through\r\n  the golden bridge of APIs, to React's dynamic frontend magic. Perfect for\r\n  highlighting the seamless integration between different parts of your\r\n  full-stack application!\r\n</Callout>\r\n\r\n### Enhanced Notes\r\n\r\n<Note title=\"Pro Tip\">\r\n  Use these note components to highlight helpful tips, best practices, or\r\n  insider knowledge that can improve the developer experience.\r\n</Note>\r\n\r\n<Warning title=\"Breaking Change\">\r\n  This feature has been deprecated in version 1.5 and will be removed in version\r\n  2.0. Please migrate to the new API before upgrading.\r\n</Warning>\r\n\r\n<Info title=\"New Feature\">\r\n  This feature was added in version 1.4 and provides enhanced performance and\r\n  better type safety for your applications.\r\n</Info>\r\n\r\n### Step-by-Step Instructions\r\n\r\n<div className=\"space-y-4\">\r\n\r\n<Step number=\"1\" title=\"Project Setup\">\r\nCreate a new FARM project with the AI template for quick setup with intelligent features built-in.\r\n\r\n```bash\r\nfarm create my-ai-app --template ai-chat\r\n```\r\n\r\n</Step>\r\n\r\n<Step number=\"2\" title=\"Configure AI Provider\">\r\nSet up your preferred AI provider in the configuration file. FARM supports multiple providers for flexibility.\r\n\r\n```typescript\r\n// farm.config.ts\r\nexport default defineConfig({\r\n  ai: {\r\n    provider: \"ollama\",\r\n    models: [\"llama3.2\", \"codellama\"],\r\n    temperature: 0.7,\r\n  },\r\n});\r\n```\r\n\r\n</Step>\r\n\r\n<Step number=\"3\" title=\"Implement Features\">\r\nUse the generated hooks and components to build your AI-powered features with type safety and error handling.\r\n\r\n```typescript\r\nconst { generate, loading } = useAI();\r\nconst response = await generate(\"Create a user dashboard\");\r\n```\r\n\r\n</Step>\r\n\r\n</div>\r\n\r\n## API Documentation Components\r\n\r\n### API Methods\r\n\r\n<ApiMethod method=\"GET\" endpoint=\"/api/users\" description=\"Retrieve all users with pagination\">\r\n\r\n**Query Parameters:**\r\n\r\n- `page` (number): Page number for pagination\r\n- `limit` (number): Items per page (default: 20)\r\n- `search` (string): Search term for filtering\r\n\r\n**Response:**\r\n\r\n```json\r\n{\r\n  \"users\": [\r\n    {\r\n      \"id\": \"user_123\",\r\n      \"name\": \"John Doe\",\r\n      \"email\": \"john@example.com\"\r\n    }\r\n  ],\r\n  \"pagination\": {\r\n    \"page\": 1,\r\n    \"limit\": 20,\r\n    \"total\": 150\r\n  }\r\n}\r\n```\r\n\r\n</ApiMethod>\r\n\r\n<ApiMethod method=\"POST\" endpoint=\"/api/users\" description=\"Create a new user\">\r\n\r\n**Request Body:**\r\n\r\n```json\r\n{\r\n  \"name\": \"Jane Smith\",\r\n  \"email\": \"jane@example.com\",\r\n  \"role\": \"user\"\r\n}\r\n```\r\n\r\n**Response:**\r\n\r\n```json\r\n{\r\n  \"id\": \"user_124\",\r\n  \"name\": \"Jane Smith\",\r\n  \"email\": \"jane@example.com\",\r\n  \"role\": \"user\",\r\n  \"createdAt\": \"2024-01-15T10:30:00Z\"\r\n}\r\n```\r\n\r\n</ApiMethod>\r\n\r\n### Property Tables\r\n\r\n<PropertyTable\r\n  properties={[\r\n    {\r\n      name: \"provider\",\r\n      type: \"string\",\r\n      required: true,\r\n      description: \"AI provider name ('openai', 'ollama', 'huggingface')\",\r\n      default: undefined,\r\n    },\r\n    {\r\n      name: \"model\",\r\n      type: \"string\",\r\n      required: true,\r\n      description: \"Model identifier for the selected provider\",\r\n      default: undefined,\r\n    },\r\n    {\r\n      name: \"temperature\",\r\n      type: \"number\",\r\n      required: false,\r\n      description: \"Creativity level for AI responses (0.0 to 2.0)\",\r\n      default: \"0.7\",\r\n    },\r\n    {\r\n      name: \"maxTokens\",\r\n      type: \"number\",\r\n      required: false,\r\n      description: \"Maximum tokens in the generated response\",\r\n      default: \"2048\",\r\n    },\r\n    {\r\n      name: \"streaming\",\r\n      type: \"boolean\",\r\n      required: false,\r\n      description: \"Enable real-time streaming of responses\",\r\n      default: \"false\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n### Feature Lists\r\n\r\n<FeatureList\r\n  features={[\r\n    {\r\n      name: \"TypeScript Support\",\r\n      included: true,\r\n      description: \"Full TypeScript integration with automatic type generation\",\r\n    },\r\n    {\r\n      name: \"Hot Module Replacement\",\r\n      included: true,\r\n      description:\r\n        \"Fast development with instant updates and state preservation\",\r\n    },\r\n    {\r\n      name: \"Built-in Authentication\",\r\n      included: true,\r\n      description: \"Multiple OAuth providers and JWT token management\",\r\n    },\r\n    {\r\n      name: \"AI Code Generation\",\r\n      included: true,\r\n      description:\r\n        \"Intelligent component and API generation with AI assistance\",\r\n    },\r\n    {\r\n      name: \"GraphQL Support\",\r\n      included: false,\r\n      description: \"GraphQL integration planned for version 2.0\",\r\n    },\r\n    {\r\n      name: \"Real-time Features\",\r\n      included: false,\r\n      description: \"WebSocket integration coming in Q2 2024\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n### Comparison Tables\r\n\r\n<ComparisonTable\r\n  title=\"FARM vs Other Frameworks\"\r\n  frameworks={[\r\n    {\r\n      name: \"FARM\",\r\n      features: {\r\n        \"AI Integration\": \"✅ Built-in\",\r\n        \"Type Safety\": \"✅ Full TypeScript\",\r\n        \"Code Generation\": \"✅ AI-powered\",\r\n        Database: \"✅ MongoDB + Beanie\",\r\n        Authentication: \"✅ Multi-provider\",\r\n        Deployment: \"✅ Automated\",\r\n      },\r\n    },\r\n    {\r\n      name: \"Next.js\",\r\n      features: {\r\n        \"AI Integration\": \"❌ Manual setup\",\r\n        \"Type Safety\": \"✅ TypeScript\",\r\n        \"Code Generation\": \"❌ Limited\",\r\n        Database: \"❌ BYO solution\",\r\n        Authentication: \"❌ Third-party\",\r\n        Deployment: \"✅ Vercel\",\r\n      },\r\n    },\r\n    {\r\n      name: \"Django\",\r\n      features: {\r\n        \"AI Integration\": \"❌ Manual setup\",\r\n        \"Type Safety\": \"⚠️ Python typing\",\r\n        \"Code Generation\": \"✅ Built-in\",\r\n        Database: \"✅ ORM included\",\r\n        Authentication: \"✅ Built-in\",\r\n        Deployment: \"⚠️ Manual\",\r\n      },\r\n    },\r\n  ]}\r\n/>\r\n\r\n## Badges and Labels\r\n\r\n<div className=\"flex flex-wrap gap-2 my-4\">\r\n  <Badge variant=\"default\">Default</Badge>\r\n  <Badge variant=\"secondary\">Secondary</Badge>\r\n  <Badge variant=\"destructive\">Destructive</Badge>\r\n  <Badge variant=\"outline\">Outline</Badge>\r\n</div>\r\n\r\n## Typography Elements\r\n\r\n### Headings\r\n\r\n# H1 Heading\r\n\r\n## H2 Heading\r\n\r\n### H3 Heading\r\n\r\n#### H4 Heading\r\n\r\n##### H5 Heading\r\n\r\n###### H6 Heading\r\n\r\n### Text Styles\r\n\r\n**Bold text** for emphasis and _italic text_ for subtle highlighting.\r\n\r\n`Inline code` for technical terms and file names.\r\n\r\n> Blockquotes for important quotes or highlighting key concepts from documentation or user feedback.\r\n\r\n### Lists\r\n\r\n**Unordered list:**\r\n\r\n- Feature one with comprehensive description\r\n- Feature two with detailed explanation\r\n- Feature three with additional context\r\n\r\n**Ordered list:**\r\n\r\n1. First step in the process\r\n2. Second step with important details\r\n3. Third step completing the workflow\r\n\r\n**Task list:**\r\n\r\n- [x] Completed feature or task\r\n- [x] Another completed item\r\n- [ ] Pending feature or task\r\n- [ ] Future enhancement\r\n\r\n## Usage Guidelines\r\n\r\n<div className=\"grid grid-cols-1 md:grid-cols-2 gap-6 my-8\">\r\n\r\n<Card>\r\n  <CardHeader>\r\n    <CardTitle>🎨 Design Principles</CardTitle>\r\n  </CardHeader>\r\n  <CardContent>\r\n    <ul className=\"space-y-2 text-sm\">\r\n      <li>• Consistent spacing and typography</li>\r\n      <li>• High contrast for accessibility</li>\r\n      <li>• Mobile-responsive design</li>\r\n      <li>• Dark/light theme support</li>\r\n    </ul>\r\n  </CardContent>\r\n</Card>\r\n\r\n<Card>\r\n  <CardHeader>\r\n    <CardTitle>📝 Content Guidelines</CardTitle>\r\n  </CardHeader>\r\n  <CardContent>\r\n    <ul className=\"space-y-2 text-sm\">\r\n      <li>• Clear and concise messaging</li>\r\n      <li>• Consistent terminology</li>\r\n      <li>• Helpful code examples</li>\r\n      <li>• Proper component usage</li>\r\n    </ul>\r\n  </CardContent>\r\n</Card>\r\n\r\n</div>\r\n\r\n<Note title=\"Component Documentation\">\r\n  All components are fully documented with TypeScript interfaces and include\r\n  accessibility features. Refer to the [Typography\r\n  Showcase](/docs/typography-showcase) for additional examples and advanced\r\n  usage patterns.\r\n</Note>\r\n",
      "excerpt": "Comprehensive showcase of all available UI components and documentation elements in the FARM Framework.",
      "category": "docs",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.790Z",
      "breadcrumbs": [
        "Docs",
        "Components"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Component Library",
          "id": "component-library"
        },
        {
          "level": 2,
          "text": "Layout Components",
          "id": "layout-components"
        },
        {
          "level": 3,
          "text": "Cards",
          "id": "cards"
        },
        {
          "level": 2,
          "text": "Interactive Components",
          "id": "interactive-components"
        },
        {
          "level": 3,
          "text": "Accordion",
          "id": "accordion"
        },
        {
          "level": 3,
          "text": "Tabs",
          "id": "tabs"
        },
        {
          "level": 2,
          "text": "Code Display Components",
          "id": "code-display-components"
        },
        {
          "level": 3,
          "text": "Code Blocks",
          "id": "code-blocks"
        },
        {
          "level": 1,
          "text": "Python example",
          "id": "python-example"
        },
        {
          "level": 3,
          "text": "Code Tabs",
          "id": "code-tabs"
        },
        {
          "level": 1,
          "text": "Generate AI integration",
          "id": "generate-ai-integration"
        },
        {
          "level": 1,
          "text": "Start development server",
          "id": "start-development-server"
        },
        {
          "level": 1,
          "text": "Deploy to production",
          "id": "deploy-to-production"
        },
        {
          "level": 2,
          "text": "Documentation Components",
          "id": "documentation-components"
        },
        {
          "level": 3,
          "text": "Callouts",
          "id": "callouts"
        },
        {
          "level": 3,
          "text": "Enhanced Notes",
          "id": "enhanced-notes"
        },
        {
          "level": 3,
          "text": "Step-by-Step Instructions",
          "id": "step-by-step-instructions"
        },
        {
          "level": 2,
          "text": "API Documentation Components",
          "id": "api-documentation-components"
        },
        {
          "level": 3,
          "text": "API Methods",
          "id": "api-methods"
        },
        {
          "level": 3,
          "text": "Property Tables",
          "id": "property-tables"
        },
        {
          "level": 3,
          "text": "Feature Lists",
          "id": "feature-lists"
        },
        {
          "level": 3,
          "text": "Comparison Tables",
          "id": "comparison-tables"
        },
        {
          "level": 2,
          "text": "Badges and Labels",
          "id": "badges-and-labels"
        },
        {
          "level": 2,
          "text": "Typography Elements",
          "id": "typography-elements"
        },
        {
          "level": 3,
          "text": "Headings",
          "id": "headings"
        },
        {
          "level": 1,
          "text": "H1 Heading",
          "id": "h1-heading"
        },
        {
          "level": 2,
          "text": "H2 Heading",
          "id": "h2-heading"
        },
        {
          "level": 3,
          "text": "H3 Heading",
          "id": "h3-heading"
        },
        {
          "level": 4,
          "text": "H4 Heading",
          "id": "h4-heading"
        },
        {
          "level": 5,
          "text": "H5 Heading",
          "id": "h5-heading"
        },
        {
          "level": 6,
          "text": "H6 Heading",
          "id": "h6-heading"
        },
        {
          "level": 3,
          "text": "Text Styles",
          "id": "text-styles"
        },
        {
          "level": 3,
          "text": "Lists",
          "id": "lists"
        },
        {
          "level": 2,
          "text": "Usage Guidelines",
          "id": "usage-guidelines"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-configuration-index",
      "title": "Index",
      "url": "/docs/configuration",
      "content": "# Configuration\r\n\r\nProject settings live in `farm.config.ts`. This file controls database options, AI providers, authentication, and build settings.\r\n\r\n## Basic Configuration\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"TypeScript\",\r\n    code: `// farm.config.ts\r\nimport { defineConfig } from '@farm/core';\r\n\r\nexport default defineConfig({\r\n  database: {\r\n    provider: 'mongodb',\r\n    url: process.env.DATABASE_URL || 'mongodb://localhost:27017/farm-app'\r\n  },\r\n  ai: {\r\n    provider: 'ollama',\r\n    models: ['llama3.2', 'codellama']\r\n  },\r\n  auth: {\r\n    providers: ['github', 'google'],\r\n    jwt: {\r\n      secret: process.env.JWT_SECRET!,\r\n      expiresIn: '7d'\r\n    }\r\n  }\r\n});`\r\n  },\r\n  {\r\n    language: \"javascript\",\r\n    label: \"JavaScript\",\r\n    code: `// farm.config.js\r\nconst { defineConfig } = require('@farm/core');\r\n\r\nmodule.exports = defineConfig({\r\ndatabase: {\r\nprovider: 'mongodb',\r\nurl: process.env.DATABASE_URL || 'mongodb://localhost:27017/farm-app'\r\n},\r\nai: {\r\nprovider: 'ollama',\r\nmodels: ['llama3.2', 'codellama']\r\n},\r\nauth: {\r\nproviders: ['github', 'google'],\r\njwt: {\r\nsecret: process.env.JWT_SECRET,\r\nexpiresIn: '7d'\r\n}\r\n}\r\n});`\r\n}\r\n]} />\r\n\r\n## Environment Variables\r\n\r\nCreate a `.env` file in your project root:\r\n\r\n```bash\r\n# Database\r\nDATABASE_URL=mongodb://localhost:27017/farm-app\r\n\r\n# Authentication\r\nJWT_SECRET=your-super-secret-jwt-key\r\nGITHUB_CLIENT_ID=your-github-client-id\r\nGITHUB_CLIENT_SECRET=your-github-client-secret\r\n\r\n# AI Providers\r\nOPENAI_API_KEY=your-openai-api-key\r\nOLLAMA_HOST=http://localhost:11434\r\n```\r\n\r\n## Advanced Configuration\r\n\r\n<PropertyTable\r\n  properties={[\r\n    {\r\n      name: \"database.provider\",\r\n      type: \"string\",\r\n      required: true,\r\n      description: \"Database provider ('mongodb', 'postgresql', 'sqlite')\",\r\n    },\r\n    {\r\n      name: \"database.url\",\r\n      type: \"string\",\r\n      required: true,\r\n      description: \"Database connection string\",\r\n    },\r\n    {\r\n      name: \"ai.provider\",\r\n      type: \"string\",\r\n      required: false,\r\n      description: \"AI provider ('ollama', 'openai', 'huggingface')\",\r\n      default: \"none\",\r\n    },\r\n    {\r\n      name: \"auth.providers\",\r\n      type: \"string[]\",\r\n      required: false,\r\n      description: \"OAuth providers to enable\",\r\n      default: \"[]\",\r\n    },\r\n    {\r\n      name: \"server.port\",\r\n      type: \"number\",\r\n      required: false,\r\n      description: \"Backend server port\",\r\n      default: \"8000\",\r\n    },\r\n    {\r\n      name: \"frontend.port\",\r\n      type: \"number\",\r\n      required: false,\r\n      description: \"Frontend development port\",\r\n      default: \"3000\",\r\n    },\r\n  ]}\r\n/>\r\n",
      "excerpt": "Project settings live in. This file controls database options, AI providers, authentication, and build settings.",
      "category": "docs/configuration",
      "type": "reference",
      "tags": [
        "mongodb",
        "farm",
        "typescript",
        "authentication",
        "database"
      ],
      "lastModified": "2025-06-12T21:57:32.790Z",
      "breadcrumbs": [
        "Docs",
        "Configuration",
        "Index"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Configuration",
          "id": "configuration"
        },
        {
          "level": 2,
          "text": "Basic Configuration",
          "id": "basic-configuration"
        },
        {
          "level": 2,
          "text": "Environment Variables",
          "id": "environment-variables"
        },
        {
          "level": 1,
          "text": "Database",
          "id": "database"
        },
        {
          "level": 1,
          "text": "Authentication",
          "id": "authentication"
        },
        {
          "level": 1,
          "text": "AI Providers",
          "id": "ai-providers"
        },
        {
          "level": 2,
          "text": "Advanced Configuration",
          "id": "advanced-configuration"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-deployment-index",
      "title": "Index",
      "url": "/docs/deployment",
      "content": "# Deployment Guide\n\n<Callout type=\"info\" title=\"Production Ready\">\n  FARM applications are designed for easy deployment across multiple platforms\n  with built-in optimization and security features.\n</Callout>\n\n## Quick Deployment\n\nDeploy your FARM application with a single command:\n\n<CodeTabs examples={[\n  {\n    language: \"bash\",\n    label: \"Platform Deployment\",\n    code: `# Vercel (Recommended for small-medium apps)\nfarm deploy --platform vercel\n\n# AWS (Enterprise scale)\n\nfarm deploy --platform aws\n\n# Google Cloud Platform\n\nfarm deploy --platform gcp\n\n# Railway (Simple deployment)\n\nfarm deploy --platform railway\n\n# Docker (Self-hosted)\n\nfarm deploy --platform docker`  },\n  {\n    language: \"bash\",\n    label: \"Custom Configuration\",\n    code:`# Deploy with custom environment\nfarm deploy --platform vercel --env production\n\n# Deploy specific services only\n\nfarm deploy --platform aws --services api,web\n\n# Deploy with custom domain\n\nfarm deploy --platform vercel --domain myapp.com`\n}\n]} />\n\n## Docker Deployment\n\n### Auto-Generated Dockerfile\n\nFARM automatically generates optimized Docker configurations:\n\n<CodeTabs examples={[\n  {\n    language: \"dockerfile\",\n    label: \"Multi-Stage Dockerfile\",\n    code: `# Auto-generated multi-stage Dockerfile\nFROM node:18-alpine AS frontend-builder\nWORKDIR /app\nCOPY apps/web/package.json ./\nRUN npm install\nCOPY apps/web ./\nRUN npm run build\n\nFROM python:3.11-slim AS backend\nWORKDIR /app\n\n# Install Python dependencies\n\nCOPY apps/api/requirements.txt ./\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy backend code\n\nCOPY apps/api ./\n\n# Copy built frontend\n\nCOPY --from=frontend-builder /app/dist ./static\n\n# Expose port and run\n\nEXPOSE 8000\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]`\n}\n]} />\n\n### Docker Compose Setup\n\n<CodeTabs examples={[\n  {\n    language: \"yaml\",\n    label: \"Production Compose\",\n    code: `# docker-compose.prod.yml\nversion: '3.8'\n\nservices:\nweb:\nbuild: .\nports: - \"80:8000\"\nenvironment: - NODE_ENV=production - DATABASE_URL=mongodb://db:27017/farm_prod - OPENAI_API_KEY=\\${OPENAI_API_KEY} - JWT_SECRET=\\${JWT_SECRET}\ndepends_on: - db - redis\nrestart: unless-stopped\n\ndb:\nimage: mongo:7\nenvironment: - MONGO_INITDB_ROOT_USERNAME=\\${MONGO_USER} - MONGO_INITDB_ROOT_PASSWORD=\\${MONGO_PASSWORD}\nvolumes: - mongodb_data:/data/db\nrestart: unless-stopped\n\nredis:\nimage: redis:7-alpine\ncommand: redis-server --requirepass \\${REDIS_PASSWORD}\nvolumes: - redis_data:/data\nrestart: unless-stopped\n\n# Optional: Nginx reverse proxy\n\nnginx:\nimage: nginx:alpine\nports: - \"443:443\" - \"80:80\"\nvolumes: - ./nginx.conf:/etc/nginx/nginx.conf - ./ssl:/etc/nginx/ssl\ndepends_on: - web\nrestart: unless-stopped\n\nvolumes:\nmongodb_data:\nredis_data:`  },\n  {\n    language: \"bash\",\n    label: \"Deploy Commands\",\n    code:`# Build and deploy with Docker\nfarm docker build --production\n\n# Start production environment\n\ndocker-compose -f docker-compose.prod.yml up -d\n\n# Scale services\n\ndocker-compose -f docker-compose.prod.yml up -d --scale web=3\n\n# Monitor logs\n\ndocker-compose -f docker-compose.prod.yml logs -f web`\n}\n]} />\n\n## Cloud Platform Deployment\n\n### Vercel Deployment\n\nPerfect for frontend-heavy applications with serverless API:\n\n<CodeTabs examples={[\n  {\n    language: \"json\",\n    label: \"vercel.json\",\n    code: `{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"apps/web/package.json\",\n      \"use\": \"@vercel/static-build\",\n      \"config\": {\n        \"distDir\": \"dist\"\n      }\n    },\n    {\n      \"src\": \"apps/api/main.py\",\n      \"use\": \"@vercel/python\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/api/(.*)\",\n      \"dest\": \"apps/api/main.py\"\n    },\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"apps/web/dist/$1\"\n    }\n  ],\n  \"env\": {\n    \"DATABASE_URL\": \"@database-url\",\n    \"OPENAI_API_KEY\": \"@openai-api-key\"\n  }\n}`\n  },\n  {\n    language: \"bash\",\n    label: \"Deployment\",\n    code: `# Install Vercel CLI\nnpm install -g vercel\n\n# Deploy with FARM CLI\n\nfarm deploy --platform vercel\n\n# Or deploy manually\n\nvercel --prod\n\n# Set environment variables\n\nvercel env add DATABASE_URL\nvercel env add OPENAI_API_KEY`\n}\n]} />\n\n### AWS Deployment\n\nEnterprise-grade deployment with ECS and DocumentDB:\n\n<CodeTabs examples={[\n  {\n    language: \"yaml\",\n    label: \"AWS CDK Stack\",\n    code: `# Generated AWS CDK configuration\nResources:\n  # ECS Cluster\n  FarmCluster:\n    Type: AWS::ECS::Cluster\n    Properties:\n      ClusterName: farm-production\n\n# Application Load Balancer\n\nLoadBalancer:\nType: AWS::ElasticLoadBalancingV2::LoadBalancer\nProperties:\nType: application\nScheme: internet-facing\n\n# ECS Service\n\nWebService:\nType: AWS::ECS::Service\nProperties:\nCluster: !Ref FarmCluster\nTaskDefinition: !Ref WebTask\nDesiredCount: 2\n\n# DocumentDB Cluster\n\nDatabaseCluster:\nType: AWS::DocDB::DBCluster\nProperties:\nEngine: docdb\nMasterUsername: !Ref DBUsername\nMasterUserPassword: !Ref DBPassword`  },\n  {\n    language: \"bash\",\n    label: \"AWS Deployment\",\n    code:`# Deploy to AWS\nfarm deploy --platform aws --region us-east-1\n\n# With custom configuration\n\nfarm deploy --platform aws \\\\\n--cluster-size 3 \\\\\n--db-instance-class db.t3.medium \\\\\n--enable-auto-scaling`\n}\n]} />\n\n### Railway Deployment\n\nSimple, developer-friendly deployment:\n\n<CodeTabs examples={[\n  {\n    language: \"json\",\n    label: \"railway.json\",\n    code: `{\n  \"build\": {\n    \"builder\": \"nixpacks\"\n  },\n  \"deploy\": {\n    \"startCommand\": \"farm start --production\",\n    \"healthcheckPath\": \"/health\",\n    \"healthcheckTimeout\": 30\n  },\n  \"services\": [\n    {\n      \"name\": \"web\",\n      \"source\": \"./\",\n      \"variables\": {\n        \"NODE_ENV\": \"production\",\n        \"DATABASE_URL\": \"$\\{{MongoDB.DATABASE_URL}}\",\n        \"OPENAI_API_KEY\": \"$\\{{OPENAI_API_KEY}}\"\n      }\n    },\n    {\n      \"name\": \"mongodb\",\n      \"image\": \"mongo:7\",\n      \"variables\": {\n        \"MONGO_INITDB_ROOT_USERNAME\": \"$\\{{MONGO_USERNAME}}\",\n        \"MONGO_INITDB_ROOT_PASSWORD\": \"$\\{{MONGO_PASSWORD}}\"\n      }\n    }\n  ]\n}`\n  },\n  {\n    language: \"bash\",\n    label: \"Railway Commands\",\n    code: `# Install Railway CLI\nnpm install -g @railway/cli\n\n# Login and link project\n\nrailway login\nrailway link\n\n# Deploy with FARM CLI\n\nfarm deploy --platform railway\n\n# Monitor deployment\n\nrailway logs --service web`\n}\n]} />\n\n## Environment Configuration\n\n### Production Environment Variables\n\n<PropertyTable\n  properties={[\n    {\n      name: \"NODE_ENV\",\n      type: \"string\",\n      required: true,\n      description: \"Set to 'production' for production deployments\",\n    },\n    {\n      name: \"DATABASE_URL\",\n      type: \"string\",\n      required: true,\n      description: \"MongoDB connection string for production database\",\n    },\n    {\n      name: \"OPENAI_API_KEY\",\n      type: \"string\",\n      required: false,\n      description: \"OpenAI API key for AI features (if using OpenAI provider)\",\n    },\n    {\n      name: \"JWT_SECRET\",\n      type: \"string\",\n      required: true,\n      description:\n        \"Secret key for JWT token signing (use strong random string)\",\n    },\n    {\n      name: \"CORS_ORIGINS\",\n      type: \"string\",\n      required: false,\n      description: \"Comma-separated list of allowed CORS origins\",\n    },\n    {\n      name: \"REDIS_URL\",\n      type: \"string\",\n      required: false,\n      description: \"Redis connection string for caching and sessions\",\n    },\n  ]}\n/>\n\n### Environment-Specific Configuration\n\n<CodeTabs examples={[\n  {\n    language: \"typescript\",\n    label: \"farm.config.production.ts\",\n    code: `import { defineConfig } from \"@farm/core\";\n\nexport default defineConfig({\n  name: \"my-farm-app\",\n  \n  // Production AI configuration\n  ai: {\n    providers: {\n      openai: {\n        enabled: true,\n        apiKey: process.env.OPENAI_API_KEY,\n        defaultModel: \"gpt-3.5-turbo\",\n        rateLimit: {\n          requests: 100,\n          window: \"1m\"\n        }\n      },\n      ollama: {\n        enabled: false // Disable local models in production\n      }\n    },\n    routing: {\n      production: \"openai\"\n    }\n  },\n\n// Production database\ndatabase: {\ntype: \"mongodb\",\nurl: process.env.DATABASE_URL,\npool: {\nminSize: 5,\nmaxSize: 20\n}\n},\n\n// Production security\nsecurity: {\ncors: {\norigins: process.env.CORS_ORIGINS?.split(\",\") || [],\ncredentials: true\n},\nrateLimit: {\nenabled: true,\nmax: 100,\nwindowMs: 60000\n}\n},\n\n// Production performance\nperformance: {\ncache: {\nenabled: true,\nttl: 3600,\nredis: process.env.REDIS_URL\n},\ncompression: true,\nstaticAssets: {\nmaxAge: \"1y\",\nimmutable: true\n}\n}\n});`\n}\n]} />\n\n## Production Optimizations\n\n### Performance Optimizations\n\n<FeatureList\n  features={[\n    {\n      title: \"Automatic Code Splitting\",\n      description:\n        \"Route-based and component-based splitting for optimal loading\",\n      icon: \"⚡\",\n    },\n    {\n      title: \"API Response Caching\",\n      description:\n        \"Redis integration for response caching and session management\",\n      icon: \"💾\",\n    },\n    {\n      title: \"CDN Integration\",\n      description:\n        \"Automatic static asset optimization and global distribution\",\n      icon: \"🌍\",\n    },\n    {\n      title: \"Database Optimization\",\n      description: \"Connection pooling, indexing, and query optimization\",\n      icon: \"🗄️\",\n    },\n  ]}\n/>\n\n### Security Hardening\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"Security Configuration\",\n    code: `# apps/api/src/core/security.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\nfrom fastapi_limiter import FastAPILimiter\nimport redis.asyncio as redis\n\nasync def configure_security(app: FastAPI): # CORS configuration\napp.add_middleware(\nCORSMiddleware,\nallow_origins=[\"https://yourdomain.com\"],\nallow_credentials=True,\nallow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\nallow_headers=[\"*\"],\n)\n\n    # Trusted host middleware\n    app.add_middleware(\n        TrustedHostMiddleware,\n        allowed_hosts=[\"yourdomain.com\", \"*.yourdomain.com\"]\n    )\n\n    # Rate limiting\n    redis_client = redis.from_url(\"redis://localhost:6379\")\n    await FastAPILimiter.init(redis_client)\n\n    # Security headers\n    @app.middleware(\"http\")\n    async def add_security_headers(request, call_next):\n        response = await call_next(request)\n        response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n        response.headers[\"X-Frame-Options\"] = \"DENY\"\n        response.headers[\"X-XSS-Protection\"] = \"1; mode=block\"\n        return response`\n\n}\n]} />\n\n## Monitoring & Observability\n\n### Health Checks\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"Health Check Endpoint\",\n    code: `# Automatic health check generation\nfrom fastapi import FastAPI\nfrom farm.monitoring import health_check\n\n@app.get(\"/health\")\nasync def health():\nreturn await health_check({\n\"database\": check_mongodb_connection,\n\"redis\": check_redis_connection,\n\"ai_providers\": check_ai_providers,\n\"disk_space\": check_disk_space,\n\"memory\": check_memory_usage\n})`  },\n  {\n    language: \"json\",\n    label: \"Health Response\",\n    code:`{\n\"status\": \"healthy\",\n\"timestamp\": \"2024-01-15T10:30:00Z\",\n\"services\": {\n\"database\": {\n\"status\": \"healthy\",\n\"response_time\": \"2ms\"\n},\n\"redis\": {\n\"status\": \"healthy\",\n\"response_time\": \"1ms\"\n},\n\"ai_providers\": {\n\"openai\": {\n\"status\": \"healthy\",\n\"models_available\": [\"gpt-3.5-turbo\", \"gpt-4\"]\n}\n}\n},\n\"system\": {\n\"memory_usage\": \"45%\",\n\"disk_space\": \"20%\",\n\"cpu_usage\": \"12%\"\n}\n}`\n}\n]} />\n\n### Logging & Metrics\n\n<CodeTabs examples={[\n  {\n    language: \"python\",\n    label: \"Structured Logging\",\n    code: `# Automatic structured logging\nimport structlog\nfrom farm.monitoring import setup_logging\n\n# Configure structured logging\n\nlogger = structlog.get_logger()\n\n@app.middleware(\"http\")\nasync def log_requests(request, call_next):\nstart_time = time.time()\n\n    response = await call_next(request)\n\n    process_time = time.time() - start_time\n    logger.info(\n        \"request_completed\",\n        method=request.method,\n        url=str(request.url),\n        status_code=response.status_code,\n        process_time=process_time,\n        user_agent=request.headers.get(\"user-agent\")\n    )`\n\n}\n]} />\n\n## Deployment Checklist\n\n### Pre-Deployment\n\n<div className=\"space-y-2\">\n\n- [ ] **Environment Variables**: All required environment variables configured\n- [ ] **Database**: Production database setup and migrations applied\n- [ ] **AI Providers**: API keys configured and tested\n- [ ] **Security**: CORS, rate limiting, and security headers configured\n- [ ] **Testing**: All tests passing in production-like environment\n- [ ] **Performance**: Load testing completed\n- [ ] **Monitoring**: Health checks and logging configured\n\n</div>\n\n### Post-Deployment\n\n<div className=\"space-y-2\">\n\n- [ ] **Health Check**: Verify `/health` endpoint responds correctly\n- [ ] **Database Connection**: Confirm database connectivity\n- [ ] **AI Services**: Test AI provider connectivity\n- [ ] **Static Assets**: Verify static files load correctly\n- [ ] **API Functionality**: Test critical API endpoints\n- [ ] **Frontend**: Confirm frontend loads and functions\n- [ ] **Monitoring**: Set up alerts and monitoring dashboards\n\n</div>\n\n---\n\n<Note>\n  For enterprise deployments, consider our [Enterprise Support](/enterprise) for\n  dedicated assistance with scaling, security, and compliance requirements.\n</Note>\n",
      "excerpt": "<Callout type=\"info\" title=\"Production Ready\">\n  FARM applications are designed for easy deployment across multiple platforms\n  with built-in optimization and s...",
      "category": "docs/deployment",
      "type": "reference",
      "tags": [
        "fastapi",
        "mongodb",
        "farm",
        "typescript",
        "python"
      ],
      "lastModified": "2025-06-12T21:57:32.790Z",
      "breadcrumbs": [
        "Docs",
        "Deployment",
        "Index"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Deployment Guide",
          "id": "deployment-guide"
        },
        {
          "level": 2,
          "text": "Quick Deployment",
          "id": "quick-deployment"
        },
        {
          "level": 1,
          "text": "AWS (Enterprise scale)",
          "id": "aws-enterprise-scale"
        },
        {
          "level": 1,
          "text": "Google Cloud Platform",
          "id": "google-cloud-platform"
        },
        {
          "level": 1,
          "text": "Railway (Simple deployment)",
          "id": "railway-simple-deployment"
        },
        {
          "level": 1,
          "text": "Docker (Self-hosted)",
          "id": "docker-self-hosted"
        },
        {
          "level": 1,
          "text": "Deploy specific services only",
          "id": "deploy-specific-services-only"
        },
        {
          "level": 1,
          "text": "Deploy with custom domain",
          "id": "deploy-with-custom-domain"
        },
        {
          "level": 2,
          "text": "Docker Deployment",
          "id": "docker-deployment"
        },
        {
          "level": 3,
          "text": "Auto-Generated Dockerfile",
          "id": "auto-generated-dockerfile"
        },
        {
          "level": 1,
          "text": "Install Python dependencies",
          "id": "install-python-dependencies"
        },
        {
          "level": 1,
          "text": "Copy backend code",
          "id": "copy-backend-code"
        },
        {
          "level": 1,
          "text": "Copy built frontend",
          "id": "copy-built-frontend"
        },
        {
          "level": 1,
          "text": "Expose port and run",
          "id": "expose-port-and-run"
        },
        {
          "level": 3,
          "text": "Docker Compose Setup",
          "id": "docker-compose-setup"
        },
        {
          "level": 1,
          "text": "Optional: Nginx reverse proxy",
          "id": "optional-nginx-reverse-proxy"
        },
        {
          "level": 1,
          "text": "Start production environment",
          "id": "start-production-environment"
        },
        {
          "level": 1,
          "text": "Scale services",
          "id": "scale-services"
        },
        {
          "level": 1,
          "text": "Monitor logs",
          "id": "monitor-logs"
        },
        {
          "level": 2,
          "text": "Cloud Platform Deployment",
          "id": "cloud-platform-deployment"
        },
        {
          "level": 3,
          "text": "Vercel Deployment",
          "id": "vercel-deployment"
        },
        {
          "level": 1,
          "text": "Deploy with FARM CLI",
          "id": "deploy-with-farm-cli"
        },
        {
          "level": 1,
          "text": "Or deploy manually",
          "id": "or-deploy-manually"
        },
        {
          "level": 1,
          "text": "Set environment variables",
          "id": "set-environment-variables"
        },
        {
          "level": 3,
          "text": "AWS Deployment",
          "id": "aws-deployment"
        },
        {
          "level": 1,
          "text": "Application Load Balancer",
          "id": "application-load-balancer"
        },
        {
          "level": 1,
          "text": "ECS Service",
          "id": "ecs-service"
        },
        {
          "level": 1,
          "text": "DocumentDB Cluster",
          "id": "documentdb-cluster"
        },
        {
          "level": 1,
          "text": "With custom configuration",
          "id": "with-custom-configuration"
        },
        {
          "level": 3,
          "text": "Railway Deployment",
          "id": "railway-deployment"
        },
        {
          "level": 1,
          "text": "Login and link project",
          "id": "login-and-link-project"
        },
        {
          "level": 1,
          "text": "Deploy with FARM CLI",
          "id": "deploy-with-farm-cli"
        },
        {
          "level": 1,
          "text": "Monitor deployment",
          "id": "monitor-deployment"
        },
        {
          "level": 2,
          "text": "Environment Configuration",
          "id": "environment-configuration"
        },
        {
          "level": 3,
          "text": "Production Environment Variables",
          "id": "production-environment-variables"
        },
        {
          "level": 3,
          "text": "Environment-Specific Configuration",
          "id": "environment-specific-configuration"
        },
        {
          "level": 2,
          "text": "Production Optimizations",
          "id": "production-optimizations"
        },
        {
          "level": 3,
          "text": "Performance Optimizations",
          "id": "performance-optimizations"
        },
        {
          "level": 3,
          "text": "Security Hardening",
          "id": "security-hardening"
        },
        {
          "level": 2,
          "text": "Monitoring & Observability",
          "id": "monitoring-observability"
        },
        {
          "level": 3,
          "text": "Health Checks",
          "id": "health-checks"
        },
        {
          "level": 3,
          "text": "Logging & Metrics",
          "id": "logging-metrics"
        },
        {
          "level": 1,
          "text": "Configure structured logging",
          "id": "configure-structured-logging"
        },
        {
          "level": 2,
          "text": "Deployment Checklist",
          "id": "deployment-checklist"
        },
        {
          "level": 3,
          "text": "Pre-Deployment",
          "id": "pre-deployment"
        },
        {
          "level": 3,
          "text": "Post-Deployment",
          "id": "post-deployment"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-deployment-README",
      "title": "README",
      "url": "/docs/deployment/README",
      "content": "# Deployment\r\n\r\nStrategies for deploying FARM applications to cloud platforms or on-premises environments.\r\n",
      "excerpt": "Strategies for deploying FARM applications to cloud platforms or on-premises environments. .",
      "category": "docs/deployment",
      "type": "reference",
      "tags": [
        "farm",
        "deployment"
      ],
      "lastModified": "2025-06-12T21:57:32.790Z",
      "breadcrumbs": [
        "Docs",
        "Deployment",
        "README"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Deployment",
          "id": "deployment"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-docs-overview",
      "title": "Docs Overview",
      "url": "/docs/docs-overview",
      "content": "# FARM Documentation Overview\r\n\r\nThe documentation is organized for use with a static site generator.\r\n\r\n- [Guide](guide/getting-started.md)\r\n  - [Development Server](guide/dev-server.md)\r\n  - [AI Integration](guide/ai-integration.md)\r\n  - [Database](guide/database.md)\r\n  - [Code Generation](guide/code-generation.md)\r\n  - [Plugin System](guide/plugin-system.md)\r\n- [Configuration](configuration/index.md)\r\n- [API Reference](api/cli.md)\r\n- [Deployment](deployment/index.md)\r\n- [Advanced Topics](advanced/performance.md)\r\n  - [Testing](advanced/testing.md)\r\n  - [Security](advanced/security.md)\r\n  - [Documentation System](advanced/documentation-system.md)\r\n- [Community](community/index.md)\r\n- [Migration](migration/index.md)\r\n",
      "excerpt": "The documentation is organized for use with a static site generator.",
      "category": "docs",
      "type": "reference",
      "tags": [
        "farm",
        "database",
        "api",
        "deployment",
        "configuration"
      ],
      "lastModified": "2025-06-12T21:57:32.791Z",
      "breadcrumbs": [
        "Docs",
        "Docs Overview"
      ],
      "headings": [
        {
          "level": 1,
          "text": "FARM Documentation Overview",
          "id": "farm-documentation-overview"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-getting-started",
      "title": "Getting Started",
      "url": "/docs/getting-started",
      "content": "\r\nimport { Alert, AlertTitle, AlertDescription } from \"@/components/ui/alert\";\r\n\r\n# Getting Started\r\n\r\nGet up and running with the FARM Stack Framework in minutes. FARM combines the power of **F**astAPI, **A**I tooling, **R**eact, and **M**ongoDB into a unified full-stack platform.\r\n\r\n<Alert>\r\n  <AlertTitle>Prerequisites</AlertTitle>\r\n  <AlertDescription>\r\n    Make sure you have Node.js 18+ and Python 3.9+ installed.\r\n  </AlertDescription>\r\n</Alert>\r\n\r\n## Installation\r\n\r\n<Step number={1} title=\"Install the CLI\">\r\n\r\nInstall the FARM CLI using your preferred package manager:\r\n\r\n<CodeTabs\r\n  examples={[\r\n    {\r\n      language: \"bash\",\r\n      label: \"npm\",\r\n      code: `npm install -g @farm/cli`,\r\n    },\r\n    {\r\n      language: \"bash\",\r\n      label: \"pnpm\",\r\n      code: `pnpm add -g @farm/cli`,\r\n    },\r\n    {\r\n      language: \"bash\",\r\n      label: \"yarn\",\r\n      code: `yarn global add @farm/cli`,\r\n    },\r\n  ]}\r\n/>\r\n\r\n</Step>\r\n\r\n<Step number={2} title=\"Create Your First Project\">\r\n\r\nCreate a new FARM project with our interactive CLI:\r\n\r\n```bash\r\nfarm create my-farm-app\r\n```\r\n\r\nYou'll be prompted to choose your project template:\r\n\r\n- **Starter** - Basic FARM setup with authentication\r\n- **AI-Powered** - Includes Ollama integration and ML pipelines\r\n- **Enterprise** - Full-featured with advanced security and monitoring\r\n\r\n</Step>\r\n\r\n<Step number={3} title=\"Navigate and Install Dependencies\">\r\n\r\n```bash\r\ncd my-farm-app\r\nnpm install\r\n```\r\n\r\n</Step>\r\n\r\n<Step number={4} title=\"Start Development\">\r\n\r\nLaunch both frontend and backend in development mode:\r\n\r\n```bash\r\nnpm run dev\r\n```\r\n\r\nThis starts:\r\n\r\n- **Frontend** at `http://localhost:3000` (React + Vite)\r\n- **Backend** at `http://localhost:8000` (FastAPI)\r\n- **API Docs** at `http://localhost:8000/docs` (Swagger UI)\r\n\r\n</Step>\r\n\r\n## Project Structure\r\n\r\nYour new FARM project follows a monorepo structure:\r\n\r\n```\r\nmy-farm-app/\r\n├── frontend/          # React TypeScript app\r\n│   ├── src/\r\n│   ├── public/\r\n│   └── package.json\r\n├── backend/           # FastAPI Python app\r\n│   ├── app/\r\n│   ├── requirements.txt\r\n│   └── main.py\r\n├── shared/            # Shared types and utilities\r\n├── farm.config.ts     # FARM configuration\r\n└── package.json       # Root package.json\r\n```\r\n\r\n## Next Steps\r\n\r\n<FeatureList\r\n  features={[\r\n    {\r\n      name: \"Configure Database\",\r\n      included: true,\r\n      description: \"Set up MongoDB or your preferred database\",\r\n    },\r\n    {\r\n      name: \"Add Authentication\",\r\n      included: true,\r\n      description: \"Implement user auth with built-in providers\",\r\n    },\r\n    {\r\n      name: \"Integrate AI Features\",\r\n      included: true,\r\n      description: \"Add Ollama or OpenAI for intelligent features\",\r\n    },\r\n    {\r\n      name: \"Deploy to Production\",\r\n      included: true,\r\n      description: \"Deploy with Docker or serverless platforms\",\r\n    },\r\n  ]}\r\n/>\r\n\r\nReady to dive deeper? Check out our [Configuration Guide](/docs/configuration) or explore [AI Integration](/docs/guide/ai-integration).\r\n",
      "excerpt": "import { Alert, AlertTitle, AlertDescription } from \"@/components/ui/alert\";\r\n\r\n\r\n\r\nGet up and running with the FARM Stack Framework in minutes.",
      "category": "docs",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.792Z",
      "breadcrumbs": [
        "Docs",
        "Getting Started"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Getting Started",
          "id": "getting-started"
        },
        {
          "level": 2,
          "text": "Installation",
          "id": "installation"
        },
        {
          "level": 2,
          "text": "Project Structure",
          "id": "project-structure"
        },
        {
          "level": 2,
          "text": "Next Steps",
          "id": "next-steps"
        }
      ],
      "sidebarTitle": "Getting Started",
      "icon": "rocket",
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-guide-ai-integration",
      "title": "Ai Integration",
      "url": "/docs/guide/ai-integration",
      "content": "# AI/ML Integration\r\n\r\nFARM provides first-class AI support with a unified provider abstraction layer. Seamlessly switch between local development with Ollama and production deployments with OpenAI, Anthropic, or HuggingFace.\r\n\r\n<Callout type=\"success\" title=\"AI-First Architecture\">\r\n  Built-in GPU support, model inference, streaming responses, and ML pipeline\r\n  integration out of the box.\r\n</Callout>\r\n\r\n## Provider Architecture\r\n\r\nThe AI system uses a provider pattern that allows transparent switching between different AI services:\r\n\r\n```mermaid\r\ngraph LR\r\n    A[FARM App] --> B[AI Provider Interface]\r\n    B --> C[Ollama Provider]\r\n    B --> D[OpenAI Provider]\r\n    B --> E[HuggingFace Provider]\r\n    C --> F[Local Models]\r\n    D --> G[GPT Models]\r\n    E --> H[Open Source Models]\r\n```\r\n\r\n## Backend Integration\r\n\r\n### Multi-Provider Setup\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Provider Configuration\", \r\n    code: `# farm.config.ts\r\nexport default defineConfig({\r\n  ai: {\r\n    provider: 'ollama', // 'ollama' | 'openai' | 'anthropic' | 'huggingface'\r\n    models: ['llama3.2', 'codellama'],\r\n    fallback: 'openai', // Fallback provider\r\n    settings: {\r\n      temperature: 0.7,\r\n      maxTokens: 1000,\r\n      streaming: true\r\n    }\r\n  }\r\n});`\r\n  },\r\n  {\r\n    language: \"python\",\r\n    label: \"Python Backend\",\r\n    code: `# Multi-provider AI integration\r\nfrom farm.ai import AIProvider, ChatMessage\r\n\r\n# Get configured provider (Ollama in dev, OpenAI in prod)\r\n\r\nprovider = AIProvider.get_default()\r\n\r\n@app.post(\"/chat\")\r\nasync def chat_endpoint(request: ChatRequest):\r\nresponse = await provider.chat([\r\nChatMessage(role=\"user\", content=request.message)\r\n], model=request.model or \"llama3.2\")\r\n\r\n    return {\"response\": response}\r\n\r\n# Streaming chat endpoint\r\n\r\n@app.post(\"/chat/stream\")\r\nasync def streaming_chat(request: ChatRequest):\r\nasync def generate():\r\nasync for chunk in provider.stream_chat(\r\nrequest.messages,\r\nmodel=request.model\r\n):\r\nyield f\"data: {chunk.json()}\\\\n\\\\n\"\r\n\r\n    return StreamingResponse(generate(), media_type=\"text/plain\")`\r\n\r\n}\r\n]} />\r\n\r\n### Provider-Specific Usage\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Ollama (Local)\",\r\n    code: `# Ollama provider for local development\r\nfrom farm.ai import OllamaProvider\r\n\r\nollama = OllamaProvider()\r\n\r\n# Chat completion\r\n\r\nresponse = await ollama.chat([\r\nChatMessage(role=\"user\", content=\"Hello!\")\r\n], model=\"llama3.2\")\r\n\r\n# Check available models\r\n\r\nmodels = await ollama.list_models()\r\nprint([model.name for model in models])\r\n\r\n# Pull new model\r\n\r\nawait ollama.pull_model(\"codellama\")`  },\r\n  {\r\n    language: \"python\", \r\n    label: \"OpenAI (Production)\",\r\n    code:`# OpenAI provider for production\r\nfrom farm.ai import OpenAIProvider\r\n\r\nopenai = OpenAIProvider(api_key=os.getenv(\"OPENAI_API_KEY\"))\r\n\r\n# Chat completion\r\n\r\nresponse = await openai.chat([\r\nChatMessage(role=\"user\", content=\"Hello!\")\r\n], model=\"gpt-4\")\r\n\r\n# Function calling\r\n\r\nresponse = await openai.chat(\r\nmessages=[ChatMessage(role=\"user\", content=\"What's the weather?\")],\r\nfunctions=[get_weather_function],\r\nmodel=\"gpt-4\"\r\n)`\r\n}\r\n]} />\r\n\r\n## Frontend Integration\r\n\r\n### React Hooks\r\n\r\nFARM provides type-safe React hooks for AI operations:\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Streaming Chat\",\r\n    code: `import { useStreamingChat, useAIModels } from \"@farm/ai-hooks\";\r\n\r\nfunction ChatComponent() {\r\nconst {\r\nmessages,\r\nsendMessage,\r\nisStreaming,\r\nerror\r\n} = useStreamingChat({\r\nprovider: \"ollama\", // Auto-switches based on environment\r\nmodel: \"llama3.2\",\r\nonMessage: (message) => {\r\nconsole.log(\"New message:\", message);\r\n},\r\nonError: (error) => {\r\nconsole.error(\"Chat error:\", error);\r\n}\r\n});\r\n\r\nconst { data: models, isLoading } = useAIModels(\"ollama\");\r\n\r\nreturn (\r\n<div className=\"chat-container\">\r\n<ModelSelector \r\n        models={models} \r\n        loading={isLoading}\r\n        onChange={setSelectedModel}\r\n      />\r\n<ChatMessages messages={messages} />\r\n<ChatInput\r\nonSend={sendMessage}\r\ndisabled={isStreaming}\r\nplaceholder={isStreaming ? \"AI is typing...\" : \"Type a message...\"}\r\n/>\r\n{error && <ErrorBanner error={error} />}\r\n</div>\r\n);\r\n}`  },\r\n  {\r\n    language: \"typescript\",\r\n    label: \"AI Completion\",\r\n    code:`import { useAICompletion, useAIHealth } from \"@farm/ai-hooks\";\r\n\r\nfunction CodeEditor() {\r\nconst {\r\ncomplete,\r\ncompletion,\r\nisLoading\r\n} = useAICompletion({\r\nprovider: \"ollama\",\r\nmodel: \"codellama\"\r\n});\r\n\r\nconst { data: health } = useAIHealth();\r\n\r\nconst handleCompletion = async (prompt: string) => {\r\nconst result = await complete({\r\nprompt,\r\nmaxTokens: 500,\r\ntemperature: 0.2\r\n});\r\nreturn result;\r\n};\r\n\r\nreturn (\r\n<div>\r\n<div className=\"status\">\r\nOllama: {health?.ollama?.status}\r\nOpenAI: {health?.openai?.status}  \r\n </div>\r\n<CodeMirror \r\n        onComplete={handleCompletion}\r\n        completion={completion}\r\n        loading={isLoading}\r\n      />\r\n</div>\r\n);\r\n}`\r\n}\r\n]} />\r\n\r\n### WebSocket Streaming\r\n\r\nFor real-time AI responses, FARM provides WebSocket integration:\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"WebSocket Client\",\r\n    code: `import { useAIWebSocket } from \"@farm/ai-hooks\";\r\n\r\nfunction RealtimeChat() {\r\nconst {\r\nsendMessage,\r\nmessages,\r\nconnectionStatus,\r\nlastMessage\r\n} = useAIWebSocket({\r\nurl: \"/ws/chat\",\r\nprovider: \"ollama\",\r\nmodel: \"llama3.2\"\r\n});\r\n\r\nuseEffect(() => {\r\nif (lastMessage?.type === \"ai_response\") {\r\n// Handle streaming AI response\r\nconsole.log(\"AI:\", lastMessage.content);\r\n}\r\n}, [lastMessage]);\r\n\r\nreturn (\r\n<div>\r\n<ConnectionStatus status={connectionStatus} />\r\n<ChatWindow messages={messages} />\r\n<MessageInput onSend={sendMessage} />\r\n</div>\r\n);\r\n}`  },\r\n  {\r\n    language: \"python\",\r\n    label: \"WebSocket Backend\", \r\n    code:`from fastapi import WebSocket\r\nfrom farm.ai import AIProvider\r\n\r\n@app.websocket(\"/ws/chat\")\r\nasync def websocket_chat(websocket: WebSocket):\r\nawait websocket.accept()\r\nprovider = AIProvider.get_default()\r\n\r\n    try:\r\n        while True:\r\n            # Receive message from client\r\n            data = await websocket.receive_json()\r\n            message = data[\"message\"]\r\n\r\n            # Stream AI response\r\n            async for chunk in provider.stream_chat([\r\n                ChatMessage(role=\"user\", content=message)\r\n            ], model=\"llama3.2\"):\r\n                await websocket.send_json({\r\n                    \"type\": \"ai_response\",\r\n                    \"content\": chunk.content,\r\n                    \"done\": chunk.done\r\n                })\r\n\r\n    except WebSocketDisconnect:\r\n        print(\"Client disconnected\")`\r\n\r\n}\r\n]} />\r\n\r\n## Local Development with Ollama\r\n\r\n### Automatic Model Management\r\n\r\n<Step number={1} title=\"Configuration\">\r\n\r\nConfigure models in your `farm.config.ts`:\r\n\r\n```typescript\r\nexport default defineConfig({\r\n  ai: {\r\n    provider: \"ollama\",\r\n    models: [\"llama3.2\", \"codellama\", \"llama3.2-vision\"],\r\n    autoStart: true, // Start Ollama with dev server\r\n    pullOnStart: true, // Download models if missing\r\n  },\r\n});\r\n```\r\n\r\n</Step>\r\n\r\n<Step number={2} title=\"Development Server\">\r\n\r\nStart development with automatic Ollama setup:\r\n\r\n```bash\r\nfarm dev\r\n# ✓ Starting Ollama service...\r\n# ✓ Pulling llama3.2...\r\n# ✓ Pulling codellama...\r\n# ✓ Models ready for inference\r\n# ✓ Frontend: http://localhost:3000\r\n# ✓ Backend: http://localhost:8000\r\n# ✓ Ollama: http://localhost:11434\r\n```\r\n\r\n</Step>\r\n\r\n### GPU Detection & Configuration\r\n\r\n<FeatureList\r\n  features={[\r\n    {\r\n      name: \"Automatic GPU Detection\",\r\n      description:\r\n        \"Framework detects available NVIDIA GPUs and configures Ollama accordingly\",\r\n      icon: \"🎯\",\r\n    },\r\n    {\r\n      name: \"Memory Management\",\r\n      description: \"Intelligent GPU memory allocation across multiple models\",\r\n      icon: \"🧠\",\r\n    },\r\n    {\r\n      name: \"CPU Fallback\",\r\n      description: \"Graceful degradation to CPU when GPU unavailable\",\r\n      icon: \"🔄\",\r\n    },\r\n    {\r\n      name: \"Model Hot-Swap\",\r\n      description: \"Update ML models without server restart\",\r\n      icon: \"🔥\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n## Production Deployment\r\n\r\n### Environment-Based Provider Switching\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Environment Config\",\r\n    code: `// farm.config.ts\r\nexport default defineConfig({\r\n  ai: {\r\n    // Development: Use Ollama locally\r\n    provider: process.env.NODE_ENV === 'development' ? 'ollama' : 'openai',\r\n    \r\n    // Production: Use OpenAI\r\n    openai: {\r\n      apiKey: process.env.OPENAI_API_KEY,\r\n      organization: process.env.OPENAI_ORG_ID\r\n    },\r\n    \r\n    // Fallback configuration\r\n    fallback: {\r\n      provider: 'anthropic',\r\n      apiKey: process.env.ANTHROPIC_API_KEY\r\n    }\r\n  }\r\n});`\r\n  },\r\n  {\r\n    language: \"python\",\r\n    label: \"Provider Routing\",\r\n    code: `# Automatic provider routing\r\nprovider = AIProvider.get_default()  # Returns correct provider for environment\r\n\r\n# Manual provider selection\r\n\r\nif os.getenv(\"AI_PROVIDER\") == \"openai\":\r\nprovider = AIProvider.get(\"openai\")\r\nelif os.getenv(\"AI_PROVIDER\") == \"anthropic\":\r\nprovider = AIProvider.get(\"anthropic\")\r\nelse:\r\nprovider = AIProvider.get(\"ollama\") # Default to local`\r\n}\r\n]} />\r\n\r\n### Deployment Configurations\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"yaml\",\r\n    label: \"Docker Compose\",\r\n    code: `# docker-compose.yml\r\nversion: '3.8'\r\nservices:\r\n  api:\r\n    build: ./apps/api\r\n    environment:\r\n      - AI_PROVIDER=openai\r\n      - OPENAI_API_KEY=\\${OPENAI_API_KEY}\r\n    depends_on:\r\n      - mongodb\r\n\r\nweb:\r\nbuild: ./apps/web\r\nenvironment: - VITE_API_URL=http://api:8000 - VITE_AI_PROVIDER=openai\r\n\r\n# Ollama service for local development\r\n\r\nollama:\r\nimage: ollama/ollama:latest\r\nports: - \"11434:11434\"\r\nvolumes: - ollama_data:/root/.ollama\r\nprofiles: - development`  },\r\n  {\r\n    language: \"yaml\", \r\n    label: \"Kubernetes\",\r\n    code:`# k8s-deployment.yml\r\napiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\nname: farm-api\r\nspec:\r\ntemplate:\r\nspec:\r\ncontainers: - name: api\r\nimage: farm-api:latest\r\nenv: - name: AI_PROVIDER\r\nvalue: \"openai\" - name: OPENAI_API_KEY\r\nvalueFrom:\r\nsecretKeyRef:\r\nname: ai-secrets\r\nkey: openai-api-key`\r\n}\r\n]} />\r\n\r\n## Advanced Features\r\n\r\n### Function Calling\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Backend Functions\",\r\n    code: `from farm.ai import function_definition\r\n\r\n@function_definition\r\nasync def get_weather(location: str, unit: str = \"celsius\") -> dict:\r\n\"\"\"Get current weather for a location.\"\"\" # Your weather API integration\r\nreturn {\"temperature\": 22, \"condition\": \"sunny\"}\r\n\r\n@app.post(\"/chat/functions\")\r\nasync def chat_with_functions(request: ChatRequest):\r\nprovider = AIProvider.get_default()\r\n\r\n    response = await provider.chat(\r\n        messages=request.messages,\r\n        functions=[get_weather],\r\n        model=\"gpt-4\"\r\n    )\r\n\r\n    return response`\r\n\r\n},\r\n{\r\nlanguage: \"typescript\",\r\nlabel: \"Frontend Integration\",\r\ncode: `import { useFunctionCalling } from \"@farm/ai-hooks\";\r\n\r\nfunction WeatherChat() {\r\nconst {\r\nsendMessage,\r\nmessages,\r\nisLoading\r\n} = useFunctionCalling({\r\nprovider: \"openai\",\r\nmodel: \"gpt-4\",\r\nfunctions: [\"get_weather\", \"get_forecast\"],\r\nonFunctionCall: (name, args, result) => {\r\nconsole.log(\\`Function \\${name} called with\\`, args, \\`result:\\`, result);\r\n}\r\n});\r\n\r\nreturn (\r\n<ChatInterface \r\n      messages={messages}\r\n      onSend={sendMessage}\r\n      loading={isLoading}\r\n      showFunctionCalls={true}\r\n    />\r\n);\r\n}`\r\n}\r\n]} />\r\n\r\n### Vector Operations\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Embeddings & Search\",\r\n    code: `from farm.ai import EmbeddingProvider\r\nfrom farm.database import VectorIndex\r\n\r\n# Generate embeddings\r\n\r\nembedding_provider = EmbeddingProvider.get_default()\r\nembeddings = await embedding_provider.embed([\r\n\"Document content 1\",\r\n\"Document content 2\"\r\n])\r\n\r\n# Vector search with MongoDB\r\n\r\nvector_index = VectorIndex(\"documents\")\r\nresults = await vector_index.search(\r\nquery_embedding=embeddings[0],\r\nlimit=10,\r\nthreshold=0.8\r\n)\r\n\r\n# Hybrid search (text + vector)\r\n\r\nhybrid_results = await vector_index.hybrid_search(\r\ntext_query=\"machine learning\",\r\nvector_query=embeddings[0],\r\nweights={\"text\": 0.3, \"vector\": 0.7}\r\n)`\r\n}\r\n]} />\r\n\r\n<Warning>\r\n  Vector operations require MongoDB Atlas or a local MongoDB instance with\r\n  vector search enabled.\r\n</Warning>\r\n\r\n## Performance & Monitoring\r\n\r\n### AI Health Monitoring\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Health Checks\",\r\n    code: `from farm.ai import AIHealthMonitor\r\n\r\n@app.get(\"/health/ai\")\r\nasync def ai_health():\r\nmonitor = AIHealthMonitor()\r\n\r\n    return {\r\n        \"ollama\": await monitor.check_ollama(),\r\n        \"openai\": await monitor.check_openai(),\r\n        \"models\": await monitor.list_available_models(),\r\n        \"gpu\": await monitor.gpu_status()\r\n    }`\r\n\r\n},\r\n{\r\nlanguage: \"typescript\",\r\nlabel: \"Frontend Monitoring\",\r\ncode: `import { useAIHealth } from \"@farm/ai-hooks\";\r\n\r\nfunction AIStatusDashboard() {\r\nconst { data: health, refetch } = useAIHealth({\r\nrefetchInterval: 30000 // Check every 30 seconds\r\n});\r\n\r\nreturn (\r\n<div className=\"ai-status\">\r\n<StatusCard \r\n        title=\"Ollama\"\r\n        status={health?.ollama?.status}\r\n        models={health?.ollama?.models}\r\n      />\r\n<StatusCard\r\n        title=\"OpenAI\" \r\n        status={health?.openai?.status}\r\n        quota={health?.openai?.quota}\r\n      />\r\n<GPUCard gpu={health?.gpu} />\r\n</div>\r\n);\r\n}`\r\n}\r\n]} />\r\n\r\n<Info>\r\n  FARM automatically monitors AI provider health and provides detailed metrics\r\n  for debugging and optimization.\r\n</Info>\r\n",
      "excerpt": "FARM provides first-class AI support with a unified provider abstraction layer.",
      "category": "docs/guide",
      "type": "guide",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.793Z",
      "breadcrumbs": [
        "Docs",
        "Guide",
        "Ai Integration"
      ],
      "headings": [
        {
          "level": 1,
          "text": "AI/ML Integration",
          "id": "aiml-integration"
        },
        {
          "level": 2,
          "text": "Provider Architecture",
          "id": "provider-architecture"
        },
        {
          "level": 2,
          "text": "Backend Integration",
          "id": "backend-integration"
        },
        {
          "level": 3,
          "text": "Multi-Provider Setup",
          "id": "multi-provider-setup"
        },
        {
          "level": 1,
          "text": "Get configured provider (Ollama in dev, OpenAI in prod)",
          "id": "get-configured-provider-ollama-in-dev-openai-in-prod"
        },
        {
          "level": 1,
          "text": "Streaming chat endpoint",
          "id": "streaming-chat-endpoint"
        },
        {
          "level": 3,
          "text": "Provider-Specific Usage",
          "id": "provider-specific-usage"
        },
        {
          "level": 1,
          "text": "Chat completion",
          "id": "chat-completion"
        },
        {
          "level": 1,
          "text": "Check available models",
          "id": "check-available-models"
        },
        {
          "level": 1,
          "text": "Pull new model",
          "id": "pull-new-model"
        },
        {
          "level": 1,
          "text": "Chat completion",
          "id": "chat-completion"
        },
        {
          "level": 1,
          "text": "Function calling",
          "id": "function-calling"
        },
        {
          "level": 2,
          "text": "Frontend Integration",
          "id": "frontend-integration"
        },
        {
          "level": 3,
          "text": "React Hooks",
          "id": "react-hooks"
        },
        {
          "level": 3,
          "text": "WebSocket Streaming",
          "id": "websocket-streaming"
        },
        {
          "level": 2,
          "text": "Local Development with Ollama",
          "id": "local-development-with-ollama"
        },
        {
          "level": 3,
          "text": "Automatic Model Management",
          "id": "automatic-model-management"
        },
        {
          "level": 1,
          "text": "✓ Starting Ollama service...",
          "id": "-starting-ollama-service"
        },
        {
          "level": 1,
          "text": "✓ Pulling llama3.2...",
          "id": "-pulling-llama32"
        },
        {
          "level": 1,
          "text": "✓ Pulling codellama...",
          "id": "-pulling-codellama"
        },
        {
          "level": 1,
          "text": "✓ Models ready for inference",
          "id": "-models-ready-for-inference"
        },
        {
          "level": 1,
          "text": "✓ Frontend: http://localhost:3000",
          "id": "-frontend-httplocalhost3000"
        },
        {
          "level": 1,
          "text": "✓ Backend: http://localhost:8000",
          "id": "-backend-httplocalhost8000"
        },
        {
          "level": 1,
          "text": "✓ Ollama: http://localhost:11434",
          "id": "-ollama-httplocalhost11434"
        },
        {
          "level": 3,
          "text": "GPU Detection & Configuration",
          "id": "gpu-detection-configuration"
        },
        {
          "level": 2,
          "text": "Production Deployment",
          "id": "production-deployment"
        },
        {
          "level": 3,
          "text": "Environment-Based Provider Switching",
          "id": "environment-based-provider-switching"
        },
        {
          "level": 1,
          "text": "Manual provider selection",
          "id": "manual-provider-selection"
        },
        {
          "level": 3,
          "text": "Deployment Configurations",
          "id": "deployment-configurations"
        },
        {
          "level": 1,
          "text": "Ollama service for local development",
          "id": "ollama-service-for-local-development"
        },
        {
          "level": 2,
          "text": "Advanced Features",
          "id": "advanced-features"
        },
        {
          "level": 3,
          "text": "Function Calling",
          "id": "function-calling"
        },
        {
          "level": 3,
          "text": "Vector Operations",
          "id": "vector-operations"
        },
        {
          "level": 1,
          "text": "Generate embeddings",
          "id": "generate-embeddings"
        },
        {
          "level": 1,
          "text": "Vector search with MongoDB",
          "id": "vector-search-with-mongodb"
        },
        {
          "level": 1,
          "text": "Hybrid search (text + vector)",
          "id": "hybrid-search-text-vector"
        },
        {
          "level": 2,
          "text": "Performance & Monitoring",
          "id": "performance-monitoring"
        },
        {
          "level": 3,
          "text": "AI Health Monitoring",
          "id": "ai-health-monitoring"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-guide-architecture",
      "title": "Architecture",
      "url": "/docs/guide/architecture",
      "content": "# Framework Architecture\n\n<Callout type=\"info\" title=\"Overview\">\n  Understanding FARM's architecture helps you build scalable, maintainable applications with proper separation of concerns.\n</Callout>\n\n## Core Architecture Principles\n\nFARM follows a **monorepo architecture** with clear separation between frontend, backend, and shared resources. The framework emphasizes:\n\n- **Type Safety**: End-to-end type safety from database to frontend\n- **Code Generation**: Automatic API clients and type definitions  \n- **Hot Reload**: Intelligent development server with cross-service updates\n- **AI-First**: Built-in ML/AI service integration\n- **Plugin Architecture**: Extensible system for adding functionality\n\n## Monorepo Structure\n\n<CodeTabs examples={[\n  {\n    language: \"plaintext\",\n    label: \"Project Structure\",\n    code: `farm-app/\n├── apps/\n│   ├── web/                    # React/TypeScript frontend\n│   │   ├── src/\n│   │   │   ├── components/     # Reusable UI components\n│   │   │   ├── pages/          # Page components with routing\n│   │   │   ├── hooks/          # Custom React hooks\n│   │   │   ├── stores/         # State management (Zustand)\n│   │   │   ├── services/       # API client services (auto-generated)\n│   │   │   ├── types/          # TypeScript definitions (auto-generated)\n│   │   │   └── utils/          # Frontend utilities\n│   │   ├── public/             # Static assets\n│   │   └── package.json\n│   └── api/                    # FastAPI backend\n│       ├── src/\n│       │   ├── routes/         # API route handlers\n│       │   ├── models/         # Pydantic models & database schemas\n│       │   ├── services/       # Business logic layer\n│       │   ├── ml/             # AI/ML inference services\n│       │   ├── database/       # Database connection & ODM\n│       │   ├── auth/           # Authentication & authorization\n│       │   └── core/           # Core utilities & configuration\n│       ├── tests/              # Backend test suite\n│       └── pyproject.toml\n├── packages/\n│   ├── shared-types/           # Shared TypeScript/Python type definitions\n│   ├── ui-components/          # Reusable UI component library\n│   └── ml-utils/               # Common ML utilities and models\n├── tools/\n│   ├── farm-cli/               # Framework CLI tool\n│   ├── codegen/                # Type generation and client creation\n│   └── dev-server/             # Unified development server\n├── farm.config.ts              # Framework configuration\n├── docker-compose.yml          # Local development environment\n└── package.json                # Workspace root configuration`\n  }\n]} />\n\n## Request Flow Architecture\n\nThe following diagram shows how requests flow through a FARM application:\n\n<CodeTabs examples={[\n  {\n    language: \"plaintext\",\n    label: \"Request Flow\",\n    code: `┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐\n│   React App     │───▶│   FastAPI        │───▶│   MongoDB       │\n│   (TypeScript)  │    │   (Python)       │    │   (Database)    │\n└─────────────────┘    └──────────────────┘    └─────────────────┘\n        │                        │                        │\n        │                        ▼                        │\n        │              ┌──────────────────┐               │\n        │              │   ML Services    │               │\n        │              │   (GPU/CPU)      │               │\n        │              └──────────────────┘               │\n        │                        │                        │\n        ▼                        ▼                        ▼\n┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐\n│   Vite Build    │    │   Docker         │    │   Vector DB     │\n│   System        │    │   Containers     │    │   (Optional)    │\n└─────────────────┘    └──────────────────┘    └─────────────────┘`\n  }\n]} />\n\n### Request Lifecycle\n\n1. **Frontend Request**: React component makes API call using auto-generated client\n2. **Routing**: FastAPI routes request to appropriate handler  \n3. **Validation**: Pydantic models validate request data\n4. **Business Logic**: Service layer processes the request\n5. **Database**: MongoDB operations via Beanie ODM\n6. **AI Processing**: Optional ML model inference\n7. **Response**: Type-safe response returned to frontend\n\n## Layer Architecture\n\n### 1. Frontend Layer (React/TypeScript)\n\n<FeatureList features={[\n  {\n    title: \"Modern React\",\n    description: \"React 18+ with Concurrent Features, Suspense, and Server Components support\",\n    icon: \"⚛️\"\n  },\n  {\n    title: \"TypeScript\",\n    description: \"Full type safety across the application with auto-generated types\",\n    icon: \"🏷️\"\n  },\n  {\n    title: \"Vite Build System\", \n    description: \"Lightning-fast build tool with HMR and optimized production builds\",\n    icon: \"⚡\"\n  },\n  {\n    title: \"State Management\",\n    description: \"Zustand for client state, TanStack Query for server state\",\n    icon: \"🏪\"\n  }\n]} />\n\n**Key Technologies:**\n- **UI Framework**: Headless UI components with Tailwind CSS styling\n- **Routing**: File-based routing system inspired by Next.js\n- **Testing**: Jest and Playwright for comprehensive testing\n- **Code Generation**: Automatic API clients and TypeScript types\n\n### 2. Backend Layer (FastAPI)\n\n<FeatureList features={[\n  {\n    title: \"FastAPI Framework\",\n    description: \"Modern Python web framework with automatic OpenAPI documentation\",\n    icon: \"🚀\"\n  },\n  {\n    title: \"Async Support\",\n    description: \"Full async/await support for high-performance I/O operations\",\n    icon: \"⚡\"\n  },\n  {\n    title: \"Dependency Injection\",\n    description: \"Built-in DI system for services and database connections\",\n    icon: \"🔌\"\n  },\n  {\n    title: \"Real-time Features\",\n    description: \"WebSocket support for real-time communication and AI streaming\",\n    icon: \"📡\"\n  }\n]} />\n\n**Key Features:**\n- **Background Tasks**: Celery integration for async task processing\n- **Security**: JWT authentication, OAuth2, rate limiting, and CORS handling\n- **API Documentation**: Automatic OpenAPI/Swagger documentation generation\n- **Error Handling**: Comprehensive error handling with detailed logging\n\n### 3. AI/ML Integration Layer\n\n<FeatureList features={[\n  {\n    title: \"Local AI Development\",\n    description: \"Ollama integration for zero-cost, offline AI development\",\n    icon: \"🏠\"\n  },\n  {\n    title: \"Multi-Provider Support\", \n    description: \"Seamless switching between Ollama, OpenAI, and HuggingFace\",\n    icon: \"🔄\"\n  },\n  {\n    title: \"GPU Acceleration\",\n    description: \"CUDA support with automatic GPU detection and allocation\",\n    icon: \"🎮\"\n  },\n  {\n    title: \"Streaming Responses\",\n    description: \"Real-time AI output streaming to frontend with WebSocket support\",\n    icon: \"📺\"\n  }\n]} />\n\n**Architecture Components:**\n- **Model Serving**: Automated model download, caching, and serving infrastructure\n- **Inference Pipeline**: Optimized model loading, caching, and batch processing\n- **Provider Routing**: Environment-based provider switching (Ollama dev → OpenAI prod)\n- **Vector Operations**: Built-in vector database integration for embedding storage\n\n### 4. Database Layer (MongoDB + ODM)\n\n<FeatureList features={[\n  {\n    title: \"MongoDB Primary\",\n    description: \"Primary database with flexible document schema and powerful querying\",\n    icon: \"🍃\"\n  },\n  {\n    title: \"Beanie ODM\",\n    description: \"Modern async ODM for Python with Pydantic integration\",\n    icon: \"🐻\"\n  },\n  {\n    title: \"Schema Validation\",\n    description: \"Automatic validation using Pydantic models with type safety\",\n    icon: \"✅\"\n  },\n  {\n    title: \"Database Agnostic\",\n    description: \"Plugin system for PostgreSQL, MySQL, and other databases\",\n    icon: \"🔄\"\n  }\n]} />\n\n**Key Features:**\n- **Migration System**: Database migration tools for schema evolution\n- **Connection Pooling**: Optimized connection management for production\n- **Relationship Management**: Support for document references and embedded documents\n- **Performance Optimization**: Indexing, aggregation pipelines, and query optimization\n\n## Development Architecture\n\n### Hot Reload System\n\nFARM's intelligent hot reload system provides seamless development experience:\n\n<CodeTabs examples={[\n  {\n    language: \"plaintext\",\n    label: \"Hot Reload Flow\",\n    code: `Python Model Change\n       ↓\nType Generation Triggered\n       ↓\nTypeScript Types Updated\n       ↓\nFrontend Components Reload\n       ↓\nAPI Client Regenerated\n       ↓\nDevelopment Server Synced`\n  }\n]} />\n\n**Features:**\n- **Intelligent HMR**: Changes to Python models automatically update TypeScript types\n- **API Watching**: Backend changes trigger frontend API client regeneration\n- **Database Sync**: Model changes automatically update database schemas\n- **ML Model Hot-Swap**: Update ML models without server restart\n- **Error Boundaries**: Comprehensive error handling with detailed stack traces\n\n### Code Generation Pipeline\n\n<CodeTabs examples={[\n  {\n    language: \"plaintext\",\n    label: \"Generation Pipeline\",\n    code: `1. Schema Analysis\n   │ Parse Pydantic models and FastAPI routes\n   ↓\n2. OpenAPI Generation  \n   │ Create comprehensive API documentation\n   ↓\n3. TypeScript Generation\n   │ Generate interfaces, types, and API clients\n   ↓\n4. React Hook Generation\n   │ Create custom hooks for API operations\n   ↓\n5. Form Generation\n   │ Auto-generate forms with validation\n   ↓\n6. Test Generation\n   │ Create basic test suites for new endpoints`\n  }\n]} />\n\n## Production Architecture\n\n### Scalability Patterns\n\n<FeatureList features={[\n  {\n    title: \"Horizontal Scaling\",\n    description: \"Stateless backend services that scale horizontally with load balancers\",\n    icon: \"📈\"\n  },\n  {\n    title: \"Microservices Ready\",\n    description: \"Plugin architecture supports service decomposition as you grow\",\n    icon: \"🧩\"\n  },\n  {\n    title: \"Caching Strategy\",\n    description: \"Multi-layer caching with Redis for sessions and API responses\",\n    icon: \"💾\"\n  },\n  {\n    title: \"CDN Integration\",\n    description: \"Automatic static asset optimization and global distribution\",\n    icon: \"🌍\"\n  }\n]} />\n\n### Deployment Architecture\n\n<CodeTabs examples={[\n  {\n    language: \"yaml\",\n    label: \"Docker Compose\",\n    code: `# Production-ready Docker composition\nversion: '3.8'\nservices:\n  web:\n    build: ./apps/web\n    ports:\n      - \"80:80\"\n    environment:\n      - API_URL=http://api:8000\n      \n  api:\n    build: ./apps/api  \n    ports:\n      - \"8000:8000\"\n    environment:\n      - DATABASE_URL=mongodb://db:27017/farm\n      - OPENAI_API_KEY=\\${OPENAI_API_KEY}\n    depends_on:\n      - db\n      - redis\n      \n  db:\n    image: mongo:7\n    volumes:\n      - mongodb_data:/data/db\n      \n  redis:\n    image: redis:7-alpine\n    \nvolumes:\n  mongodb_data:`\n  }\n]} />\n\n## Best Practices\n\n### Architecture Guidelines\n\n<div className=\"space-y-4\">\n\n**🏗️ Separation of Concerns**\n- Keep business logic in service layer, not route handlers\n- Use Pydantic models for all data validation\n- Separate database models from API models when needed\n\n**🔄 Type Safety**\n- Always run code generation after model changes\n- Use auto-generated API clients in frontend\n- Leverage TypeScript strict mode for maximum safety\n\n**🚀 Performance**\n- Use async/await throughout the backend\n- Implement proper database indexing\n- Cache frequently accessed data with Redis\n\n**🔒 Security**\n- Validate all inputs with Pydantic models\n- Use dependency injection for authentication\n- Implement proper CORS and rate limiting\n\n</div>\n\n---\n\n<Note>\nThis architecture provides a solid foundation for building scalable applications. As your app grows, the plugin system allows you to add functionality without architectural changes.\n</Note>",
      "excerpt": "<Callout type=\"info\" title=\"Overview\">\n  Understanding FARM's architecture helps you build scalable, maintainable applications with proper separation of concern...",
      "category": "docs/guide",
      "type": "guide",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.793Z",
      "breadcrumbs": [
        "Docs",
        "Guide",
        "Architecture"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Framework Architecture",
          "id": "framework-architecture"
        },
        {
          "level": 2,
          "text": "Core Architecture Principles",
          "id": "core-architecture-principles"
        },
        {
          "level": 2,
          "text": "Monorepo Structure",
          "id": "monorepo-structure"
        },
        {
          "level": 2,
          "text": "Request Flow Architecture",
          "id": "request-flow-architecture"
        },
        {
          "level": 3,
          "text": "Request Lifecycle",
          "id": "request-lifecycle"
        },
        {
          "level": 2,
          "text": "Layer Architecture",
          "id": "layer-architecture"
        },
        {
          "level": 3,
          "text": "1. Frontend Layer (React/TypeScript)",
          "id": "1-frontend-layer-reacttypescript"
        },
        {
          "level": 3,
          "text": "2. Backend Layer (FastAPI)",
          "id": "2-backend-layer-fastapi"
        },
        {
          "level": 3,
          "text": "3. AI/ML Integration Layer",
          "id": "3-aiml-integration-layer"
        },
        {
          "level": 3,
          "text": "4. Database Layer (MongoDB + ODM)",
          "id": "4-database-layer-mongodb-odm"
        },
        {
          "level": 2,
          "text": "Development Architecture",
          "id": "development-architecture"
        },
        {
          "level": 3,
          "text": "Hot Reload System",
          "id": "hot-reload-system"
        },
        {
          "level": 3,
          "text": "Code Generation Pipeline",
          "id": "code-generation-pipeline"
        },
        {
          "level": 2,
          "text": "Production Architecture",
          "id": "production-architecture"
        },
        {
          "level": 3,
          "text": "Scalability Patterns",
          "id": "scalability-patterns"
        },
        {
          "level": 3,
          "text": "Deployment Architecture",
          "id": "deployment-architecture"
        },
        {
          "level": 2,
          "text": "Best Practices",
          "id": "best-practices"
        },
        {
          "level": 3,
          "text": "Architecture Guidelines",
          "id": "architecture-guidelines"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-guide-code-generation",
      "title": "Code Generation",
      "url": "/docs/guide/code-generation",
      "content": "# Code Generation Pipeline\r\n\r\nFARM's intelligent code generation system automatically converts Python backend models into TypeScript types, API clients, React hooks, and complete CRUD interfaces. This ensures end-to-end type safety and eliminates manual client code maintenance.\r\n\r\n<Callout type=\"success\" title=\"Zero Configuration\">\r\n  Type generation happens automatically during development and builds, keeping\r\n  frontend and backend perfectly synchronized.\r\n</Callout>\r\n\r\n## Architecture Overview\r\n\r\n```mermaid\r\ngraph LR\r\n    A[Python Models] --> B[Type Extractor]\r\n    C[FastAPI Routes] --> B\r\n    B --> D[TypeScript Generator]\r\n    B --> E[API Client Generator]\r\n    B --> F[Hook Generator]\r\n    D --> G[Type Definitions]\r\n    E --> H[API Functions]\r\n    F --> I[React Hooks]\r\n    G --> J[Frontend App]\r\n    H --> J\r\n    I --> J\r\n```\r\n\r\n## Automatic Type Generation\r\n\r\n### From Python Models to TypeScript\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Python Model\",\r\n    code: `from beanie import Document\r\nfrom farm.database import Field\r\nfrom typing import Optional, List\r\nfrom datetime import datetime\r\nfrom enum import Enum\r\n\r\nclass UserRole(str, Enum):\r\nADMIN = \"admin\"\r\nUSER = \"user\"\r\nMODERATOR = \"moderator\"\r\n\r\nclass User(Document):\r\nname: str = Field(..., description=\"User's full name\")\r\nemail: str = Field(..., unique=True, description=\"Email address\")\r\nage: Optional[int] = Field(None, ge=18, le=120)\r\nrole: UserRole = Field(default=UserRole.USER)\r\npreferences: dict = Field(default_factory=dict)\r\ntags: List[str] = Field(default_factory=list)\r\ncreated_at: datetime = Field(default_factory=datetime.utcnow)\r\nis_active: bool = Field(default=True)\r\n\r\n    class Settings:\r\n        collection = \"users\"`\r\n\r\n},\r\n{\r\nlanguage: \"typescript\",\r\nlabel: \"Generated TypeScript\",\r\ncode: `// Auto-generated from Python models\r\nexport enum UserRole {\r\nADMIN = \"admin\",\r\nUSER = \"user\",\r\nMODERATOR = \"moderator\"\r\n}\r\n\r\nexport interface User {\r\n  id: string;\r\n  name: string;\r\n  email: string;\r\n  age?: number;\r\n  role: UserRole;\r\n  preferences: Record<string, any>;\r\n  tags: string[];\r\n  created_at: Date;\r\n  is_active: boolean;\r\n}\r\n\r\nexport interface CreateUserRequest {\r\n  name: string;\r\n  email: string;\r\n  age?: number;\r\n  role?: UserRole;\r\n  preferences?: Record<string, any>;\r\n  tags?: string[];\r\n}\r\n\r\nexport interface UpdateUserRequest {\r\n  name?: string;\r\n  email?: string;\r\n  age?: number;\r\n  role?: UserRole;\r\n  preferences?: Record<string, any>;\r\n  tags?: string[];\r\n  is_active?: boolean;\r\n}`\r\n  }\r\n]} />\r\n\r\n### API Route Generation\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"FastAPI Endpoints\",\r\n    code: `from fastapi import APIRouter, HTTPException, Depends\r\nfrom farm.api import auto_crud, paginate\r\nfrom typing import List\r\n\r\nrouter = APIRouter(prefix=\"/api/users\", tags=[\"users\"])\r\n\r\n# Auto-generate CRUD endpoints\r\n\r\nauto_crud(User, router=router, exclude=[\"delete\"])\r\n\r\n# Custom endpoints\r\n\r\n@router.get(\"/search\")\r\nasync def search_users(\r\nquery: str,\r\nrole: Optional[UserRole] = None,\r\npage: int = 1,\r\nlimit: int = 20\r\n) -> PaginatedResponse[User]:\r\nfilters = {}\r\nif role:\r\nfilters[\"role\"] = role\r\n\r\n    users = await User.find(\r\n        User.name.regex(query, \"i\") if query else {},\r\n        **filters\r\n    )\r\n\r\n    return await paginate(users, page=page, limit=limit)\r\n\r\n@router.post(\"/{user_id}/activate\")\r\nasync def activate_user(user_id: str) -> User:\r\nuser = await User.get(user_id)\r\nif not user:\r\nraise HTTPException(404, \"User not found\")\r\n\r\n    user.is_active = True\r\n    await user.save()\r\n    return user`\r\n\r\n},\r\n{\r\nlanguage: \"typescript\",\r\nlabel: \"Generated API Client\",\r\ncode: `// Auto-generated API client\r\nexport class UserService {\r\nprivate static baseUrl = process.env.VITE_API_URL + \"/api/users\";\r\n\r\n// CRUD operations\r\nstatic async list(params?: {\r\npage?: number;\r\nlimit?: number;\r\nrole?: UserRole;\r\n}): Promise<PaginatedResponse<User>> {\r\nconst query = new URLSearchParams(params as any).toString();\r\nconst response = await fetch(\\`\\${this.baseUrl}?\\${query}\\`);\r\nreturn response.json();\r\n}\r\n\r\nstatic async get(id: string): Promise<User> {\r\nconst response = await fetch(\\`\\${this.baseUrl}/\\${id}\\`);\r\nif (!response.ok) throw new Error(\"User not found\");\r\nreturn response.json();\r\n}\r\n\r\nstatic async create(data: CreateUserRequest): Promise<User> {\r\nconst response = await fetch(this.baseUrl, {\r\nmethod: \"POST\",\r\nheaders: { \"Content-Type\": \"application/json\" },\r\nbody: JSON.stringify(data)\r\n});\r\nif (!response.ok) throw new Error(\"Failed to create user\");\r\nreturn response.json();\r\n}\r\n\r\nstatic async update(id: string, data: UpdateUserRequest): Promise<User> {\r\nconst response = await fetch(\\`\\${this.baseUrl}/\\${id}\\`, {\r\nmethod: \"PATCH\",\r\nheaders: { \"Content-Type\": \"application/json\" },\r\nbody: JSON.stringify(data)\r\n});\r\nif (!response.ok) throw new Error(\"Failed to update user\");\r\nreturn response.json();\r\n}\r\n\r\n// Custom endpoints\r\nstatic async search(params: {\r\nquery: string;\r\nrole?: UserRole;\r\npage?: number;\r\nlimit?: number;\r\n}): Promise<PaginatedResponse<User>> {\r\nconst query = new URLSearchParams(params as any).toString();\r\nconst response = await fetch(\\`\\${this.baseUrl}/search?\\${query}\\`);\r\nreturn response.json();\r\n}\r\n\r\nstatic async activate(id: string): Promise<User> {\r\nconst response = await fetch(\\`\\${this.baseUrl}/\\${id}/activate\\`, {\r\nmethod: \"POST\"\r\n});\r\nif (!response.ok) throw new Error(\"Failed to activate user\");\r\nreturn response.json();\r\n}\r\n}`\r\n}\r\n]} />\r\n\r\n## React Hook Generation\r\n\r\n### Generated Hooks\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Query Hooks\",\r\n    code: `// Auto-generated React hooks using TanStack Query\r\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\r\nimport { UserService } from '@/services/UserService';\r\n\r\nexport function useUsers(params?: {\r\n  page?: number;\r\n  limit?: number;\r\n  role?: UserRole;\r\n}) {\r\n  return useQuery({\r\n    queryKey: ['users', params],\r\n    queryFn: () => UserService.list(params),\r\n    keepPreviousData: true,\r\n    staleTime: 5 * 60 * 1000, // 5 minutes\r\n  });\r\n}\r\n\r\nexport function useUser(id: string) {\r\n  return useQuery({\r\n    queryKey: ['users', id],\r\n    queryFn: () => UserService.get(id),\r\n    enabled: !!id,\r\n  });\r\n}\r\n\r\nexport function useUserSearch(query: string, options?: {\r\n  role?: UserRole;\r\n  page?: number;\r\n  limit?: number;\r\n}) {\r\n  return useQuery({\r\n    queryKey: ['users', 'search', query, options],\r\n    queryFn: () => UserService.search({ query, ...options }),\r\n    enabled: query.length > 2,\r\n    debounce: 300,\r\n  });\r\n}`\r\n  },\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Mutation Hooks\",\r\n    code: `export function useCreateUser() {\r\n  const queryClient = useQueryClient();\r\n  \r\n  return useMutation({\r\n    mutationFn: UserService.create,\r\n    onSuccess: (newUser) => {\r\n      // Invalidate and refetch users list\r\n      queryClient.invalidateQueries(['users']);\r\n      \r\n      // Add to cache\r\n      queryClient.setQueryData(['users', newUser.id], newUser);\r\n    },\r\n    onError: (error) => {\r\n      console.error('Failed to create user:', error);\r\n    }\r\n  });\r\n}\r\n\r\nexport function useUpdateUser() {\r\n  const queryClient = useQueryClient();\r\n  \r\n  return useMutation({\r\n    mutationFn: ({ id, ...data }: { id: string } & UpdateUserRequest) =>\r\n      UserService.update(id, data),\r\n    onSuccess: (updatedUser) => {\r\n      // Update cached user\r\n      queryClient.setQueryData(['users', updatedUser.id], updatedUser);\r\n      \r\n      // Invalidate lists that might contain this user\r\n      queryClient.invalidateQueries(['users'], { exact: false });\r\n    }\r\n  });\r\n}\r\n\r\nexport function useActivateUser() {\r\n  const queryClient = useQueryClient();\r\n  \r\n  return useMutation({\r\n    mutationFn: UserService.activate,\r\n    onSuccess: (user) => {\r\n      queryClient.setQueryData(['users', user.id], user);\r\n      queryClient.invalidateQueries(['users']);\r\n    }\r\n  });\r\n}`\r\n  }\r\n]} />\r\n\r\n### Hook Usage in Components\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"List Component\",\r\n    code: `import { useUsers, useUserSearch } from '@/hooks/useUsers';\r\nimport { UserRole } from '@/types/User';\r\n\r\nfunction UserList() {\r\nconst [searchQuery, setSearchQuery] = useState('');\r\nconst [selectedRole, setSelectedRole] = useState<UserRole>();\r\nconst [page, setPage] = useState(1);\r\n\r\n// Use search when query exists, otherwise list all\r\nconst {\r\ndata: searchResults,\r\nisLoading: isSearching\r\n} = useUserSearch(searchQuery, { role: selectedRole, page });\r\n\r\nconst {\r\ndata: allUsers,\r\nisLoading: isLoadingAll\r\n} = useUsers({ role: selectedRole, page });\r\n\r\nconst data = searchQuery ? searchResults : allUsers;\r\nconst isLoading = searchQuery ? isSearching : isLoadingAll;\r\n\r\nreturn (\r\n<div>\r\n<div className=\"filters\">\r\n<SearchInput\r\n          value={searchQuery}\r\n          onChange={setSearchQuery}\r\n          placeholder=\"Search users...\"\r\n        />\r\n<RoleFilter\r\n          value={selectedRole}\r\n          onChange={setSelectedRole}\r\n        />\r\n</div>\r\n\r\n      {isLoading ? (\r\n        <UserListSkeleton />\r\n      ) : (\r\n        <div>\r\n          {data?.items.map(user => (\r\n            <UserCard key={user.id} user={user} />\r\n          ))}\r\n          <Pagination\r\n            current={page}\r\n            total={data?.total || 0}\r\n            pageSize={data?.limit || 20}\r\n            onChange={setPage}\r\n          />\r\n        </div>\r\n      )}\r\n    </div>\r\n\r\n);\r\n}`  },\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Form Component\",\r\n    code:`import { useCreateUser, useUpdateUser } from '@/hooks/useUsers';\r\nimport { useForm } from 'react-hook-form';\r\n\r\ninterface UserFormProps {\r\nuser?: User;\r\nonSuccess?: () => void;\r\n}\r\n\r\nfunction UserForm({ user, onSuccess }: UserFormProps) {\r\nconst isEditing = !!user;\r\n\r\nconst createUser = useCreateUser();\r\nconst updateUser = useUpdateUser();\r\n\r\nconst form = useForm<CreateUserRequest>({\r\ndefaultValues: user ? {\r\nname: user.name,\r\nemail: user.email,\r\nage: user.age,\r\nrole: user.role,\r\ntags: user.tags\r\n} : {\r\nrole: UserRole.USER,\r\ntags: []\r\n}\r\n});\r\n\r\nconst onSubmit = async (data: CreateUserRequest) => {\r\ntry {\r\nif (isEditing) {\r\nawait updateUser.mutateAsync({ id: user.id, ...data });\r\n} else {\r\nawait createUser.mutateAsync(data);\r\n}\r\nonSuccess?.();\r\n} catch (error) {\r\n// Error handling is done in the hooks\r\n}\r\n};\r\n\r\nreturn (\r\n<form onSubmit={form.handleSubmit(onSubmit)}>\r\n<Input\r\n{...form.register('name', { required: 'Name is required' })}\r\nlabel=\"Name\"\r\nerror={form.formState.errors.name?.message}\r\n/>\r\n\r\n      <Input\r\n        {...form.register('email', { required: 'Email is required' })}\r\n        type=\"email\"\r\n        label=\"Email\"\r\n        error={form.formState.errors.email?.message}\r\n      />\r\n\r\n      <NumberInput\r\n        {...form.register('age', { min: 18, max: 120 })}\r\n        label=\"Age\"\r\n        error={form.formState.errors.age?.message}\r\n      />\r\n\r\n      <Select\r\n        {...form.register('role')}\r\n        label=\"Role\"\r\n        options={Object.values(UserRole)}\r\n      />\r\n\r\n      <TagInput\r\n        {...form.register('tags')}\r\n        label=\"Tags\"\r\n      />\r\n\r\n      <Button\r\n        type=\"submit\"\r\n        loading={createUser.isLoading || updateUser.isLoading}\r\n      >\r\n        {isEditing ? 'Update' : 'Create'} User\r\n      </Button>\r\n    </form>\r\n\r\n);\r\n}`\r\n}\r\n]} />\r\n\r\n## CLI Code Generation\r\n\r\n### Generate Commands\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Model Generation\",\r\n    code: `# Generate complete model with API and frontend\r\nfarm generate model Product\r\n\r\n# Generate with specific features\r\n\r\nfarm generate model Product --api --hooks --forms\r\n\r\n# Generate from existing database\r\n\r\nfarm generate model --from-db products`  },\r\n  {\r\n    language: \"bash\",\r\n    label: \"Page Generation\",\r\n    code:`# Generate CRUD pages for existing model\r\nfarm generate page users\r\n\r\n# Generate with specific layout\r\n\r\nfarm generate page users --layout dashboard\r\n\r\n# Generate with custom components\r\n\r\nfarm generate page users --components table,form,filters`\r\n}\r\n]} />\r\n\r\n### Generated File Structure\r\n\r\nWhen you run `farm generate model Product`, it creates:\r\n\r\n```\r\n📁 Backend (Python)\r\n├── apps/api/src/models/product.py\r\n├── apps/api/src/routes/products.py\r\n└── apps/api/tests/test_products.py\r\n\r\n📁 Frontend (TypeScript)\r\n├── apps/web/src/types/Product.ts\r\n├── apps/web/src/services/ProductService.ts\r\n├── apps/web/src/hooks/useProducts.ts\r\n└── apps/web/src/components/ProductForm.tsx\r\n\r\n📁 Generated Pages (Optional)\r\n├── apps/web/src/pages/products/index.tsx\r\n├── apps/web/src/pages/products/[id].tsx\r\n└── apps/web/src/pages/products/create.tsx\r\n```\r\n\r\n### Custom Templates\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Custom Template\",\r\n    code: `// templates/custom-model.template.ts\r\nexport const customModelTemplate = {\r\n  python: \\`\r\nfrom beanie import Document\r\nfrom farm.database import Field\r\nfrom typing import {{ imports }}\r\n\r\nclass {{ ModelName }}(Document):\r\n{{ fields }}\r\n\r\n    class Settings:\r\n        collection = \"{{ collection_name }}\"\r\n        {{ settings }}\r\n\r\n\\`,\r\n\r\ntypescript: \\`\r\nexport interface {{ ModelName }} {\r\n{{ fields }}\r\n}\r\n\r\nexport interface Create{{ ModelName }}Request {\r\n  {{ create_fields }}\r\n}\r\n  \\`,\r\n  \r\n  hooks: \\`\r\nexport function use{{ ModelName }}s() {\r\n  return useQuery({\r\n    queryKey: ['{{ model_name }}s'],\r\n    queryFn: {{ ModelName }}Service.list\r\n  });\r\n}\r\n  \\`\r\n};`\r\n  },\r\n  {\r\n    language: \"bash\",\r\n    label: \"Use Custom Template\",\r\n    code: `# Use custom template\r\nfarm generate model Product --template custom-model\r\n\r\n# Generate from URL template\r\n\r\nfarm generate model Product --template https://github.com/user/farm-templates/model.json`\r\n}\r\n]} />\r\n\r\n## Configuration & Customization\r\n\r\n### Generation Settings\r\n\r\n<CodeTabs\r\n  examples={[\r\n    {\r\n      language: \"typescript\",\r\n      label: \"farm.config.ts\",\r\n      code: `export default defineConfig({\r\n  codegen: {\r\n    // Output directories\r\n    output: {\r\n      types: 'apps/web/src/types',\r\n      services: 'apps/web/src/services',\r\n      hooks: 'apps/web/src/hooks'\r\n    },\r\n    \r\n    // Generation options\r\n    typescript: {\r\n      enumFormat: 'union', // 'union' | 'enum'\r\n      dateFormat: 'Date', // 'Date' | 'string'\r\n      optionalFormat: 'partial', // 'partial' | 'required'\r\n      includeDocstrings: true\r\n    },\r\n    \r\n    // Hook generation\r\n    hooks: {\r\n      library: 'tanstack-query', // 'tanstack-query' | 'swr'\r\n      errorBoundary: true,\r\n      suspense: false,\r\n      devtools: true\r\n    },\r\n    \r\n    // API client\r\n    client: {\r\n      baseUrl: process.env.VITE_API_URL,\r\n      timeout: 10000,\r\n      retries: 3,\r\n      interceptors: true\r\n    }\r\n  }\r\n});`,\r\n    },\r\n  ]}\r\n/>\r\n\r\n### Watch Mode\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Development Workflow\",\r\n    code: `# Start with automatic generation\r\nfarm dev --codegen\r\n\r\n# Watch specific files\r\n\r\nfarm codegen watch --models --routes\r\n\r\n# Manual generation\r\n\r\nfarm codegen generate\r\n\r\n# Generate specific types\r\n\r\nfarm codegen generate --only types,hooks`\r\n}\r\n]} />\r\n\r\n## Advanced Features\r\n\r\n### Custom Type Mappings\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Python Types\",\r\n    code: `from farm.codegen import TypeMapping\r\nfrom decimal import Decimal\r\nfrom uuid import UUID\r\n\r\n# Custom type mappings\r\n\r\nTypeMapping.register(Decimal, \"number\")\r\nTypeMapping.register(UUID, \"string\")\r\n\r\n# Custom field annotations\r\n\r\nfrom typing import Annotated\r\n\r\nUserId = Annotated[str, {\"tsType\": \"string\", \"validation\": \"uuid\"}]\r\nPrice = Annotated[Decimal, {\"tsType\": \"number\", \"precision\": 2}]\r\n\r\nclass Product(Document):\r\nid: UserId\r\nprice: Price = Field(..., description=\"Product price in USD\")`  },\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Generated Result\",\r\n    code:`// Generated with custom mappings\r\nexport interface Product {\r\nid: string; // UUID validation\r\nprice: number; // Decimal with 2 precision\r\n}\r\n\r\n// Generated validation\r\nexport const ProductSchema = z.object({\r\nid: z.string().uuid(),\r\nprice: z.number().multipleOf(0.01)\r\n});`\r\n}\r\n]} />\r\n\r\n### Integration with OpenAPI\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"OpenAPI Integration\",\r\n    code: `# FastAPI automatically generates OpenAPI schema\r\nfrom fastapi import FastAPI\r\nfrom farm.codegen import generate_client_from_openapi\r\n\r\napp = FastAPI(\r\ntitle=\"FARM API\",\r\ndescription=\"Auto-generated API documentation\",\r\nversion=\"1.0.0\"\r\n)\r\n\r\n# Export OpenAPI schema\r\n\r\n@app.get(\"/openapi.json\")\r\nasync def get_openapi():\r\nreturn app.openapi()\r\n\r\n# Generate client from OpenAPI\r\n\r\nawait generate_client_from_openapi(\r\n\"http://localhost:8000/openapi.json\",\r\noutput_dir=\"apps/web/src/generated\"\r\n)`\r\n}\r\n]} />\r\n\r\n<Info>\r\n  Code generation runs automatically during development and can be configured to\r\n  run on file changes, ensuring your frontend always stays in sync with backend\r\n  changes.\r\n</Info>\r\n\r\n## Best Practices\r\n\r\n### Type Safety Guidelines\r\n\r\n<FeatureList\r\n  features={[\r\n    {\r\n      name: \"Strict TypeScript\",\r\n      description: \"Enable strict mode and proper type checking\",\r\n      icon: \"🔒\",\r\n    },\r\n    {\r\n      name: \"Validation Layers\",\r\n      description: \"Use runtime validation for API boundaries\",\r\n      icon: \"✅\",\r\n    },\r\n    {\r\n      name: \"Error Handling\",\r\n      description: \"Proper error types and handling strategies\",\r\n      icon: \"🚨\",\r\n    },\r\n    {\r\n      name: \"Documentation\",\r\n      description: \"Generate docs from code comments\",\r\n      icon: \"📝\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n<Warning>\r\n  Generated code should not be manually edited. Make changes to the source\r\n  Python models and regenerate to maintain consistency.\r\n</Warning>\r\n",
      "excerpt": "FARM's intelligent code generation system automatically converts Python backend models into TypeScript types, API clients, React hooks, and complete CRUD interf...",
      "category": "docs/guide",
      "type": "guide",
      "tags": [
        "fastapi",
        "react",
        "farm",
        "typescript",
        "python"
      ],
      "lastModified": "2025-06-12T21:57:32.793Z",
      "breadcrumbs": [
        "Docs",
        "Guide",
        "Code Generation"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Code Generation Pipeline",
          "id": "code-generation-pipeline"
        },
        {
          "level": 2,
          "text": "Architecture Overview",
          "id": "architecture-overview"
        },
        {
          "level": 2,
          "text": "Automatic Type Generation",
          "id": "automatic-type-generation"
        },
        {
          "level": 3,
          "text": "From Python Models to TypeScript",
          "id": "from-python-models-to-typescript"
        },
        {
          "level": 3,
          "text": "API Route Generation",
          "id": "api-route-generation"
        },
        {
          "level": 1,
          "text": "Auto-generate CRUD endpoints",
          "id": "auto-generate-crud-endpoints"
        },
        {
          "level": 1,
          "text": "Custom endpoints",
          "id": "custom-endpoints"
        },
        {
          "level": 2,
          "text": "React Hook Generation",
          "id": "react-hook-generation"
        },
        {
          "level": 3,
          "text": "Generated Hooks",
          "id": "generated-hooks"
        },
        {
          "level": 3,
          "text": "Hook Usage in Components",
          "id": "hook-usage-in-components"
        },
        {
          "level": 2,
          "text": "CLI Code Generation",
          "id": "cli-code-generation"
        },
        {
          "level": 3,
          "text": "Generate Commands",
          "id": "generate-commands"
        },
        {
          "level": 1,
          "text": "Generate with specific features",
          "id": "generate-with-specific-features"
        },
        {
          "level": 1,
          "text": "Generate from existing database",
          "id": "generate-from-existing-database"
        },
        {
          "level": 1,
          "text": "Generate with specific layout",
          "id": "generate-with-specific-layout"
        },
        {
          "level": 1,
          "text": "Generate with custom components",
          "id": "generate-with-custom-components"
        },
        {
          "level": 3,
          "text": "Generated File Structure",
          "id": "generated-file-structure"
        },
        {
          "level": 3,
          "text": "Custom Templates",
          "id": "custom-templates"
        },
        {
          "level": 1,
          "text": "Generate from URL template",
          "id": "generate-from-url-template"
        },
        {
          "level": 2,
          "text": "Configuration & Customization",
          "id": "configuration-customization"
        },
        {
          "level": 3,
          "text": "Generation Settings",
          "id": "generation-settings"
        },
        {
          "level": 3,
          "text": "Watch Mode",
          "id": "watch-mode"
        },
        {
          "level": 1,
          "text": "Watch specific files",
          "id": "watch-specific-files"
        },
        {
          "level": 1,
          "text": "Manual generation",
          "id": "manual-generation"
        },
        {
          "level": 1,
          "text": "Generate specific types",
          "id": "generate-specific-types"
        },
        {
          "level": 2,
          "text": "Advanced Features",
          "id": "advanced-features"
        },
        {
          "level": 3,
          "text": "Custom Type Mappings",
          "id": "custom-type-mappings"
        },
        {
          "level": 1,
          "text": "Custom type mappings",
          "id": "custom-type-mappings"
        },
        {
          "level": 1,
          "text": "Custom field annotations",
          "id": "custom-field-annotations"
        },
        {
          "level": 3,
          "text": "Integration with OpenAPI",
          "id": "integration-with-openapi"
        },
        {
          "level": 1,
          "text": "Export OpenAPI schema",
          "id": "export-openapi-schema"
        },
        {
          "level": 1,
          "text": "Generate client from OpenAPI",
          "id": "generate-client-from-openapi"
        },
        {
          "level": 2,
          "text": "Best Practices",
          "id": "best-practices"
        },
        {
          "level": 3,
          "text": "Type Safety Guidelines",
          "id": "type-safety-guidelines"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-guide-database",
      "title": "Database",
      "url": "/docs/guide/database",
      "content": "# Database Integration\r\n\r\nFARM provides a flexible database layer with MongoDB as the primary choice, while supporting PostgreSQL, MySQL, and SQLite through a unified provider interface. The system features automatic type generation, migrations, and seamless ODM integration.\r\n\r\n<Callout type=\"success\" title=\"Database Agnostic\">\r\n  Start with MongoDB and switch to PostgreSQL or other databases without\r\n  changing your application code.\r\n</Callout>\r\n\r\n## Database Architecture\r\n\r\n```mermaid\r\ngraph TD\r\n    A[Python Models] --> B[Database Provider]\r\n    B --> C[MongoDB + Beanie]\r\n    B --> D[PostgreSQL + SQLAlchemy]\r\n    B --> E[MySQL + SQLAlchemy]\r\n    B --> F[SQLite + SQLAlchemy]\r\n    A --> G[Auto Type Generation]\r\n    G --> H[TypeScript Types]\r\n    G --> I[API Client]\r\n    A --> J[Migrations]\r\n    J --> K[Schema Changes]\r\n```\r\n\r\n## MongoDB with Beanie ODM\r\n\r\n### Model Definition\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Basic Model\",\r\n    code: `from beanie import Document, Indexed\r\nfrom farm.database import Field\r\nfrom farm.api import auto_crud\r\nfrom typing import Optional\r\nfrom datetime import datetime\r\n\r\nclass User(Document):\r\nname: str = Field(..., description=\"User's full name\")\r\nemail: Indexed(str, unique=True) = Field(..., description=\"User email address\")\r\nage: Optional[int] = Field(None, ge=0, le=150)\r\npreferences: dict = Field(default_factory=dict)\r\ncreated_at: datetime = Field(default_factory=datetime.utcnow)\r\nis_active: bool = Field(default=True)\r\n\r\n    class Settings:\r\n        collection = \"users\"\r\n        use_state_management = True\r\n        validate_on_save = True\r\n\r\n# Auto-generate CRUD API endpoints\r\n\r\nauto_crud(User, prefix=\"/api/users\")`  },\r\n  {\r\n    language: \"python\",\r\n    label: \"Advanced Model\",\r\n    code:`from beanie import Document, Link, BackLink\r\nfrom typing import List, Optional\r\nfrom enum import Enum\r\n\r\nclass PostStatus(str, Enum):\r\nDRAFT = \"draft\"\r\nPUBLISHED = \"published\"\r\nARCHIVED = \"archived\"\r\n\r\nclass Tag(Document):\r\nname: str = Field(..., unique=True)\r\ncolor: str = Field(default=\"#gray\")\r\n\r\n    class Settings:\r\n        collection = \"tags\"\r\n\r\nclass Post(Document):\r\ntitle: str = Field(..., min_length=1, max_length=200)\r\ncontent: str = Field(...)\r\nstatus: PostStatus = Field(default=PostStatus.DRAFT)\r\nauthor: Link[User] = Field(...)\r\ntags: List[Link[Tag]] = Field(default_factory=list)\r\nviews: int = Field(default=0, ge=0)\r\n\r\n    # Computed fields\r\n    @property\r\n    def is_published(self) -> bool:\r\n        return self.status == PostStatus.PUBLISHED\r\n\r\n    # Instance methods\r\n    async def publish(self):\r\n        self.status = PostStatus.PUBLISHED\r\n        await self.save()\r\n\r\n    class Settings:\r\n        collection = \"posts\"\r\n        indexes = [\r\n            [(\"title\", \"text\"), (\"content\", \"text\")],  # Text search\r\n            [(\"author\", 1), (\"created_at\", -1)],       # Author posts\r\n            [(\"status\", 1), (\"created_at\", -1)]        # Status timeline\r\n        ]\r\n\r\n# Reverse relationships\r\n\r\nUser.posts = BackLink[Post](\"author\")`\r\n}\r\n]} />\r\n\r\n### Database Operations\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\", \r\n    label: \"CRUD Operations\",\r\n    code: `# Create\r\nuser = User(name=\"John Doe\", email=\"john@example.com\", age=30)\r\nawait user.create()\r\n\r\n# Read\r\n\r\nuser = await User.find_one(User.email == \"john@example.com\")\r\nusers = await User.find(User.age >= 18).to_list()\r\n\r\n# Update\r\n\r\nawait user.set({User.age: 31})\r\n\r\n# or\r\n\r\nuser.age = 31\r\nawait user.save()\r\n\r\n# Delete\r\n\r\nawait user.delete()\r\n\r\n# Bulk operations\r\n\r\nawait User.find(User.age < 18).delete()\r\nawait User.find(User.is_active == False).update(\r\n{\"$set\": {\"status\": \"inactive\"}}\r\n)`  },\r\n  {\r\n    language: \"python\",\r\n    label: \"Advanced Queries\",\r\n    code:`from beanie.operators import In, RegEx, Near\r\nfrom motor.motor_asyncio import AsyncIOMotorClientSession\r\n\r\n# Complex queries\r\n\r\nactive_users = await User.find(\r\nUser.is_active == True,\r\nUser.age >= 18,\r\nUser.email.regex(\".\\*@company\\\\.com$\")\r\n).sort(-User.created_at).limit(10).to_list()\r\n\r\n# Aggregation\r\n\r\npipeline = [\r\n{\"$match\": {\"status\": \"published\"}},\r\n{\"$group\": {\"_id\": \"$author\", \"post_count\": {\"$sum\": 1}}},\r\n{\"$sort\": {\"post_count\": -1}}\r\n]\r\ntop_authors = await Post.aggregate(pipeline).to_list()\r\n\r\n# Transactions\r\n\r\nasync with await User.get_motor_collection().database.client.start_session() as session:\r\nasync with session.start_transaction():\r\nuser = User(name=\"Alice\", email=\"alice@example.com\")\r\nawait user.create(session=session)\r\n\r\n        post = Post(title=\"First Post\", content=\"Hello World\", author=user)\r\n        await post.create(session=session)`\r\n\r\n}\r\n]} />\r\n\r\n### Relationships & References\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Link Relationships\",\r\n    code: `# Create with relationships\r\nauthor = await User.find_one(User.email == \"john@example.com\")\r\ntags = await Tag.find(In(Tag.name, [\"python\", \"mongodb\"])).to_list()\r\n\r\npost = Post(\r\ntitle=\"FARM Stack Tutorial\",\r\ncontent=\"Learn how to build with FARM...\",\r\nauthor=author,\r\ntags=tags\r\n)\r\nawait post.create()\r\n\r\n# Fetch with relationships\r\n\r\npost = await Post.find_one(\r\nPost.title == \"FARM Stack Tutorial\"\r\n).populate(Post.author, Post.tags)\r\n\r\nprint(f\"Author: {post.author.name}\")\r\nprint(f\"Tags: {[tag.name for tag in post.tags]}\")\r\n\r\n# Reverse relationships\r\n\r\nauthor_posts = await author.posts.find().to_list()\r\nprint(f\"Author has {len(author_posts)} posts\")`  },\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Generated Types\",\r\n    code:`// Auto-generated TypeScript types\r\ninterface User {\r\nid: string;\r\nname: string;\r\nemail: string;\r\nage?: number;\r\npreferences: Record<string, any>;\r\ncreated_at: Date;\r\nis_active: boolean;\r\n}\r\n\r\ninterface Post {\r\nid: string;\r\ntitle: string;\r\ncontent: string;\r\nstatus: 'draft' | 'published' | 'archived';\r\nauthor: User | string; // Can be populated or just ID\r\ntags: Tag[] | string[];\r\nviews: number;\r\nis_published: boolean; // Computed property\r\n}\r\n\r\n// Auto-generated API client\r\nimport { UserService, PostService } from '@/services/api';\r\n\r\nconst users = await UserService.list({ age_gte: 18 });\r\nconst post = await PostService.create({\r\ntitle: \"New Post\",\r\ncontent: \"Content here...\",\r\nauthor_id: \"user_123\"\r\n});`\r\n}\r\n]} />\r\n\r\n## Alternative Database Providers\r\n\r\n### PostgreSQL with SQLAlchemy\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Configuration\",\r\n    code: `// farm.config.ts\r\nexport default defineConfig({\r\n  database: {\r\n    provider: 'postgresql',\r\n    url: process.env.DATABASE_URL || 'postgresql://user:pass@localhost/farm',\r\n    options: {\r\n      pool_size: 10,\r\n      max_overflow: 20,\r\n      echo: process.env.NODE_ENV === 'development'\r\n    }\r\n  }\r\n});`\r\n  },\r\n  {\r\n    language: \"python\",\r\n    label: \"SQLAlchemy Models\",\r\n    code: `from sqlalchemy import Column, Integer, String, DateTime, Boolean\r\nfrom sqlalchemy.ext.declarative import declarative_base\r\nfrom farm.database import Field, auto_crud\r\nfrom datetime import datetime\r\n\r\nBase = declarative_base()\r\n\r\nclass User(Base):\r\n**tablename** = \"users\"\r\n\r\n    id = Column(Integer, primary_key=True, index=True)\r\n    name = Column(String, nullable=False)\r\n    email = Column(String, unique=True, index=True, nullable=False)\r\n    age = Column(Integer, nullable=True)\r\n    created_at = Column(DateTime, default=datetime.utcnow)\r\n    is_active = Column(Boolean, default=True)\r\n\r\n# Same auto-CRUD generation\r\n\r\nauto_crud(User, prefix=\"/api/users\")`\r\n}\r\n]} />\r\n\r\n### Multi-Database Setup\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Multiple Connections\",\r\n    code: `from farm.database import DatabaseManager\r\n\r\n# Configure multiple databases\r\n\r\ndb_manager = DatabaseManager()\r\n\r\n# Primary MongoDB for documents\r\n\r\nawait db_manager.connect(\"mongodb\", {\r\n\"url\": \"mongodb://localhost:27017/farm_docs\",\r\n\"name\": \"documents\"\r\n})\r\n\r\n# PostgreSQL for relational data\r\n\r\nawait db_manager.connect(\"postgresql\", {\r\n\"url\": \"postgresql://user:pass@localhost/farm_rel\",\r\n\"name\": \"analytics\"\r\n})\r\n\r\n# Use specific database\r\n\r\nusers_doc = await User.find_one(database=\"documents\")\r\nanalytics_data = await AnalyticsEvent.query(database=\"analytics\")`  },\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Multi-DB Config\",\r\n    code:`// farm.config.ts\r\nexport default defineConfig({\r\ndatabases: {\r\nprimary: {\r\nprovider: 'mongodb',\r\nurl: process.env.MONGODB_URL,\r\nmodels: ['User', 'Post', 'Tag']\r\n},\r\nanalytics: {\r\nprovider: 'postgresql',\r\nurl: process.env.POSTGRES_URL,\r\nmodels: ['Event', 'Metric', 'Report']\r\n},\r\ncache: {\r\nprovider: 'redis',\r\nurl: process.env.REDIS_URL\r\n}\r\n}\r\n});`\r\n}\r\n]} />\r\n\r\n## Migrations & Schema Management\r\n\r\n### Automatic Migrations\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Migration Commands\",\r\n    code: `# Generate migration from model changes\r\nfarm db migrate create add_user_preferences\r\n\r\n# Apply pending migrations\r\n\r\nfarm db migrate\r\n\r\n# Rollback last migration\r\n\r\nfarm db migrate rollback\r\n\r\n# Check migration status\r\n\r\nfarm db migrate status`  },\r\n  {\r\n    language: \"python\",\r\n    label: \"Migration File\",\r\n    code:`# migrations/001_add_user_preferences.py\r\nfrom farm.database.migration import Migration\r\n\r\nclass AddUserPreferences(Migration):\r\nversion = \"001\"\r\ndescription = \"Add preferences field to User model\"\r\n\r\n    async def up(self):\r\n        # MongoDB migration\r\n        await self.db.users.update_many(\r\n            {\"preferences\": {\"$exists\": False}},\r\n            {\"$set\": {\"preferences\": {}}}\r\n        )\r\n\r\n        # Add index\r\n        await self.db.users.create_index(\"preferences.theme\")\r\n\r\n    async def down(self):\r\n        # Rollback migration\r\n        await self.db.users.update_many(\r\n            {},\r\n            {\"$unset\": {\"preferences\": \"\"}}\r\n        )\r\n\r\n        await self.db.users.drop_index(\"preferences.theme\")`\r\n\r\n}\r\n]} />\r\n\r\n### Schema Validation\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Validation Rules\",\r\n    code: `from pydantic import validator, root_validator\r\nfrom typing import List\r\n\r\nclass User(Document):\r\nname: str = Field(..., min_length=2, max_length=50)\r\nemail: str = Field(..., regex=r'^[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.[a-zA-Z]{2,}$')\r\nage: Optional[int] = Field(None, ge=13, le=120)\r\ntags: List[str] = Field(default_factory=list, max_items=10)\r\n\r\n    @validator('name')\r\n    def validate_name(cls, v):\r\n        if v.lower() in ['admin', 'root', 'system']:\r\n            raise ValueError('Reserved username')\r\n        return v.title()\r\n\r\n    @validator('tags')\r\n    def validate_tags(cls, v):\r\n        return [tag.lower().strip() for tag in v if tag.strip()]\r\n\r\n    @root_validator\r\n    def validate_model(cls, values):\r\n        if values.get('age', 0) < 16 and 'mature' in values.get('tags', []):\r\n            raise ValueError('Mature content not allowed for users under 16')\r\n        return values`\r\n\r\n}\r\n]} />\r\n\r\n## Performance & Optimization\r\n\r\n### Indexing Strategy\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"MongoDB Indexes\",\r\n    code: `class Post(Document):\r\n    title: str\r\n    content: str\r\n    author: Link[User]\r\n    tags: List[str]\r\n    created_at: datetime\r\n    \r\n    class Settings:\r\n        collection = \"posts\"\r\n        indexes = [\r\n            # Single field indexes\r\n            [(\"created_at\", -1)],           # Timeline queries\r\n            [(\"author\", 1)],                # Author lookup\r\n            \r\n            # Compound indexes  \r\n            [(\"author\", 1), (\"created_at\", -1)],  # Author timeline\r\n            [(\"status\", 1), (\"created_at\", -1)],  # Status timeline\r\n            \r\n            # Text search\r\n            [(\"title\", \"text\"), (\"content\", \"text\")],\r\n            \r\n            # Partial indexes\r\n            {\r\n                \"key\": [(\"email\", 1)],\r\n                \"partialFilterExpression\": {\"email\": {\"$exists\": True}}\r\n            },\r\n            \r\n            # TTL index for temporary data\r\n            {\r\n                \"key\": [(\"expires_at\", 1)],\r\n                \"expireAfterSeconds\": 0\r\n            }\r\n        ]`\r\n  },\r\n  {\r\n    language: \"python\",\r\n    label: \"Query Optimization\",\r\n    code: `# Use projection to limit fields\r\nusers = await User.find(\r\n    User.is_active == True\r\n).project(User.name, User.email).to_list()\r\n\r\n# Batch operations\r\n\r\nuser_ids = [\"id1\", \"id2\", \"id3\"]\r\nusers = await User.find(In(User.id, user_ids)).to_list()\r\n\r\n# Pagination with cursor\r\n\r\nfrom farm.database import paginate\r\n\r\nasync def get_users_page(cursor: Optional[str] = None, limit: int = 20):\r\nreturn await paginate(\r\nUser.find(User.is_active == True).sort(-User.created_at),\r\ncursor=cursor,\r\nlimit=limit\r\n)\r\n\r\n# Use aggregation for complex queries\r\n\r\npipeline = [\r\n{\"$match\": {\"created_at\": {\"$gte\": last_week}}},\r\n{\"$group\": {\r\n\"_id\": \"$author\",\r\n\"post_count\": {\"$sum\": 1},\r\n\"total_views\": {\"$sum\": \"$views\"}\r\n}},\r\n{\"$sort\": {\"post_count\": -1}},\r\n{\"$limit\": 10}\r\n]\r\ntop_authors = await Post.aggregate(pipeline).to_list()`\r\n}\r\n]} />\r\n\r\n### Connection Pooling\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Connection Configuration\",\r\n    code: `// farm.config.ts\r\nexport default defineConfig({\r\n  database: {\r\n    provider: 'mongodb',\r\n    url: process.env.DATABASE_URL,\r\n    options: {\r\n      maxPoolSize: 50,        // Maximum connections\r\n      minPoolSize: 5,         // Minimum connections  \r\n      maxIdleTimeMS: 30000,   // Close after 30s idle\r\n      serverSelectionTimeoutMS: 5000, // Connection timeout\r\n      heartbeatFrequencyMS: 10000,    // Health check interval\r\n      retryWrites: true,      // Retry failed writes\r\n      w: 'majority',          // Write concern\r\n      readPreference: 'primaryPreferred'\r\n    }\r\n  }\r\n});`\r\n  },\r\n  {\r\n    language: \"python\",\r\n    label: \"Connection Monitoring\",\r\n    code: `from farm.database import ConnectionMonitor\r\n\r\n@app.get(\"/health/database\")\r\nasync def database_health():\r\nmonitor = ConnectionMonitor()\r\n\r\n    return {\r\n        \"status\": await monitor.check_connection(),\r\n        \"pool_stats\": await monitor.get_pool_stats(),\r\n        \"slow_queries\": await monitor.get_slow_queries(),\r\n        \"indexes\": await monitor.check_indexes()\r\n    }`\r\n\r\n}\r\n]} />\r\n\r\n## Vector Search & AI Integration\r\n\r\n### Vector Embeddings\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Vector Models\",\r\n    code: `from farm.database import VectorField\r\nfrom farm.ai import EmbeddingProvider\r\n\r\nclass Document(BaseDocument):\r\ntitle: str\r\ncontent: str\r\nembedding: VectorField[List[float]] = Field(default=None)\r\n\r\n    async def generate_embedding(self):\r\n        \"\"\"Generate embedding for content\"\"\"\r\n        provider = EmbeddingProvider.get_default()\r\n        self.embedding = await provider.embed(f\"{self.title} {self.content}\")\r\n        await self.save()\r\n\r\n    @classmethod\r\n    async def vector_search(cls, query: str, limit: int = 10) -> List['Document']:\r\n        \"\"\"Search documents by similarity\"\"\"\r\n        provider = EmbeddingProvider.get_default()\r\n        query_embedding = await provider.embed(query)\r\n\r\n        pipeline = [\r\n            {\r\n                \"$vectorSearch\": {\r\n                    \"index\": \"vector_index\",\r\n                    \"path\": \"embedding\",\r\n                    \"queryVector\": query_embedding,\r\n                    \"numCandidates\": limit * 3,\r\n                    \"limit\": limit\r\n                }\r\n            },\r\n            {\"$addFields\": {\"score\": {\"$meta\": \"vectorSearchScore\"}}}\r\n        ]\r\n\r\n        return await cls.aggregate(pipeline).to_list()`\r\n\r\n},\r\n{\r\nlanguage: \"typescript\",\r\nlabel: \"Frontend Vector Search\",\r\ncode: `import { useVectorSearch } from \"@farm/database-hooks\";\r\n\r\nfunction SearchComponent() {\r\nconst {\r\nsearch,\r\nresults,\r\nisLoading,\r\nsimilarity_scores\r\n} = useVectorSearch<Document>({\r\ncollection: \"documents\",\r\nindex: \"vector_index\"\r\n});\r\n\r\nconst handleSearch = async (query: string) => {\r\nconst results = await search({\r\nquery,\r\nlimit: 10,\r\nthreshold: 0.7 // Minimum similarity score\r\n});\r\nconsole.log(\"Similar documents:\", results);\r\n};\r\n\r\nreturn (\r\n<div>\r\n<SearchInput onSearch={handleSearch} />\r\n{isLoading && <Spinner />}\r\n<SearchResults \r\n        results={results}\r\n        scores={similarity_scores}\r\n      />\r\n</div>\r\n);\r\n}`\r\n}\r\n]} />\r\n\r\n<Info>\r\n  Vector search requires MongoDB Atlas with vector search enabled or a local\r\n  MongoDB instance with the appropriate indexes configured.\r\n</Info>\r\n\r\n## Testing & Development\r\n\r\n### Database Testing\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Test Setup\",\r\n    code: `import pytest\r\nfrom farm.database import init_test_database, cleanup_test_database\r\n\r\n@pytest.fixture(scope=\"session\")\r\nasync def test_db():\r\n\"\"\"Initialize test database\"\"\"\r\nawait init_test_database()\r\nyield\r\nawait cleanup_test_database()\r\n\r\n@pytest.fixture\r\nasync def clean_db():\r\n\"\"\"Clean database between tests\"\"\"\r\nawait User.delete_all()\r\nawait Post.delete_all()\r\nyield\r\n\r\nasync def test_user_creation(clean_db):\r\nuser = User(name=\"Test User\", email=\"test@example.com\")\r\nawait user.create()\r\n\r\n    assert user.id is not None\r\n    assert user.created_at is not None\r\n\r\n    # Verify in database\r\n    found_user = await User.find_one(User.email == \"test@example.com\")\r\n    assert found_user.name == \"Test User\"`\r\n\r\n},\r\n{\r\nlanguage: \"bash\",\r\nlabel: \"Test Commands\",\r\ncode: `# Run database tests\r\nfarm test --db\r\n\r\n# Test with specific database\r\n\r\nfarm test --db postgresql\r\n\r\n# Test migrations\r\n\r\nfarm test --migrations\r\n\r\n# Performance testing\r\n\r\nfarm test --benchmark`\r\n}\r\n]} />\r\n\r\n<Warning>\r\n  Always use a separate test database to avoid affecting your development data.\r\n  FARM automatically configures test databases with the `_test` suffix.\r\n</Warning>\r\n",
      "excerpt": "FARM provides a flexible database layer with MongoDB as the primary choice, while supporting PostgreSQL, MySQL, and SQLite through a unified provider interface.",
      "category": "docs/guide",
      "type": "guide",
      "tags": [
        "mongodb",
        "farm",
        "typescript",
        "python",
        "database"
      ],
      "lastModified": "2025-06-12T21:57:32.794Z",
      "breadcrumbs": [
        "Docs",
        "Guide",
        "Database"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Database Integration",
          "id": "database-integration"
        },
        {
          "level": 2,
          "text": "Database Architecture",
          "id": "database-architecture"
        },
        {
          "level": 2,
          "text": "MongoDB with Beanie ODM",
          "id": "mongodb-with-beanie-odm"
        },
        {
          "level": 3,
          "text": "Model Definition",
          "id": "model-definition"
        },
        {
          "level": 1,
          "text": "Auto-generate CRUD API endpoints",
          "id": "auto-generate-crud-api-endpoints"
        },
        {
          "level": 1,
          "text": "Reverse relationships",
          "id": "reverse-relationships"
        },
        {
          "level": 3,
          "text": "Database Operations",
          "id": "database-operations"
        },
        {
          "level": 1,
          "text": "Read",
          "id": "read"
        },
        {
          "level": 1,
          "text": "Update",
          "id": "update"
        },
        {
          "level": 1,
          "text": "or",
          "id": "or"
        },
        {
          "level": 1,
          "text": "Delete",
          "id": "delete"
        },
        {
          "level": 1,
          "text": "Bulk operations",
          "id": "bulk-operations"
        },
        {
          "level": 1,
          "text": "Complex queries",
          "id": "complex-queries"
        },
        {
          "level": 1,
          "text": "Aggregation",
          "id": "aggregation"
        },
        {
          "level": 1,
          "text": "Transactions",
          "id": "transactions"
        },
        {
          "level": 3,
          "text": "Relationships & References",
          "id": "relationships-references"
        },
        {
          "level": 1,
          "text": "Fetch with relationships",
          "id": "fetch-with-relationships"
        },
        {
          "level": 1,
          "text": "Reverse relationships",
          "id": "reverse-relationships"
        },
        {
          "level": 2,
          "text": "Alternative Database Providers",
          "id": "alternative-database-providers"
        },
        {
          "level": 3,
          "text": "PostgreSQL with SQLAlchemy",
          "id": "postgresql-with-sqlalchemy"
        },
        {
          "level": 1,
          "text": "Same auto-CRUD generation",
          "id": "same-auto-crud-generation"
        },
        {
          "level": 3,
          "text": "Multi-Database Setup",
          "id": "multi-database-setup"
        },
        {
          "level": 1,
          "text": "Configure multiple databases",
          "id": "configure-multiple-databases"
        },
        {
          "level": 1,
          "text": "Primary MongoDB for documents",
          "id": "primary-mongodb-for-documents"
        },
        {
          "level": 1,
          "text": "PostgreSQL for relational data",
          "id": "postgresql-for-relational-data"
        },
        {
          "level": 1,
          "text": "Use specific database",
          "id": "use-specific-database"
        },
        {
          "level": 2,
          "text": "Migrations & Schema Management",
          "id": "migrations-schema-management"
        },
        {
          "level": 3,
          "text": "Automatic Migrations",
          "id": "automatic-migrations"
        },
        {
          "level": 1,
          "text": "Apply pending migrations",
          "id": "apply-pending-migrations"
        },
        {
          "level": 1,
          "text": "Rollback last migration",
          "id": "rollback-last-migration"
        },
        {
          "level": 1,
          "text": "Check migration status",
          "id": "check-migration-status"
        },
        {
          "level": 3,
          "text": "Schema Validation",
          "id": "schema-validation"
        },
        {
          "level": 2,
          "text": "Performance & Optimization",
          "id": "performance-optimization"
        },
        {
          "level": 3,
          "text": "Indexing Strategy",
          "id": "indexing-strategy"
        },
        {
          "level": 1,
          "text": "Batch operations",
          "id": "batch-operations"
        },
        {
          "level": 1,
          "text": "Pagination with cursor",
          "id": "pagination-with-cursor"
        },
        {
          "level": 1,
          "text": "Use aggregation for complex queries",
          "id": "use-aggregation-for-complex-queries"
        },
        {
          "level": 3,
          "text": "Connection Pooling",
          "id": "connection-pooling"
        },
        {
          "level": 2,
          "text": "Vector Search & AI Integration",
          "id": "vector-search-ai-integration"
        },
        {
          "level": 3,
          "text": "Vector Embeddings",
          "id": "vector-embeddings"
        },
        {
          "level": 2,
          "text": "Testing & Development",
          "id": "testing-development"
        },
        {
          "level": 3,
          "text": "Database Testing",
          "id": "database-testing"
        },
        {
          "level": 1,
          "text": "Test with specific database",
          "id": "test-with-specific-database"
        },
        {
          "level": 1,
          "text": "Test migrations",
          "id": "test-migrations"
        },
        {
          "level": 1,
          "text": "Performance testing",
          "id": "performance-testing"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-guide-dev-server",
      "title": "Dev Server",
      "url": "/docs/guide/dev-server",
      "content": "# Development Server\r\n\r\n<Callout type=\"info\" title=\"Unified Development Experience\">\r\n  FARM's development server orchestrates all services - React, FastAPI, MongoDB,\r\n  and AI models - for seamless full-stack development.\r\n</Callout>\r\n\r\nThe `farm dev` command provides a unified development experience that manages multiple services, coordinates hot reloads, and ensures optimal developer productivity.\r\n\r\n## Quick Start\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Start Development\",\r\n    code: `# Start all services\r\nfarm dev\r\n\r\n# Start with verbose logging\r\n\r\nfarm dev --verbose\r\n\r\n# Start specific services only\r\n\r\nfarm dev --frontend-only\r\nfarm dev --backend-only`  },\r\n  {\r\n    language: \"bash\", \r\n    label: \"Service Status\",\r\n    code:`# Check service health\r\nfarm status\r\n\r\n# View service logs\r\n\r\nfarm logs\r\n\r\n# Restart specific service\r\n\r\nfarm restart api`\r\n}\r\n]} />\r\n\r\n## Architecture Overview\r\n\r\nThe development server uses a sophisticated process manager that coordinates multiple services:\r\n\r\n```text\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Development Server                      │\r\n│                         (farm dev)                             │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐  │\r\n│  │   MongoDB   │  │   Ollama    │  │   FastAPI   │  │  React  │  │\r\n│  │   :27017    │  │   :11434    │  │   :8000     │  │  :3000  │  │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘  │\r\n│         │                │                │              │      │\r\n│         └────────────────┼────────────────┼──────────────┘      │\r\n│                          │                │                     │\r\n│  ┌─────────────────────────────────────────────────────────────┐  │\r\n│  │           Service Health Monitor & Log Aggregator          │  │\r\n│  └─────────────────────────────────────────────────────────────┘  │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n## Service Management\r\n\r\n<FeatureList\r\n  features={[\r\n    {\r\n      title: \"Automatic Service Discovery\",\r\n      description: \"Detects available services and their optimal startup order\",\r\n      icon: \"⚡\",\r\n    },\r\n    {\r\n      title: \"Health Monitoring\",\r\n      description: \"Continuous health checks with automatic restart on failure\",\r\n      icon: \"❤️\",\r\n    },\r\n    {\r\n      title: \"Log Aggregation\",\r\n      description: \"Unified logging with color-coded service identification\",\r\n      icon: \"📋\",\r\n    },\r\n    {\r\n      title: \"Hot Reload Coordination\",\r\n      description: \"Intelligent reload triggering across frontend and backend\",\r\n      icon: \"🔄\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n## Configuration\r\n\r\nConfigure development server behavior in `farm.config.ts`:\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Basic Config\",\r\n    code: `// farm.config.ts\r\nimport { defineConfig } from \"@farm/core\";\r\n\r\nexport default defineConfig({\r\n  development: {\r\n    ports: {\r\n      frontend: 3000,\r\n      backend: 8000,\r\n      database: 27017,\r\n      ollama: 11434,\r\n    },\r\n    hotReload: {\r\n      enabled: true,\r\n      typeGeneration: true,\r\n      aiModels: true,\r\n    },\r\n    services: {\r\n      autoStart: [\"database\", \"ollama\", \"backend\", \"frontend\"],\r\n      healthCheck: {\r\n        interval: 5000,\r\n        timeout: 30000,\r\n        retries: 3,\r\n      },\r\n    },\r\n  },\r\n});`\r\n  },\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Advanced Config\",\r\n    code: `// Advanced development configuration\r\nexport default defineConfig({\r\n  development: {\r\n    // Custom service definitions\r\n    services: {\r\n      database: {\r\n        command: \"mongod\",\r\n        args: [\"--dbpath\", \"./data/db\"],\r\n        healthCheck: \"mongodb://localhost:27017\",\r\n        env: { MONGO_INITDB_ROOT_USERNAME: \"admin\" },\r\n      },\r\n      redis: {\r\n        command: \"redis-server\",\r\n        port: 6379,\r\n        optional: true, // Won't fail if unavailable\r\n      },\r\n    },\r\n    \r\n    // Watch configuration\r\n    watch: {\r\n      ignore: [\"**/node_modules/**\", \"**/dist/**\"],\r\n      include: [\"**/*.py\", \"**/*.ts\", \"**/*.tsx\"],\r\n    },\r\n    \r\n    // Proxy configuration\r\n    proxy: {\r\n      \"/api\": \"http://localhost:8000\",\r\n      \"/uploads\": \"http://localhost:8000/static\",\r\n    },\r\n  },\r\n});`\r\n  }\r\n]} />\r\n\r\n## Development Workflow\r\n\r\n### Startup Sequence\r\n\r\nThe development server follows a carefully orchestrated startup sequence:\r\n\r\n<PropertyTable\r\n  properties={[\r\n    {\r\n      name: \"1. Environment Check\",\r\n      type: \"Validation\",\r\n      description: \"Verifies required dependencies and configuration\",\r\n    },\r\n    {\r\n      name: \"2. Database Initialization\",\r\n      type: \"Service\",\r\n      description: \"Starts MongoDB and runs any pending migrations\",\r\n    },\r\n    {\r\n      name: \"3. AI Model Setup\",\r\n      type: \"Service\",\r\n      description: \"Starts Ollama and auto-pulls configured models\",\r\n    },\r\n    {\r\n      name: \"4. Backend Launch\",\r\n      type: \"Service\",\r\n      description: \"Starts FastAPI server with hot reload enabled\",\r\n    },\r\n    {\r\n      name: \"5. Frontend Launch\",\r\n      type: \"Service\",\r\n      description: \"Starts React dev server with Vite\",\r\n    },\r\n    {\r\n      name: \"6. Health Verification\",\r\n      type: \"Validation\",\r\n      description: \"Confirms all services are healthy and responding\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n### Hot Reload System\r\n\r\nFARM's hot reload system intelligently coordinates changes across the full stack:\r\n\r\n<Note>\r\n  **Smart Reload Triggers**: Changes to Python models automatically regenerate\r\n  TypeScript types and trigger frontend hot reload.\r\n</Note>\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"python\",\r\n    label: \"Backend Changes\",\r\n    code: `# When you modify a Pydantic model:\r\nclass User(BaseModel):\r\n    name: str\r\n    email: str\r\n    age: int  # Adding this field\r\n\r\n# Triggers:\r\n\r\n# 1. FastAPI auto-reload\r\n\r\n# 2. TypeScript type regeneration\r\n\r\n# 3. Frontend hot reload with new types`\r\n\r\n},\r\n{\r\nlanguage: \"typescript\",\r\nlabel: \"Frontend Changes\",\r\ncode: `// When you modify React components:\r\nexport function UserProfile({ user }: { user: User }) {\r\nreturn (\r\n<div>\r\n<h1>{user.name}</h1>\r\n<p>{user.email}</p>\r\n<p>Age: {user.age}</p> {/* New field available */}\r\n</div>\r\n);\r\n}\r\n\r\n// Triggers:\r\n// 1. Instant hot reload\r\n// 2. Preserves component state\r\n// 3. Updates in browser immediately`\r\n}\r\n]} />\r\n\r\n## Service Commands\r\n\r\n<ApiMethod method=\"CLI\" endpoint=\"farm dev\">\r\n  Start the complete development environment\r\n</ApiMethod>\r\n\r\n### Options\r\n\r\n<PropertyTable\r\n  properties={[\r\n    {\r\n      name: \"--frontend-only\",\r\n      type: \"boolean\",\r\n      description: \"Start only the React development server\",\r\n    },\r\n    {\r\n      name: \"--backend-only\",\r\n      type: \"boolean\",\r\n      description: \"Start only the FastAPI server and database\",\r\n    },\r\n    {\r\n      name: \"--verbose, -v\",\r\n      type: \"boolean\",\r\n      description: \"Enable verbose logging for all services\",\r\n    },\r\n    {\r\n      name: \"--port <port>\",\r\n      type: \"number\",\r\n      description: \"Override the default frontend port (3000)\",\r\n    },\r\n    {\r\n      name: \"--host <host>\",\r\n      type: \"string\",\r\n      description: \"Bind to specific host (default: localhost)\",\r\n    },\r\n    {\r\n      name: \"--no-open\",\r\n      type: \"boolean\",\r\n      description: \"Don't automatically open browser\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n### Related Commands\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Service Control\",\r\n    code: `# Check service status\r\nfarm status\r\n\r\n# View aggregated logs\r\n\r\nfarm logs\r\n\r\n# View specific service logs\r\n\r\nfarm logs --service api\r\nfarm logs --service frontend\r\n\r\n# Restart services\r\n\r\nfarm restart\r\nfarm restart --service database`  },\r\n  {\r\n    language: \"bash\",\r\n    label: \"Development Tools\",\r\n    code:`# Database management\r\nfarm db migrate\r\nfarm db seed\r\nfarm db studio\r\n\r\n# AI model management\r\n\r\nfarm ml models list\r\nfarm ml models pull llama3.1\r\nfarm ml chat --model llama3.1`\r\n}\r\n]} />\r\n\r\n## Troubleshooting\r\n\r\n### Common Issues\r\n\r\n<Warning>\r\n  **Port Conflicts**: If default ports are in use, FARM will automatically find\r\n  available alternatives and update your configuration.\r\n</Warning>\r\n\r\n<ComparisonTable\r\n  title=\"Service Startup Issues\"\r\n  data={[\r\n    {\r\n      issue: \"MongoDB won't start\",\r\n      cause: \"Port 27017 in use or data directory locked\",\r\n      solution: \"Check for existing MongoDB instances or clear lock files\",\r\n    },\r\n    {\r\n      issue: \"Ollama connection failed\",\r\n      cause: \"Ollama not installed or Docker not available\",\r\n      solution: \"Install Ollama or start Docker Desktop\",\r\n    },\r\n    {\r\n      issue: \"FastAPI import errors\",\r\n      cause: \"Python dependencies not installed\",\r\n      solution: \"Run `pip install -r requirements.txt` in backend directory\",\r\n    },\r\n    {\r\n      issue: \"React build errors\",\r\n      cause: \"Node modules out of sync or TypeScript errors\",\r\n      solution: \"Run `npm install` and check TypeScript compilation\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n### Debug Mode\r\n\r\nEnable comprehensive debugging:\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Debug Commands\",\r\n    code: `# Maximum verbosity\r\nfarm dev --verbose --debug\r\n\r\n# Service-specific debugging\r\n\r\nFARM_DEBUG=1 farm dev\r\n\r\n# Log levels\r\n\r\nFARM_LOG_LEVEL=debug farm dev`\r\n}\r\n]} />\r\n\r\n## Performance Optimization\r\n\r\n### Development Performance\r\n\r\n<FeatureList\r\n  features={[\r\n    {\r\n      title: \"Selective Service Starting\",\r\n      description: \"Use --frontend-only or --backend-only for faster iteration\",\r\n      icon: \"⚡\",\r\n    },\r\n    {\r\n      title: \"Dependency Caching\",\r\n      description: \"Intelligent caching of npm and pip dependencies\",\r\n      icon: \"💾\",\r\n    },\r\n    {\r\n      title: \"Incremental Builds\",\r\n      description: \"Only rebuild changed modules and their dependents\",\r\n      icon: \"🔄\",\r\n    },\r\n    {\r\n      title: \"Memory Management\",\r\n      description:\r\n        \"Automatic memory optimization for long-running dev sessions\",\r\n      icon: \"🧠\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n---\r\n\r\n## Next Steps\r\n\r\n- **[Hot Reload](./hot-reload)** - Deep dive into the hot reload system\r\n- **[Service Configuration](../configuration/services)** - Advanced service setup\r\n- **[Performance Tuning](../advanced/performance)** - Optimization techniques\r\n- **[Debugging](../troubleshooting/debugging)** - Advanced debugging strategies\r\n",
      "excerpt": "<Callout type=\"info\" title=\"Unified Development Experience\">\r\n  FARM's development server orchestrates all services - React, FastAPI, MongoDB,\r\n  and AI models ...",
      "category": "docs/guide",
      "type": "guide",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.794Z",
      "breadcrumbs": [
        "Docs",
        "Guide",
        "Dev Server"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Development Server",
          "id": "development-server"
        },
        {
          "level": 2,
          "text": "Quick Start",
          "id": "quick-start"
        },
        {
          "level": 1,
          "text": "Start with verbose logging",
          "id": "start-with-verbose-logging"
        },
        {
          "level": 1,
          "text": "Start specific services only",
          "id": "start-specific-services-only"
        },
        {
          "level": 1,
          "text": "View service logs",
          "id": "view-service-logs"
        },
        {
          "level": 1,
          "text": "Restart specific service",
          "id": "restart-specific-service"
        },
        {
          "level": 2,
          "text": "Architecture Overview",
          "id": "architecture-overview"
        },
        {
          "level": 2,
          "text": "Service Management",
          "id": "service-management"
        },
        {
          "level": 2,
          "text": "Configuration",
          "id": "configuration"
        },
        {
          "level": 2,
          "text": "Development Workflow",
          "id": "development-workflow"
        },
        {
          "level": 3,
          "text": "Startup Sequence",
          "id": "startup-sequence"
        },
        {
          "level": 3,
          "text": "Hot Reload System",
          "id": "hot-reload-system"
        },
        {
          "level": 1,
          "text": "Triggers:",
          "id": "triggers"
        },
        {
          "level": 1,
          "text": "1. FastAPI auto-reload",
          "id": "1-fastapi-auto-reload"
        },
        {
          "level": 1,
          "text": "2. TypeScript type regeneration",
          "id": "2-typescript-type-regeneration"
        },
        {
          "level": 1,
          "text": "3. Frontend hot reload with new types`",
          "id": "3-frontend-hot-reload-with-new-types"
        },
        {
          "level": 2,
          "text": "Service Commands",
          "id": "service-commands"
        },
        {
          "level": 3,
          "text": "Options",
          "id": "options"
        },
        {
          "level": 3,
          "text": "Related Commands",
          "id": "related-commands"
        },
        {
          "level": 1,
          "text": "View aggregated logs",
          "id": "view-aggregated-logs"
        },
        {
          "level": 1,
          "text": "View specific service logs",
          "id": "view-specific-service-logs"
        },
        {
          "level": 1,
          "text": "Restart services",
          "id": "restart-services"
        },
        {
          "level": 1,
          "text": "AI model management",
          "id": "ai-model-management"
        },
        {
          "level": 2,
          "text": "Troubleshooting",
          "id": "troubleshooting"
        },
        {
          "level": 3,
          "text": "Common Issues",
          "id": "common-issues"
        },
        {
          "level": 3,
          "text": "Debug Mode",
          "id": "debug-mode"
        },
        {
          "level": 1,
          "text": "Service-specific debugging",
          "id": "service-specific-debugging"
        },
        {
          "level": 1,
          "text": "Log levels",
          "id": "log-levels"
        },
        {
          "level": 2,
          "text": "Performance Optimization",
          "id": "performance-optimization"
        },
        {
          "level": 3,
          "text": "Development Performance",
          "id": "development-performance"
        },
        {
          "level": 2,
          "text": "Next Steps",
          "id": "next-steps"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-guide-getting-started",
      "title": "Getting Started",
      "url": "/docs/guide/getting-started",
      "content": "# Getting Started\r\n\r\nThe FARM Stack Framework combines FastAPI, AI tooling, React and MongoDB into a unified full-stack platform.\r\n\r\n## Installation\r\n\r\nFARM is distributed via npm and pip. Install the CLI:\r\n\r\n```bash\r\nnpm install -g farm-cli\r\n```\r\n\r\nCreate a new project:\r\n\r\n```bash\r\nfarm create my-app\r\n```\r\n\r\nThis scaffolds a React frontend and FastAPI backend with optional AI features.\r\n",
      "excerpt": "The FARM Stack Framework combines FastAPI, AI tooling, React and MongoDB into a unified full-stack platform. FARM is distributed via npm and pip.",
      "category": "docs/guide",
      "type": "guide",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "api"
      ],
      "lastModified": "2025-06-12T21:57:32.794Z",
      "breadcrumbs": [
        "Docs",
        "Guide",
        "Getting Started"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Getting Started",
          "id": "getting-started"
        },
        {
          "level": 2,
          "text": "Installation",
          "id": "installation"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-guide-index",
      "title": "Index",
      "url": "/docs/guide",
      "content": "# Guide\r\n\r\nThis section explains core concepts of FARM. Start with [Getting Started](getting-started.md) and explore topics like the [Development Server](dev-server.md) and [AI Integration](ai-integration.md).\r\n",
      "excerpt": "This section explains core concepts of FARM. Start with Getting Started and explore topics like the Development Server and AI Integration. .",
      "category": "docs/guide",
      "type": "guide",
      "tags": [
        "farm"
      ],
      "lastModified": "2025-06-12T21:57:32.794Z",
      "breadcrumbs": [
        "Docs",
        "Guide",
        "Index"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Guide",
          "id": "guide"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-guide-plugin-system",
      "title": "Plugin System",
      "url": "/docs/guide/plugin-system",
      "content": "# Plugin System\r\n\r\n<Callout type=\"info\" title=\"Extensible Architecture\">\r\n  FARM's plugin system enables safe and powerful extensions across all layers -\r\n  frontend, backend, AI, and database.\r\n</Callout>\r\n\r\nThe plugin system allows developers to extend FARM's capabilities through a well-defined architecture that ensures compatibility, security, and maintainability.\r\n\r\n## Quick Start\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Install Plugin\",\r\n    code: `# Install from registry\r\nfarm plugin install @farm/auth\r\n\r\n# Install from npm\r\n\r\nfarm plugin install my-custom-plugin\r\n\r\n# Install from local path\r\n\r\nfarm plugin install ./plugins/my-plugin`  },\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Enable Plugin\",\r\n    code:`// farm.config.ts\r\nimport { defineConfig } from \"@farm/core\";\r\n\r\nexport default defineConfig({\r\n  plugins: [\r\n    \"@farm/auth\",\r\n    [\"@farm/payments\", { provider: \"stripe\" }],\r\n    \"my-custom-plugin\",\r\n  ],\r\n});`\r\n  }\r\n]} />\r\n\r\n## Plugin Architecture\r\n\r\n```text\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    FARM Plugin Ecosystem                       │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐  │\r\n│  │  Frontend   │  │   Backend   │  │     AI      │  │   CLI   │  │\r\n│  │   Plugins   │  │   Plugins   │  │   Plugins   │  │ Plugins │  │\r\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘  │\r\n│         │                │                │              │      │\r\n│         └────────────────┼────────────────┼──────────────┘      │\r\n│                          │                │                     │\r\n│  ┌─────────────────────────────────────────────────────────────┐  │\r\n│  │             Plugin Registry & Lifecycle Manager            │  │\r\n│  └─────────────────────────────────────────────────────────────┘  │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n## Plugin Types\r\n\r\n<FeatureList\r\n  features={[\r\n    {\r\n      title: \"Frontend Plugins\",\r\n      description: \"React components, hooks, and utilities for the client side\",\r\n      icon: \"⚛️\",\r\n    },\r\n    {\r\n      title: \"Backend Plugins\",\r\n      description: \"FastAPI middleware, routes, and business logic extensions\",\r\n      icon: \"🐍\",\r\n    },\r\n    {\r\n      title: \"AI Plugins\",\r\n      description: \"Model integrations, preprocessing, and inference pipelines\",\r\n      icon: \"🤖\",\r\n    },\r\n    {\r\n      title: \"Database Plugins\",\r\n      description: \"ODM extensions, migrations, and data transformation tools\",\r\n      icon: \"🗄️\",\r\n    },\r\n    {\r\n      title: \"CLI Plugins\",\r\n      description: \"Custom commands and development workflow enhancements\",\r\n      icon: \"⌨️\",\r\n    },\r\n    {\r\n      title: \"Full-Stack Plugins\",\r\n      description: \"Complete feature implementations spanning all layers\",\r\n      icon: \"🔗\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n## Creating Plugins\r\n\r\n### Plugin Structure\r\n\r\n<CodeTabs\r\n  examples={[\r\n    {\r\n      language: \"plaintext\",\r\n      label: \"Directory Structure\",\r\n      code: `my-farm-plugin/\r\n├── package.json\r\n├── farm-plugin.json         # Plugin manifest\r\n├── src/\r\n│   ├── index.ts            # Main plugin entry\r\n│   ├── frontend/\r\n│   │   ├── components/     # React components\r\n│   │   ├── hooks/          # Custom hooks\r\n│   │   └── styles/         # CSS/Tailwind styles\r\n│   ├── backend/\r\n│   │   ├── routes/         # FastAPI routes\r\n│   │   ├── models/         # Pydantic models\r\n│   │   └── middleware/     # Custom middleware\r\n│   ├── ai/\r\n│   │   ├── models/         # AI model integrations\r\n│   │   └── processors/     # Data processing\r\n│   └── cli/\r\n│       └── commands/       # CLI commands\r\n├── docs/\r\n│   └── README.md\r\n└── tests/`,\r\n    },\r\n    {\r\n      language: \"json\",\r\n      label: \"Plugin Manifest\",\r\n      code: `{\r\n  \"name\": \"@farm/auth\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"Authentication plugin for FARM\",\r\n  \"type\": \"fullstack\",\r\n  \"farmVersion\": \">=2.0.0\",\r\n  \"dependencies\": {\r\n    \"frontend\": [\"@auth0/nextjs-auth0\"],\r\n    \"backend\": [\"python-jose\", \"passlib\"],\r\n    \"database\": []\r\n  },\r\n  \"configuration\": {\r\n    \"schema\": \"./config-schema.json\",\r\n    \"required\": [\"provider\", \"clientId\"],\r\n    \"optional\": [\"customization\"]\r\n  },\r\n  \"hooks\": {\r\n    \"beforeStart\": \"./hooks/setup.js\",\r\n    \"afterInstall\": \"./hooks/configure.js\"\r\n  },\r\n  \"exports\": {\r\n    \"frontend\": \"./dist/frontend/index.js\",\r\n    \"backend\": \"./dist/backend/index.py\",\r\n    \"cli\": \"./dist/cli/index.js\"\r\n  }\r\n}`,\r\n    },\r\n  ]}\r\n/>\r\n\r\n### Basic Plugin Implementation\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Frontend Plugin\",\r\n    code: `// src/frontend/index.ts\r\nimport { FarmPlugin } from \"@farm/core\";\r\n\r\nexport default class AuthPlugin extends FarmPlugin {\r\n  name = \"@farm/auth\";\r\n  \r\n  // Provide React components\r\n  components = {\r\n    LoginButton: () => import(\"./components/LoginButton\"),\r\n    UserProfile: () => import(\"./components/UserProfile\"),\r\n  };\r\n  \r\n  // Provide custom hooks\r\n  hooks = {\r\n    useAuth: () => import(\"./hooks/useAuth\"),\r\n    useSession: () => import(\"./hooks/useSession\"),\r\n  };\r\n  \r\n  // Plugin lifecycle\r\n  async onInstall() {\r\n    console.log(\"Auth plugin installed\");\r\n  }\r\n  \r\n  async onConfigure(config: any) {\r\n    // Setup authentication provider\r\n    await this.setupProvider(config.provider);\r\n  }\r\n}`\r\n  },\r\n  {\r\n    language: \"python\",\r\n    label: \"Backend Plugin\",\r\n    code: `# src/backend/index.py\r\nfrom farm.core import FarmPlugin\r\nfrom fastapi import FastAPI\r\nfrom .routes import auth_router\r\nfrom .middleware import AuthMiddleware\r\n\r\nclass AuthPlugin(FarmPlugin):\r\nname = \"@farm/auth\"\r\n\r\n    def install(self, app: FastAPI, config: dict):\r\n        # Add authentication middleware\r\n        app.add_middleware(AuthMiddleware, config=config)\r\n\r\n        # Register authentication routes\r\n        app.include_router(auth_router, prefix=\"/auth\")\r\n\r\n        # Setup database models\r\n        self.setup_models()\r\n\r\n    def setup_models(self):\r\n        # Register User model, sessions, etc.\r\n        pass`\r\n\r\n}\r\n]} />\r\n\r\n## Official Plugins\r\n\r\n<PropertyTable\r\n  properties={[\r\n    {\r\n      name: \"@farm/auth\",\r\n      type: \"Full-stack\",\r\n      description:\r\n        \"Complete authentication system with OAuth2, JWT, and session management\",\r\n    },\r\n    {\r\n      name: \"@farm/payments\",\r\n      type: \"Full-stack\",\r\n      description:\r\n        \"Payment processing with Stripe, PayPal, and cryptocurrency support\",\r\n    },\r\n    {\r\n      name: \"@farm/storage\",\r\n      type: \"Backend\",\r\n      description:\r\n        \"File storage with S3, Google Cloud, and local filesystem support\",\r\n    },\r\n    {\r\n      name: \"@farm/analytics\",\r\n      type: \"Full-stack\",\r\n      description:\r\n        \"Analytics and tracking with Google Analytics, Mixpanel integration\",\r\n    },\r\n    {\r\n      name: \"@farm/cms\",\r\n      type: \"Full-stack\",\r\n      description:\r\n        \"Content management system with rich text editing and media handling\",\r\n    },\r\n    {\r\n      name: \"@farm/notifications\",\r\n      type: \"Full-stack\",\r\n      description: \"Push notifications, email, and SMS messaging capabilities\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n## Plugin Configuration\r\n\r\n### Schema Validation\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"json\",\r\n    label: \"Config Schema\",\r\n    code: `{\r\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r\n  \"type\": \"object\",\r\n  \"properties\": {\r\n    \"provider\": {\r\n      \"type\": \"string\",\r\n      \"enum\": [\"auth0\", \"firebase\", \"custom\"],\r\n      \"description\": \"Authentication provider\"\r\n    },\r\n    \"clientId\": {\r\n      \"type\": \"string\",\r\n      \"description\": \"OAuth client ID\"\r\n    },\r\n    \"customization\": {\r\n      \"type\": \"object\",\r\n      \"properties\": {\r\n        \"theme\": { \"type\": \"string\" },\r\n        \"logoUrl\": { \"type\": \"string\" }\r\n      }\r\n    }\r\n  },\r\n  \"required\": [\"provider\", \"clientId\"]\r\n}`\r\n  },\r\n  {\r\n    language: \"typescript\",\r\n    label: \"Type-Safe Config\",\r\n    code: `// Auto-generated from schema\r\ninterface AuthPluginConfig {\r\n  provider: \"auth0\" | \"firebase\" | \"custom\";\r\n  clientId: string;\r\n  customization?: {\r\n    theme?: string;\r\n    logoUrl?: string;\r\n  };\r\n}\r\n\r\n// Usage in farm.config.ts\r\nexport default defineConfig({\r\nplugins: [\r\n[\"@farm/auth\", {\r\nprovider: \"auth0\",\r\nclientId: process.env.AUTH0_CLIENT_ID,\r\ncustomization: {\r\ntheme: \"dark\",\r\nlogoUrl: \"/logo.png\"\r\n}\r\n} satisfies AuthPluginConfig]\r\n]\r\n});`\r\n}\r\n]} />\r\n\r\n## Plugin Lifecycle\r\n\r\n<PropertyTable\r\n  properties={[\r\n    {\r\n      name: \"onInstall\",\r\n      type: \"Hook\",\r\n      description: \"Called when plugin is first installed\",\r\n    },\r\n    {\r\n      name: \"onConfigure\",\r\n      type: \"Hook\",\r\n      description: \"Called when plugin configuration changes\",\r\n    },\r\n    {\r\n      name: \"beforeStart\",\r\n      type: \"Hook\",\r\n      description: \"Called before development server starts\",\r\n    },\r\n    {\r\n      name: \"afterStart\",\r\n      type: \"Hook\",\r\n      description: \"Called after all services are running\",\r\n    },\r\n    {\r\n      name: \"beforeBuild\",\r\n      type: \"Hook\",\r\n      description: \"Called before production build\",\r\n    },\r\n    {\r\n      name: \"afterBuild\",\r\n      type: \"Hook\",\r\n      description: \"Called after build completion\",\r\n    },\r\n    {\r\n      name: \"onUninstall\",\r\n      type: \"Hook\",\r\n      description: \"Called when plugin is removed\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n## Plugin Registry\r\n\r\n### Publishing Plugins\r\n\r\n<CodeTabs examples={[\r\n  {\r\n    language: \"bash\",\r\n    label: \"Publish to Registry\",\r\n    code: `# Build plugin\r\nnpm run build\r\n\r\n# Test plugin locally\r\n\r\nfarm plugin test\r\n\r\n# Publish to FARM registry\r\n\r\nfarm plugin publish\r\n\r\n# Publish to npm (also discoverable)\r\n\r\nnpm publish`  },\r\n  {\r\n    language: \"bash\",\r\n    label: \"Registry Commands\",\r\n    code:`# Search for plugins\r\nfarm plugin search auth\r\n\r\n# Get plugin info\r\n\r\nfarm plugin info @farm/auth\r\n\r\n# List installed plugins\r\n\r\nfarm plugin list\r\n\r\n# Update plugins\r\n\r\nfarm plugin update`\r\n}\r\n]} />\r\n\r\n### Community Guidelines\r\n\r\n<Note>\r\n  **Plugin Review Process**: All plugins in the official registry undergo\r\n  security and quality review to ensure they meet FARM standards.\r\n</Note>\r\n\r\n<FeatureList\r\n  features={[\r\n    {\r\n      title: \"Security First\",\r\n      description: \"Plugins are sandboxed and undergo security review\",\r\n      icon: \"🔒\",\r\n    },\r\n    {\r\n      title: \"Documentation Required\",\r\n      description: \"Comprehensive docs and examples are mandatory\",\r\n      icon: \"📚\",\r\n    },\r\n    {\r\n      title: \"Testing Standards\",\r\n      description: \"Plugins must include comprehensive test suites\",\r\n      icon: \"🧪\",\r\n    },\r\n    {\r\n      title: \"Version Compatibility\",\r\n      description: \"Clear compatibility matrix with FARM versions\",\r\n      icon: \"📊\",\r\n    },\r\n  ]}\r\n/>\r\n\r\n## Advanced Topics\r\n\r\n### Plugin Development\r\n\r\n<Warning>\r\n  **Breaking Changes**: Plugin APIs are stable but may evolve. Always specify\r\n  compatible FARM versions in your manifest.\r\n</Warning>\r\n\r\n<CodeTabs\r\n  examples={[\r\n    {\r\n      language: \"typescript\",\r\n      label: \"Advanced Plugin\",\r\n      code: `// Complex plugin with custom hooks\r\nexport default class AdvancedPlugin extends FarmPlugin {\r\n  // Plugin dependencies\r\n  dependencies = [\"@farm/auth\"];\r\n  \r\n  // Custom configuration validation\r\n  validateConfig(config: any) {\r\n    // Custom validation logic\r\n    return config.apiKey?.length > 10;\r\n  }\r\n  \r\n  // Inter-plugin communication\r\n  async onPluginLoaded(pluginName: string) {\r\n    if (pluginName === \"@farm/auth\") {\r\n      // Integrate with auth plugin\r\n      await this.setupAuthIntegration();\r\n    }\r\n  }\r\n  \r\n  // Custom CLI commands\r\n  cliCommands = {\r\n    \"my-command\": \"./cli/my-command.js\"\r\n  };\r\n}`,\r\n    },\r\n  ]}\r\n/>\r\n\r\n---\r\n\r\n## Next Steps\r\n\r\n- **[Plugin Development Guide](../advanced/plugin-development)** - In-depth plugin creation\r\n- **[Plugin Security](../advanced/plugin-security)** - Security best practices\r\n- **[Plugin Testing](../advanced/plugin-testing)** - Testing strategies\r\n- **[Contributing Plugins](../community/contributing)** - Contribute to the ecosystem\r\n",
      "excerpt": "<Callout type=\"info\" title=\"Extensible Architecture\">\r\n  FARM's plugin system enables safe and powerful extensions across all layers -\r\n  frontend, backend, AI,...",
      "category": "docs/guide",
      "type": "guide",
      "tags": [
        "fastapi",
        "react",
        "farm",
        "typescript",
        "python"
      ],
      "lastModified": "2025-06-12T21:57:32.795Z",
      "breadcrumbs": [
        "Docs",
        "Guide",
        "Plugin System"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Plugin System",
          "id": "plugin-system"
        },
        {
          "level": 2,
          "text": "Quick Start",
          "id": "quick-start"
        },
        {
          "level": 1,
          "text": "Install from npm",
          "id": "install-from-npm"
        },
        {
          "level": 1,
          "text": "Install from local path",
          "id": "install-from-local-path"
        },
        {
          "level": 2,
          "text": "Plugin Architecture",
          "id": "plugin-architecture"
        },
        {
          "level": 2,
          "text": "Plugin Types",
          "id": "plugin-types"
        },
        {
          "level": 2,
          "text": "Creating Plugins",
          "id": "creating-plugins"
        },
        {
          "level": 3,
          "text": "Plugin Structure",
          "id": "plugin-structure"
        },
        {
          "level": 3,
          "text": "Basic Plugin Implementation",
          "id": "basic-plugin-implementation"
        },
        {
          "level": 2,
          "text": "Official Plugins",
          "id": "official-plugins"
        },
        {
          "level": 2,
          "text": "Plugin Configuration",
          "id": "plugin-configuration"
        },
        {
          "level": 3,
          "text": "Schema Validation",
          "id": "schema-validation"
        },
        {
          "level": 2,
          "text": "Plugin Lifecycle",
          "id": "plugin-lifecycle"
        },
        {
          "level": 2,
          "text": "Plugin Registry",
          "id": "plugin-registry"
        },
        {
          "level": 3,
          "text": "Publishing Plugins",
          "id": "publishing-plugins"
        },
        {
          "level": 1,
          "text": "Test plugin locally",
          "id": "test-plugin-locally"
        },
        {
          "level": 1,
          "text": "Publish to FARM registry",
          "id": "publish-to-farm-registry"
        },
        {
          "level": 1,
          "text": "Publish to npm (also discoverable)",
          "id": "publish-to-npm-also-discoverable"
        },
        {
          "level": 1,
          "text": "Get plugin info",
          "id": "get-plugin-info"
        },
        {
          "level": 1,
          "text": "List installed plugins",
          "id": "list-installed-plugins"
        },
        {
          "level": 1,
          "text": "Update plugins",
          "id": "update-plugins"
        },
        {
          "level": 3,
          "text": "Community Guidelines",
          "id": "community-guidelines"
        },
        {
          "level": 2,
          "text": "Advanced Topics",
          "id": "advanced-topics"
        },
        {
          "level": 3,
          "text": "Plugin Development",
          "id": "plugin-development"
        },
        {
          "level": 2,
          "text": "Next Steps",
          "id": "next-steps"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-index",
      "title": "Index",
      "url": "/docs",
      "content": "<Hero />\n\n<Card className=\"my-8\">\n  <CardContent>\n    Welcome to the FARM documentation. A modern, AI-first full-stack framework\n    that bridges React/TypeScript frontends with Python/FastAPI backends,\n    optimized for AI/ML workloads.\n  </CardContent>\n</Card>\n\n## What is FARM?\n\nThe FARM Stack Framework is a unified development platform that seamlessly integrates:\n\n- **F**astAPI - Modern, fast Python web framework with automatic API documentation\n- **A**I/ML - Built-in support for Ollama (local), OpenAI, HuggingFace, and GPU inference\n- **R**eact - Component-based frontend with TypeScript and modern tooling\n- **M**ongoDB - Document database with ODM integration and flexible schema support\n\n<FeatureList\n  features={[\n    {\n      title: \"AI-First Architecture\",\n      description:\n        \"Built-in GPU support, model inference, and ML pipeline integration with seamless provider switching\",\n      icon: \"🤖\",\n    },\n    {\n      title: \"Type-Safe Full-Stack\",\n      description:\n        \"Automatic client generation and end-to-end type safety from database to frontend\",\n      icon: \"🛡️\",\n    },\n    {\n      title: \"Modern Tooling\",\n      description:\n        \"Vite-powered frontend, FastAPI backend, intelligent hot-reload, and unified CLI\",\n      icon: \"⚡\",\n    },\n    {\n      title: \"Production Ready\",\n      description:\n        \"Enterprise-grade performance, security, scalability, and deployment options\",\n      icon: \"🚀\",\n    },\n  ]}\n/>\n\n## Quick Start\n\nGet started with FARM in minutes:\n\n<CodeTabs examples={[\n  {\n    language: \"bash\",\n    label: \"Create Project\",\n    code: `# Install FARM CLI\nnpm install -g @farm/cli\n\n# Create new project\n\nfarm create my-app\ncd my-app\n\n# Start development server\n\nfarm dev`  },\n  {\n    language: \"bash\", \n    label: \"With Template\",\n    code:`# Create AI chat app\nfarm create my-chat --template ai-chat\n\n# Create with specific features\n\nfarm create my-app --features auth,ai,realtime\n\n# List available templates\n\nfarm templates list`\n}\n]} />\n\n<Callout type=\"tip\" title=\"Local AI Development\">\n  FARM includes Ollama integration for zero-cost, offline AI development. Models\n  are automatically downloaded and managed for you.\n</Callout>\n\n## Core Documentation\n\n<div className=\"grid grid-cols-1 md:grid-cols-2 gap-6 my-8\">\n\n<Card>\n<CardHeader>\n<CardTitle>🚀 Getting Started</CardTitle>\n</CardHeader>\n<CardContent>\nInstallation, project setup, and your first FARM application.\n\n[Get Started →](/docs/getting-started)\n\n</CardContent>\n</Card>\n\n<Card>\n<CardHeader>\n<CardTitle>🏗️ Architecture</CardTitle>\n</CardHeader>\n<CardContent>\nCore concepts, project structure, and framework architecture.\n\n[Learn Architecture →](/docs/guide/architecture)\n\n</CardContent>\n</Card>\n\n<Card>\n<CardHeader>\n<CardTitle>🤖 AI Integration</CardTitle>\n</CardHeader>\n<CardContent>\nMulti-provider AI setup, local models with Ollama, and production deployment.\n\n[Explore AI →](/docs/guide/ai-integration)\n\n</CardContent>\n</Card>\n\n<Card>\n<CardHeader>\n<CardTitle>🗄️ Database</CardTitle>\n</CardHeader>\n<CardContent>\nMongoDB with Beanie ODM, relationships, migrations, and performance optimization.\n\n[Database Guide →](/docs/guide/database)\n\n</CardContent>\n</Card>\n\n<Card>\n<CardHeader>\n<CardTitle>⚙️ Configuration</CardTitle>\n</CardHeader>\n<CardContent>\nTypeScript-first config, environment setup, and deployment options.\n\n[Configuration →](/docs/configuration/)\n\n</CardContent>\n</Card>\n\n<Card>\n<CardHeader>\n<CardTitle>🛠️ CLI Reference</CardTitle>\n</CardHeader>\n<CardContent>\nComplete CLI command reference with examples and parameters.\n\n[CLI Docs →](/docs/api/cli)\n\n</CardContent>\n</Card>\n\n</div>\n\n## Framework Guides\n\n<div className=\"grid grid-cols-1 md:grid-cols-3 gap-4 my-8\">\n\n<Card className=\"h-full\">\n  <CardContent className=\"pt-6\">\n    <h3 className=\"font-semibold mb-2\">📝 Code Generation</h3>\n    <div className=\"text-sm text-muted-foreground mb-4\">\n      Automatic type generation, API routes, and React hooks\n    </div>\n    [Code Generation →](/docs/guide/code-generation)\n  </CardContent>\n</Card>\n\n<Card className=\"h-full\">\n  <CardContent className=\"pt-6\">\n    <h3 className=\"font-semibold mb-2\">🔌 Plugin System</h3>\n    <div className=\"text-sm text-muted-foreground mb-4\">\n      Extend functionality with official and community plugins\n    </div>\n    [Plugin System →](/docs/guide/plugin-system)\n  </CardContent>\n</Card>\n\n<Card className=\"h-full\">\n  <CardContent className=\"pt-6\">\n    <h3 className=\"font-semibold mb-2\">🚀 Deployment</h3>\n    <div className=\"text-sm text-muted-foreground mb-4\">\n      Docker, cloud platforms, and production optimization\n    </div>\n    [Deployment →](/docs/deployment/)\n  </CardContent>\n</Card>\n\n</div>\n\n## Advanced Topics\n\n<div className=\"space-y-4 my-8\">\n\n- [**Advanced Architecture**](/docs/advanced/architecture) - Monorepo structure, request flow, and scalability patterns\n- [**Performance Optimization**](/docs/advanced/performance) - Database tuning, caching, and production optimization\n- [**Security Best Practices**](/docs/advanced/security) - Authentication, authorization, and security hardening\n- [**Enterprise Features**](/docs/advanced/enterprise) - Multi-tenancy, monitoring, and enterprise support\n\n</div>\n\n## Community & Support\n\n<div className=\"grid grid-cols-1 md:grid-cols-2 gap-6 my-8\">\n\n<Card>\n<CardHeader>\n<CardTitle>💬 Get Help</CardTitle>  \n</CardHeader>\n<CardContent>\nJoin our Discord community for real-time support and discussions.\n\n[Join Discord →](https://discord.gg/JmeShQtv)\n\n</CardContent>\n</Card>\n\n<Card>\n<CardHeader>\n<CardTitle>🐛 Report Issues</CardTitle>\n</CardHeader>\n<CardContent>\nFound a bug or have a feature request? Let us know on GitHub.\n\n[GitHub Issues →](https://github.com/cstannahill/farm-framework/farm/issues)\n\n</CardContent>\n</Card>\n\n</div>\n\n---\n\n<Note>\n  **New to FARM?** Start with our [Getting Started guide](/docs/getting-started)\n  to build your first application in under 10 minutes.\n</Note>\n",
      "excerpt": "<Hero />\n\n<Card className=\"my-8\">\n  <CardContent>\n    Welcome to the FARM documentation.",
      "category": "docs",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.795Z",
      "breadcrumbs": [
        "Docs",
        "Index"
      ],
      "headings": [
        {
          "level": 2,
          "text": "What is FARM?",
          "id": "what-is-farm"
        },
        {
          "level": 2,
          "text": "Quick Start",
          "id": "quick-start"
        },
        {
          "level": 1,
          "text": "Create new project",
          "id": "create-new-project"
        },
        {
          "level": 1,
          "text": "Start development server",
          "id": "start-development-server"
        },
        {
          "level": 1,
          "text": "Create with specific features",
          "id": "create-with-specific-features"
        },
        {
          "level": 1,
          "text": "List available templates",
          "id": "list-available-templates"
        },
        {
          "level": 2,
          "text": "Core Documentation",
          "id": "core-documentation"
        },
        {
          "level": 2,
          "text": "Framework Guides",
          "id": "framework-guides"
        },
        {
          "level": 2,
          "text": "Advanced Topics",
          "id": "advanced-topics"
        },
        {
          "level": 2,
          "text": "Community & Support",
          "id": "community-support"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-migration-index",
      "title": "Index",
      "url": "/docs/migration",
      "content": "# Migration & Upgrade Strategy\r\n\r\nAutomated tools detect version changes, apply migrations and provide rollback capabilities so the framework can evolve with minimal disruption.\r\n",
      "excerpt": "Automated tools detect version changes, apply migrations and provide rollback capabilities so the framework can evolve with minimal disruption. .",
      "category": "docs/migration",
      "type": "reference",
      "tags": [],
      "lastModified": "2025-06-12T21:57:32.795Z",
      "breadcrumbs": [
        "Docs",
        "Migration",
        "Index"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Migration & Upgrade Strategy",
          "id": "migration-upgrade-strategy"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-migration-README",
      "title": "README",
      "url": "/docs/migration/README",
      "content": "# Migration\r\n\r\nGuides for upgrading projects between FARM versions.\r\n",
      "excerpt": "Guides for upgrading projects between FARM versions. .",
      "category": "docs/migration",
      "type": "reference",
      "tags": [
        "farm"
      ],
      "lastModified": "2025-06-12T21:57:32.796Z",
      "breadcrumbs": [
        "Docs",
        "Migration",
        "README"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Migration",
          "id": "migration"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-old-readme",
      "title": "Old Readme",
      "url": "/docs/old-readme",
      "content": "# FARM Stack Framework\r\n\r\n## AI-First Full-Stack Development Platform\r\n\r\n### Table of Contents\r\n\r\n1. [Overview](#overview)\r\n2. [Core Architecture](#core-architecture)\r\n3. [Framework Components](#framework-components)\r\n4. [Development Experience](#development-experience)\r\n5. [AI/ML Integration](#aiml-integration)\r\n6. [Database Layer](#database-layer)\r\n7. [Type Safety & Code Generation](#type-safety--code-generation)\r\n8. [CLI & Tooling](#cli--tooling)\r\n9. [Configuration System](#configuration-system)\r\n10. [Deployment & Production](#deployment--production)\r\n11. [Plugin Architecture](#plugin-architecture)\r\n12. [Community & Ecosystem](#community--ecosystem)\r\n\r\n---\r\n\r\n## Overview\r\n\r\n### Vision Statement\r\n\r\nThe FARM Stack Framework is a general-purpose, AI-first full-stack development platform that seamlessly integrates React/TypeScript frontends with Python/FastAPI backends, optimized for modern AI/ML workloads. It provides the developer experience quality of Next.js while bridging the gap between web development's most powerful frontend ecosystem (React) and AI/ML's most advanced backend ecosystem (Python).\r\n\r\n### Core Value Proposition\r\n\r\n- **Unified Development Experience**: Single framework, single CLI, single deployment\r\n- **AI-First Architecture**: Built-in GPU support, model inference, and ML pipeline integration\r\n- **Type-Safe Full-Stack**: Automatic client generation and end-to-end type safety\r\n- **Modern Tooling**: Vite-powered frontend, FastAPI backend, intelligent hot-reload\r\n- **Flexible Data Layer**: MongoDB-first with database-agnostic options\r\n- **Production Ready**: Enterprise-grade performance, security, and scalability\r\n\r\n### Technology Foundation\r\n\r\n- **F**astAPI - Modern, fast Python web framework with automatic API documentation\r\n- **A**I/ML - Built-in support for Ollama (local), OpenAI, HuggingFace, and GPU inference\r\n- **R**eact - Component-based frontend with TypeScript and modern tooling\r\n- **M**ongoDB - Document database with ODM integration and flexible schema support\r\n\r\n---\r\n\r\n## Core Architecture\r\n\r\n### Monorepo Structure\r\n\r\n```plaintext\r\nfarm-app/\r\n├── apps/\r\n│   ├── web/                    # React/TypeScript frontend\r\n│   │   ├── src/\r\n│   │   │   ├── components/     # Reusable UI components\r\n│   │   │   ├── pages/          # Page components with routing\r\n│   │   │   ├── hooks/          # Custom React hooks\r\n│   │   │   ├── stores/         # State management (Zustand)\r\n│   │   │   ├── services/       # API client services (auto-generated)\r\n│   │   │   ├── types/          # TypeScript definitions (auto-generated)\r\n│   │   │   └── utils/          # Frontend utilities\r\n│   │   ├── public/             # Static assets\r\n│   │   └── package.json\r\n│   └── api/                    # FastAPI backend\r\n│       ├── src/\r\n│       │   ├── routes/         # API route handlers\r\n│       │   ├── models/         # Pydantic models & database schemas\r\n│       │   ├── services/       # Business logic layer\r\n│       │   ├── ml/             # AI/ML inference services\r\n│       │   ├── database/       # Database connection & ODM\r\n│       │   ├── auth/           # Authentication & authorization\r\n│       │   └── core/           # Core utilities & configuration\r\n│       ├── tests/              # Backend test suite\r\n│       └── pyproject.toml\r\n├── packages/\r\n│   ├── shared-types/           # Shared TypeScript/Python type definitions\r\n│   ├── ui-components/          # Reusable UI component library\r\n│   └── ml-utils/               # Common ML utilities and models\r\n├── tools/\r\n│   ├── farm-cli/               # Framework CLI tool\r\n│   ├── codegen/                # Type generation and client creation\r\n│   └── dev-server/             # Unified development server\r\n├── farm.config.ts              # Framework configuration\r\n├── docker-compose.yml          # Local development environment\r\n└── package.json                # Workspace root configuration\r\n```\r\n\r\n### Request Flow Architecture\r\n\r\n```plaintext\r\n┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐\r\n│   React App     │───▶│   FastAPI        │───▶│   MongoDB       │\r\n│   (TypeScript)  │    │   (Python)       │    │   (Database)    │\r\n└─────────────────┘    └──────────────────┘    └─────────────────┘\r\n        │                        │                        │\r\n        │                        ▼                        │\r\n        │              ┌──────────────────┐               │\r\n        │              │   ML Services    │               │\r\n        │              │   (GPU/CPU)      │               │\r\n        │              └──────────────────┘               │\r\n        │                        │                        │\r\n        ▼                        ▼                        ▼\r\n┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐\r\n│   Vite Build    │    │   Docker         │    │   Vector DB     │\r\n│   System        │    │   Containers     │    │   (Optional)    │\r\n└─────────────────┘    └──────────────────┘    └─────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Framework Components\r\n\r\n### 1. Frontend Layer (React/TypeScript)\r\n\r\n- **Modern React**: React 18+ with Concurrent Features, Suspense, and Server Components support\r\n- **TypeScript**: Full type safety across the application\r\n- **Vite**: Lightning-fast build tool with HMR and optimized production builds\r\n- **State Management**: Zustand for client state, TanStack Query for server state\r\n- **UI Framework**: Headless UI components with Tailwind CSS styling\r\n- **Routing**: File-based routing system inspired by Next.js\r\n\r\n### 2. Backend Layer (FastAPI)\r\n\r\n- **FastAPI**: Modern Python web framework with automatic OpenAPI documentation\r\n- **Async Support**: Full async/await support for high-performance I/O operations\r\n- **Dependency Injection**: Built-in DI system for services and database connections\r\n- **Background Tasks**: Celery integration for async task processing\r\n- **WebSocket Support**: Real-time communication for AI streaming responses\r\n- **Security**: JWT authentication, OAuth2, rate limiting, and CORS handling\r\n\r\n### 3. AI/ML Integration Layer\r\n\r\n- **Local AI Development**: Ollama integration for zero-cost, offline AI development\r\n- **Multi-Provider Support**: Seamless switching between Ollama, OpenAI, and HuggingFace\r\n- **Model Serving**: Automated model download, caching, and serving infrastructure\r\n- **GPU Acceleration**: CUDA support with automatic GPU detection and allocation\r\n- **Inference Pipeline**: Optimized model loading, caching, and batch processing\r\n- **Streaming Responses**: Real-time AI output streaming to frontend with WebSocket support\r\n- **Provider Routing**: Environment-based provider switching (Ollama dev → OpenAI prod)\r\n- **Vector Operations**: Built-in vector database integration for embedding storage\r\n\r\n### 4. Database Layer (MongoDB + ODM)\r\n\r\n- **MongoDB**: Primary database with flexible document schema\r\n- **Beanie ODM**: Modern async ODM for Python with Pydantic integration\r\n- **Schema Validation**: Automatic validation using Pydantic models\r\n- **Migration System**: Database migration tools for schema evolution\r\n- **Connection Pooling**: Optimized connection management for production\r\n- **Database Agnostic**: Plugin system for PostgreSQL, MySQL, and other databases\r\n\r\n---\r\n\r\n## Development Experience\r\n\r\n### Unified CLI Commands\r\n\r\n```bash\r\n# Project creation\r\nfarm create my-app\r\nfarm create my-app --template ai-chat\r\nfarm create my-app --template ecommerce\r\n\r\n# Development\r\nfarm dev                    # Start full-stack development server\r\nfarm dev --frontend-only    # Frontend only\r\nfarm dev --backend-only     # Backend only\r\n\r\n# Code generation\r\nfarm generate model User    # Generate model + API + frontend types\r\nfarm generate page users    # Generate CRUD page with components\r\nfarm generate api auth      # Generate authentication endpoints\r\n\r\n# Database operations\r\nfarm db migrate            # Run database migrations\r\nfarm db seed              # Seed database with sample data\r\nfarm db studio            # Open database GUI\r\n\r\n# AI/ML operations\r\nfarm ml models list [--provider ollama|openai]  # List available models\r\nfarm ml models pull <model> [--provider ollama]  # Download Ollama model\r\nfarm ml models remove <model>                    # Remove local model\r\nfarm ml chat [--model <model>] [--provider ollama] # Interactive chat session\r\nfarm ml benchmark <model>                       # Performance testing\r\n\r\n# Build and deployment\r\nfarm build                 # Build for production\r\nfarm deploy               # Deploy to configured platform\r\nfarm docker build         # Build Docker containers\r\n```\r\n\r\n### Hot Reload & Development Server\r\n\r\n- **Intelligent HMR**: Changes to Python models automatically update TypeScript types\r\n- **API Watching**: Backend changes trigger frontend API client regeneration\r\n- **Database Sync**: Model changes automatically update database schemas\r\n- **ML Model Hot-Swap**: Update ML models without server restart\r\n- **Error Boundaries**: Comprehensive error handling with detailed stack traces\r\n\r\n### Developer Tools Integration\r\n\r\n- **VS Code Extension**: Syntax highlighting, IntelliSense, and debugging\r\n- **Type Checking**: Real-time TypeScript and mypy integration\r\n- **Linting**: ESLint, Prettier, Black, and isort configured out-of-the-box\r\n- **Testing**: Jest, Playwright, pytest with coverage reporting\r\n- **Debugging**: Integrated debugger for both frontend and backend\r\n\r\n---\r\n\r\n## AI/ML Integration\r\n\r\n### Built-in AI Services\r\n\r\n```python\r\n# Multi-provider AI integration with Ollama support\r\nfrom farm.ai import AIProvider, ChatMessage\r\n\r\n# Ollama provider (local development)\r\nollama = AIProvider.get('ollama')\r\nresponse = await ollama.chat([\r\n    ChatMessage(role=\"user\", content=\"Hello!\")\r\n], model=\"llama3.1\")\r\n\r\n# OpenAI provider (production)\r\nopenai = AIProvider.get('openai')\r\nresponse = await openai.chat([\r\n    ChatMessage(role=\"user\", content=\"Hello!\")\r\n], model=\"gpt-3.5-turbo\")\r\n\r\n# Provider routing based on environment\r\n@app.post(\"/chat\")\r\nasync def chat_endpoint(request: ChatRequest):\r\n    provider = AIProvider.get_default()  # Ollama in dev, OpenAI in prod\r\n    response = await provider.chat(request.messages, request.model)\r\n    return {\"response\": response}\r\n```\r\n\r\n### Frontend AI Hooks\r\n\r\n```typescript\r\n// React hooks for AI operations (auto-generated)\r\nimport { useStreamingChat, useAIModels, useAIHealth } from \"@farm/ai-hooks\";\r\n\r\nfunction ChatComponent() {\r\n  // Defaults to Ollama in development, OpenAI in production\r\n  const { messages, sendMessage, isStreaming } = useStreamingChat({\r\n    provider: \"ollama\", // or 'openai'\r\n    model: \"llama3.1\",\r\n    onMessage: (message) => console.log(\"New message:\", message),\r\n  });\r\n\r\n  const { data: models } = useAIModels(\"ollama\");\r\n  const { data: health } = useAIHealth();\r\n\r\n  return (\r\n    <div>\r\n      <div>Available models: {models?.map((m) => m.name).join(\", \")}</div>\r\n      <div>Ollama status: {health?.ollama?.status}</div>\r\n      <ChatMessages messages={messages} />\r\n      <ChatInput onSend={sendMessage} disabled={isStreaming} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n### GPU Management & Local AI\r\n\r\n- **Ollama Integration**: Automatic Docker container management for local AI models\r\n- **Model Auto-Download**: Configured models are automatically pulled on first startup\r\n- **GPU Detection**: Framework detects available GPUs and configures Ollama accordingly\r\n- **Memory Management**: Intelligent GPU memory allocation across multiple models\r\n- **Fallback Support**: Graceful degradation to CPU when GPU unavailable\r\n- **Provider Switching**: Seamless fallback from local (Ollama) to cloud (OpenAI) providers\r\n\r\n---\r\n\r\n## Database Layer\r\n\r\n### MongoDB Integration\r\n\r\n```python\r\n# Model definition with automatic API generation\r\nfrom farm.database import Document, Field\r\nfrom farm.api import auto_crud\r\n\r\nclass User(Document):\r\n    name: str = Field(..., description=\"User's full name\")\r\n    email: str = Field(..., unique=True)\r\n    preferences: dict = Field(default_factory=dict)\r\n\r\n    class Settings:\r\n        collection = \"users\"\r\n        indexes = [\"email\", \"name\"]\r\n\r\n# Automatic CRUD API generation\r\nuser_router = auto_crud(User, prefix=\"/users\")\r\napp.include_router(user_router)\r\n```\r\n\r\n### TypeScript Integration\r\n\r\n```typescript\r\n// Auto-generated TypeScript types\r\nexport interface User {\r\n  _id: string;\r\n  name: string;\r\n  email: string;\r\n  preferences: Record<string, any>;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n// Auto-generated API client\r\nexport const userApi = {\r\n  create: (data: CreateUserRequest) => post<User>(\"/api/users\", data),\r\n  getById: (id: string) => get<User>(`/api/users/${id}`),\r\n  update: (id: string, data: UpdateUserRequest) =>\r\n    patch<User>(`/api/users/${id}`, data),\r\n  delete: (id: string) => del(`/api/users/${id}`),\r\n  list: (params?: ListParams) =>\r\n    get<PaginatedResponse<User>>(\"/api/users\", { params }),\r\n};\r\n```\r\n\r\n### Database Flexibility\r\n\r\n```typescript\r\n// farm.config.ts - Database configuration\r\nimport { defineConfig } from \"@farm/core\";\r\n\r\nexport default defineConfig({\r\n  database: {\r\n    // MongoDB (default)\r\n    type: \"mongodb\",\r\n    url: process.env.MONGODB_URL,\r\n\r\n    // PostgreSQL option\r\n    // type: 'postgresql',\r\n    // url: process.env.DATABASE_URL,\r\n\r\n    // SQLite option\r\n    // type: 'sqlite',\r\n    // file: './database.db'\r\n  },\r\n});\r\n```\r\n\r\n---\r\n\r\n## Type Safety & Code Generation\r\n\r\n### Automatic Code Generation Pipeline\r\n\r\n1. **Schema Analysis**: Parse Pydantic models and FastAPI routes\r\n2. **OpenAPI Generation**: Create comprehensive API documentation\r\n3. **TypeScript Generation**: Generate interfaces, types, and API clients\r\n4. **React Hook Generation**: Create custom hooks for API operations\r\n5. **Form Generation**: Auto-generate forms with validation\r\n6. **Test Generation**: Create basic test suites for new endpoints\r\n\r\n### Type-Safe API Contracts\r\n\r\n```python\r\n# Backend: Pydantic models define the contract\r\nclass CreatePostRequest(BaseModel):\r\n    title: str = Field(..., min_length=1, max_length=200)\r\n    content: str = Field(..., min_length=1)\r\n    tags: List[str] = Field(default_factory=list)\r\n    published: bool = Field(default=False)\r\n\r\nclass PostResponse(BaseModel):\r\n    id: str\r\n    title: str\r\n    content: str\r\n    tags: List[str]\r\n    published: bool\r\n    created_at: datetime\r\n    author: UserResponse\r\n```\r\n\r\n```typescript\r\n// Frontend: Auto-generated TypeScript interfaces\r\ninterface CreatePostRequest {\r\n  title: string;\r\n  content: string;\r\n  tags?: string[];\r\n  published?: boolean;\r\n}\r\n\r\ninterface PostResponse {\r\n  id: string;\r\n  title: string;\r\n  content: string;\r\n  tags: string[];\r\n  published: boolean;\r\n  createdAt: string;\r\n  author: UserResponse;\r\n}\r\n\r\n// Type-safe API client\r\nconst createPost = async (data: CreatePostRequest): Promise<PostResponse> => {\r\n  return await apiClient.post(\"/posts\", data);\r\n};\r\n```\r\n\r\n---\r\n\r\n## CLI & Tooling\r\n\r\n### Project Scaffolding\r\n\r\n```bash\r\n# Interactive project creation\r\nfarm create my-app\r\n? Select a template:\r\n  ❯ Basic Web App\r\n    AI Chat Application (Ollama + OpenAI)\r\n    AI Dashboard (ML Analytics)\r\n    E-commerce Platform\r\n    Content Management System\r\n    API Only (Backend)\r\n\r\n? Enable features:\r\n  ✓ Authentication\r\n  ✓ AI/ML Integration (Ollama + Cloud Providers)\r\n  ✓ Real-time Features\r\n  ✓ Database Migrations\r\n  ○ Payment Integration\r\n  ○ Email Service\r\n```\r\n\r\n### Code Generators\r\n\r\n```bash\r\n# Generate complete CRUD functionality\r\nfarm generate resource Product \\\r\n  --fields \"name:str description:str price:float category:str\" \\\r\n  --relations \"category:Category reviews:Review[]\" \\\r\n  --permissions \"admin:crud user:read\"\r\n\r\n# This creates:\r\n# - Python model with validation\r\n# - FastAPI routes with permissions\r\n# - TypeScript interfaces\r\n# - React components (list, detail, form)\r\n# - Database migrations\r\n# - Unit tests\r\n```\r\n\r\n### Development Workflow\r\n\r\n```bash\r\n# Start development with intelligent watching\r\nfarm dev --verbose\r\n✓ Starting MongoDB container...\r\n✓ Starting Ollama AI service...\r\n📥 Auto-pulling Ollama model: llama3.1\r\n✓ Starting FastAPI server on http://localhost:8000\r\n✓ Starting React dev server on http://localhost:3000\r\n✓ Watching for model changes...\r\n✓ API documentation available at http://localhost:8000/docs\r\n✓ Ollama AI available at http://localhost:11434\r\n\r\n# Real-time feedback\r\n[API] Model User updated → Regenerating TypeScript types...\r\n[WEB] New types available → Hot reloading components...\r\n[AI]  Ollama model updated → Hot-swapping model...\r\n[DB]  Migration detected → Running auto-migration...\r\n```\r\n\r\n---\r\n\r\n## Configuration System\r\n\r\n### TypeScript-First Configuration\r\n\r\n```typescript\r\n// farm.config.ts - Type-safe configuration with IntelliSense\r\nimport { defineConfig } from \"@farm/core\";\r\n\r\nexport default defineConfig({\r\n  name: \"my-farm-app\",\r\n  template: \"ai-chat\",\r\n  features: [\"auth\", \"ai\", \"realtime\"],\r\n\r\n  // AI provider configuration\r\n  ai: {\r\n    providers: {\r\n      ollama: {\r\n        enabled: true,\r\n        url: \"http://localhost:11434\",\r\n        models: [\"llama3.1\", \"codestral\", \"phi3\"],\r\n        defaultModel: \"llama3.1\",\r\n        autoStart: true, // Start with farm dev\r\n        autoPull: [\"llama3.1\"], // Auto-download on first run\r\n      },\r\n      openai: {\r\n        enabled: true,\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n        models: [\"gpt-4\", \"gpt-3.5-turbo\"],\r\n        defaultModel: \"gpt-3.5-turbo\",\r\n      },\r\n    },\r\n    routing: {\r\n      development: \"ollama\", // Use local models in dev\r\n      production: \"openai\", // Use cloud models in prod\r\n    },\r\n    features: {\r\n      streaming: true,\r\n      caching: true,\r\n      fallback: true,\r\n    },\r\n  },\r\n\r\n  // Database configuration\r\n  database: {\r\n    type: \"mongodb\",\r\n    url: process.env.DATABASE_URL || \"mongodb://localhost:27017/farmapp\",\r\n  },\r\n\r\n  // Development server configuration\r\n  development: {\r\n    ports: {\r\n      frontend: 3000,\r\n      backend: 8000,\r\n      proxy: 4000,\r\n      ollama: 11434,\r\n    },\r\n    hotReload: {\r\n      enabled: true,\r\n      typeGeneration: true,\r\n      aiModels: true,\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n### Environment-Specific Configuration\r\n\r\n- **farm.config.development.ts** - Local development with Ollama\r\n- **farm.config.production.ts** - Production with cloud providers\r\n- **Hot reload support** - Configuration changes trigger service updates\r\n- **Type safety** - Full IntelliSense and compile-time validation\r\n\r\n---\r\n\r\n## Deployment & Production\r\n\r\n### Docker Integration\r\n\r\n```dockerfile\r\n# Auto-generated multi-stage Dockerfile\r\nFROM node:18-alpine AS frontend-builder\r\nWORKDIR /app\r\nCOPY apps/web/package.json ./\r\nRUN npm install\r\nCOPY apps/web ./\r\nRUN npm run build\r\n\r\nFROM python:3.11-slim AS backend\r\nWORKDIR /app\r\nCOPY apps/api/requirements.txt ./\r\nRUN pip install -r requirements.txt\r\nCOPY apps/api ./\r\nCOPY --from=frontend-builder /app/dist ./static\r\n\r\nEXPOSE 8000\r\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\r\n```\r\n\r\n### Cloud Platform Support\r\n\r\n```bash\r\n# One-command deployment to various platforms\r\nfarm deploy --platform vercel      # Vercel + MongoDB Atlas\r\nfarm deploy --platform aws         # AWS ECS + DocumentDB\r\nfarm deploy --platform gcp         # Google Cloud Run + Firestore\r\nfarm deploy --platform railway     # Railway + MongoDB\r\nfarm deploy --platform docker      # Docker Compose\r\n```\r\n\r\n### Production Optimizations\r\n\r\n- **Automatic Code Splitting**: Route-based and component-based splitting\r\n- **API Caching**: Redis integration for response caching\r\n- **CDN Integration**: Automatic static asset optimization\r\n- **Database Optimization**: Connection pooling and query optimization\r\n- **ML Model Optimization**: Model quantization and batching\r\n- **Monitoring**: Built-in observability with Prometheus metrics\r\n\r\n---\r\n\r\n## Plugin Architecture\r\n\r\n### Plugin System Design\r\n\r\n```python\r\n# Plugin interface\r\nfrom farm.plugins import Plugin, PluginMetadata\r\n\r\nclass AuthPlugin(Plugin):\r\n    metadata = PluginMetadata(\r\n        name=\"farm-auth\",\r\n        version=\"1.0.0\",\r\n        description=\"Authentication and authorization plugin\"\r\n    )\r\n\r\n    def install(self, app: FastAPI, config: dict):\r\n        # Add authentication routes\r\n        app.include_router(auth_router)\r\n\r\n        # Add middleware\r\n        app.add_middleware(AuthMiddleware)\r\n\r\n        # Register frontend components\r\n        self.register_components({\r\n            \"LoginForm\": \"./components/LoginForm.tsx\",\r\n            \"ProtectedRoute\": \"./components/ProtectedRoute.tsx\"\r\n        })\r\n```\r\n\r\n### Official Plugins\r\n\r\n- **farm-auth**: Authentication (OAuth, JWT, social login)\r\n- **farm-payments**: Payment processing (Stripe, PayPal)\r\n- **farm-cms**: Content management system\r\n- **farm-analytics**: User analytics and tracking\r\n- **farm-notifications**: Email, SMS, and push notifications\r\n- **farm-storage**: File upload and cloud storage\r\n- **farm-search**: Full-text search with Elasticsearch\r\n- **farm-ml-models**: Pre-trained model marketplace\r\n\r\n### Community Plugin Ecosystem\r\n\r\n- Plugin registry and marketplace\r\n- Plugin development kit and documentation\r\n- Automated testing and quality assurance\r\n- Version compatibility management\r\n- Community-driven plugin reviews\r\n\r\n---\r\n\r\n## Community & Ecosystem\r\n\r\n### Open Source Strategy\r\n\r\n- **MIT License**: Permissive licensing for maximum adoption\r\n- **GitHub-First**: Public development with transparent roadmap\r\n- **Community-Driven**: RFC process for major changes\r\n- **Contributor-Friendly**: Comprehensive contribution guidelines\r\n- **Documentation-First**: Extensive docs and examples\r\n\r\n### Learning Resources\r\n\r\n- **Interactive Tutorial**: Step-by-step framework introduction\r\n- **Example Applications**: Real-world demo applications\r\n- **Video Course Series**: Comprehensive video tutorials\r\n- **Blog Content**: Regular technical articles and updates\r\n- **Workshop Materials**: Conference and meetup presentations\r\n\r\n### Community Platforms\r\n\r\n- **Discord Server**: Real-time community chat and support\r\n- **GitHub Discussions**: Feature requests and technical discussions\r\n- **Stack Overflow**: Tagged questions and community answers\r\n- **Reddit Community**: News, showcases, and informal discussion\r\n- **Newsletter**: Monthly updates on framework development\r\n\r\n### Enterprise Support\r\n\r\n- **Professional Services**: Custom development and consulting\r\n- **Training Programs**: Team training and certification\r\n- **Priority Support**: Dedicated support channels\r\n- **Custom Plugins**: Enterprise-specific plugin development\r\n- **SLA Guarantees**: Production support agreements\r\n\r\n---\r\n\r\n## Roadmap & Future Vision\r\n\r\n### Phase 1: Foundation (Months 1-6)\r\n\r\n- Core framework architecture\r\n- TypeScript-first CLI and scaffolding\r\n- MongoDB integration with flexible database support\r\n- Type-safe API generation pipeline\r\n- Development server with unified hot-reload\r\n- **Ollama integration for local AI development**\r\n- **Provider routing system (local → cloud)**\r\n\r\n### Phase 2: AI Enhancement (Months 6-12)\r\n\r\n- Advanced AI model management and optimization\r\n- GPU acceleration and multi-GPU support\r\n- Enhanced streaming AI responses\r\n- Vector database integration for embeddings\r\n- Pre-built AI components and templates\r\n- **AI model marketplace and sharing**\r\n\r\n### Phase 3: Ecosystem (Months 12-18)\r\n\r\n- Plugin architecture and marketplace\r\n- Advanced cloud deployment integrations\r\n- Performance monitoring and optimization\r\n- Enterprise authentication and security\r\n- Community growth and contributor tools\r\n\r\n### Phase 4: Scale (Months 18+)\r\n\r\n- Advanced AI workflows and pipelines\r\n- Multi-tenancy and enterprise features\r\n- Global CDN and edge deployment\r\n- Advanced analytics and monitoring\r\n- Enterprise support and professional services\r\n\r\n---\r\n\r\nThis comprehensive documentation serves as the foundation for building the FARM Stack Framework, providing clear direction for development while maintaining flexibility for community input and iteration.\r\n",
      "excerpt": "1. Overview\r\n2. Core Architecture\r\n3. Framework Components\r\n4. Development Experience\r\n5. AI/ML Integration\r\n6. Database Layer\r\n7.",
      "category": "docs",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.796Z",
      "breadcrumbs": [
        "Docs",
        "Old Readme"
      ],
      "headings": [
        {
          "level": 1,
          "text": "FARM Stack Framework",
          "id": "farm-stack-framework"
        },
        {
          "level": 2,
          "text": "AI-First Full-Stack Development Platform",
          "id": "ai-first-full-stack-development-platform"
        },
        {
          "level": 3,
          "text": "Table of Contents",
          "id": "table-of-contents"
        },
        {
          "level": 2,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 3,
          "text": "Vision Statement",
          "id": "vision-statement"
        },
        {
          "level": 3,
          "text": "Core Value Proposition",
          "id": "core-value-proposition"
        },
        {
          "level": 3,
          "text": "Technology Foundation",
          "id": "technology-foundation"
        },
        {
          "level": 2,
          "text": "Core Architecture",
          "id": "core-architecture"
        },
        {
          "level": 3,
          "text": "Monorepo Structure",
          "id": "monorepo-structure"
        },
        {
          "level": 3,
          "text": "Request Flow Architecture",
          "id": "request-flow-architecture"
        },
        {
          "level": 2,
          "text": "Framework Components",
          "id": "framework-components"
        },
        {
          "level": 3,
          "text": "1. Frontend Layer (React/TypeScript)",
          "id": "1-frontend-layer-reacttypescript"
        },
        {
          "level": 3,
          "text": "2. Backend Layer (FastAPI)",
          "id": "2-backend-layer-fastapi"
        },
        {
          "level": 3,
          "text": "3. AI/ML Integration Layer",
          "id": "3-aiml-integration-layer"
        },
        {
          "level": 3,
          "text": "4. Database Layer (MongoDB + ODM)",
          "id": "4-database-layer-mongodb-odm"
        },
        {
          "level": 2,
          "text": "Development Experience",
          "id": "development-experience"
        },
        {
          "level": 3,
          "text": "Unified CLI Commands",
          "id": "unified-cli-commands"
        },
        {
          "level": 1,
          "text": "Project creation",
          "id": "project-creation"
        },
        {
          "level": 1,
          "text": "Development",
          "id": "development"
        },
        {
          "level": 1,
          "text": "Code generation",
          "id": "code-generation"
        },
        {
          "level": 1,
          "text": "Database operations",
          "id": "database-operations"
        },
        {
          "level": 1,
          "text": "AI/ML operations",
          "id": "aiml-operations"
        },
        {
          "level": 1,
          "text": "Build and deployment",
          "id": "build-and-deployment"
        },
        {
          "level": 3,
          "text": "Hot Reload & Development Server",
          "id": "hot-reload-development-server"
        },
        {
          "level": 3,
          "text": "Developer Tools Integration",
          "id": "developer-tools-integration"
        },
        {
          "level": 2,
          "text": "AI/ML Integration",
          "id": "aiml-integration"
        },
        {
          "level": 3,
          "text": "Built-in AI Services",
          "id": "built-in-ai-services"
        },
        {
          "level": 1,
          "text": "Multi-provider AI integration with Ollama support",
          "id": "multi-provider-ai-integration-with-ollama-support"
        },
        {
          "level": 1,
          "text": "Ollama provider (local development)",
          "id": "ollama-provider-local-development"
        },
        {
          "level": 1,
          "text": "OpenAI provider (production)",
          "id": "openai-provider-production"
        },
        {
          "level": 1,
          "text": "Provider routing based on environment",
          "id": "provider-routing-based-on-environment"
        },
        {
          "level": 3,
          "text": "Frontend AI Hooks",
          "id": "frontend-ai-hooks"
        },
        {
          "level": 3,
          "text": "GPU Management & Local AI",
          "id": "gpu-management-local-ai"
        },
        {
          "level": 2,
          "text": "Database Layer",
          "id": "database-layer"
        },
        {
          "level": 3,
          "text": "MongoDB Integration",
          "id": "mongodb-integration"
        },
        {
          "level": 1,
          "text": "Model definition with automatic API generation",
          "id": "model-definition-with-automatic-api-generation"
        },
        {
          "level": 1,
          "text": "Automatic CRUD API generation",
          "id": "automatic-crud-api-generation"
        },
        {
          "level": 3,
          "text": "TypeScript Integration",
          "id": "typescript-integration"
        },
        {
          "level": 3,
          "text": "Database Flexibility",
          "id": "database-flexibility"
        },
        {
          "level": 2,
          "text": "Type Safety & Code Generation",
          "id": "type-safety-code-generation"
        },
        {
          "level": 3,
          "text": "Automatic Code Generation Pipeline",
          "id": "automatic-code-generation-pipeline"
        },
        {
          "level": 3,
          "text": "Type-Safe API Contracts",
          "id": "type-safe-api-contracts"
        },
        {
          "level": 1,
          "text": "Backend: Pydantic models define the contract",
          "id": "backend-pydantic-models-define-the-contract"
        },
        {
          "level": 2,
          "text": "CLI & Tooling",
          "id": "cli-tooling"
        },
        {
          "level": 3,
          "text": "Project Scaffolding",
          "id": "project-scaffolding"
        },
        {
          "level": 1,
          "text": "Interactive project creation",
          "id": "interactive-project-creation"
        },
        {
          "level": 3,
          "text": "Code Generators",
          "id": "code-generators"
        },
        {
          "level": 1,
          "text": "Generate complete CRUD functionality",
          "id": "generate-complete-crud-functionality"
        },
        {
          "level": 1,
          "text": "This creates:",
          "id": "this-creates"
        },
        {
          "level": 1,
          "text": "- Python model with validation",
          "id": "--python-model-with-validation"
        },
        {
          "level": 1,
          "text": "- FastAPI routes with permissions",
          "id": "--fastapi-routes-with-permissions"
        },
        {
          "level": 1,
          "text": "- TypeScript interfaces",
          "id": "--typescript-interfaces"
        },
        {
          "level": 1,
          "text": "- React components (list, detail, form)",
          "id": "--react-components-list-detail-form"
        },
        {
          "level": 1,
          "text": "- Database migrations",
          "id": "--database-migrations"
        },
        {
          "level": 1,
          "text": "- Unit tests",
          "id": "--unit-tests"
        },
        {
          "level": 3,
          "text": "Development Workflow",
          "id": "development-workflow"
        },
        {
          "level": 1,
          "text": "Start development with intelligent watching",
          "id": "start-development-with-intelligent-watching"
        },
        {
          "level": 1,
          "text": "Real-time feedback",
          "id": "real-time-feedback"
        },
        {
          "level": 2,
          "text": "Configuration System",
          "id": "configuration-system"
        },
        {
          "level": 3,
          "text": "TypeScript-First Configuration",
          "id": "typescript-first-configuration"
        },
        {
          "level": 3,
          "text": "Environment-Specific Configuration",
          "id": "environment-specific-configuration"
        },
        {
          "level": 2,
          "text": "Deployment & Production",
          "id": "deployment-production"
        },
        {
          "level": 3,
          "text": "Docker Integration",
          "id": "docker-integration"
        },
        {
          "level": 1,
          "text": "Auto-generated multi-stage Dockerfile",
          "id": "auto-generated-multi-stage-dockerfile"
        },
        {
          "level": 3,
          "text": "Cloud Platform Support",
          "id": "cloud-platform-support"
        },
        {
          "level": 1,
          "text": "One-command deployment to various platforms",
          "id": "one-command-deployment-to-various-platforms"
        },
        {
          "level": 3,
          "text": "Production Optimizations",
          "id": "production-optimizations"
        },
        {
          "level": 2,
          "text": "Plugin Architecture",
          "id": "plugin-architecture"
        },
        {
          "level": 3,
          "text": "Plugin System Design",
          "id": "plugin-system-design"
        },
        {
          "level": 1,
          "text": "Plugin interface",
          "id": "plugin-interface"
        },
        {
          "level": 3,
          "text": "Official Plugins",
          "id": "official-plugins"
        },
        {
          "level": 3,
          "text": "Community Plugin Ecosystem",
          "id": "community-plugin-ecosystem"
        },
        {
          "level": 2,
          "text": "Community & Ecosystem",
          "id": "community-ecosystem"
        },
        {
          "level": 3,
          "text": "Open Source Strategy",
          "id": "open-source-strategy"
        },
        {
          "level": 3,
          "text": "Learning Resources",
          "id": "learning-resources"
        },
        {
          "level": 3,
          "text": "Community Platforms",
          "id": "community-platforms"
        },
        {
          "level": 3,
          "text": "Enterprise Support",
          "id": "enterprise-support"
        },
        {
          "level": 2,
          "text": "Roadmap & Future Vision",
          "id": "roadmap-future-vision"
        },
        {
          "level": 3,
          "text": "Phase 1: Foundation (Months 1-6)",
          "id": "phase-1-foundation-months-1-6"
        },
        {
          "level": 3,
          "text": "Phase 2: AI Enhancement (Months 6-12)",
          "id": "phase-2-ai-enhancement-months-6-12"
        },
        {
          "level": 3,
          "text": "Phase 3: Ecosystem (Months 12-18)",
          "id": "phase-3-ecosystem-months-12-18"
        },
        {
          "level": 3,
          "text": "Phase 4: Scale (Months 18+)",
          "id": "phase-4-scale-months-18"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-test-components",
      "title": "Test Components",
      "url": "/docs/test-components",
      "content": "# Component Test Page\n\nThis page tests all the MDX components to ensure they're working correctly.\n\n## Callout Component\n\n<Callout type=\"tip\" title=\"Success!\">\n  This Callout component should now render without errors.\n</Callout>\n\n<Callout type=\"warning\" title=\"Warning Example\">\n  This is a warning callout to test different types.\n</Callout>\n\n<Callout type=\"error\" title=\"Error Example\">\n  This is an error callout to test error styling.\n</Callout>\n\n## Tabs Component\n\n<Tabs defaultValue=\"tab1\">\n  <TabsList>\n    <Tab value=\"tab1\">Tab 1</Tab>\n    <Tab value=\"tab2\">Tab 2</Tab>\n    <Tab value=\"tab3\">Tab 3</Tab>\n  </TabsList>\n  <TabsContent value=\"tab1\">\n    Content for Tab 1 - this should display properly.\n  </TabsContent>\n  <TabsContent value=\"tab2\">\n    Content for Tab 2 - switching should work smoothly.\n  </TabsContent>\n  <TabsContent value=\"tab3\">\n    Content for Tab 3 - all functionality should be intact.\n  </TabsContent>\n</Tabs>\n\n## Accordion Component\n\n<Accordion type=\"single\" collapsible>\n  <AccordionItem value=\"item-1\">\n    <AccordionTrigger>Is it accessible?</AccordionTrigger>\n    <AccordionContent>\n      Yes. It adheres to the WAI-ARIA design pattern.\n    </AccordionContent>\n  </AccordionItem>\n  <AccordionItem value=\"item-2\">\n    <AccordionTrigger>Is it styled?</AccordionTrigger>\n    <AccordionContent>\n      Yes. It comes with default styles that matches the other components'\n      aesthetic.\n    </AccordionContent>\n  </AccordionItem>\n</Accordion>\n\n## Card Component\n\n<Card className=\"my-4\">\n  <CardHeader>\n    <CardTitle>Card Title</CardTitle>\n    <CardDescription>Card description goes here</CardDescription>\n  </CardHeader>\n  <CardContent>\n    This is the card content. It should display with proper styling.\n  </CardContent>\n  <CardFooter>\n    <p>Card footer content</p>\n  </CardFooter>\n</Card>\n\n## Code Block\n\n<CodeBlock language=\"javascript\" title=\"Example JavaScript\">\n{`function greet(name) {\n  console.log(\\`Hello, \\${name}!\\`);\n}\n\ngreet('World');`}\n\n</CodeBlock>\n\n<CodeBlock language=\"python\" title=\"Example Python\">\n{`def greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"World\")`}\n\n</CodeBlock>\n\n## Tooltip Component\n\n<Tooltip content=\"This is a tooltip\">\n  <span className=\"underline cursor-help\">Hover over me</span>\n</Tooltip>\n\n---\n\nIf all components above render without errors, the MDX integration is working correctly!\n",
      "excerpt": "This page tests all the MDX components to ensure they're working correctly. <Callout type=\"tip\" title=\"Success.",
      "category": "docs",
      "type": "reference",
      "tags": [
        "python",
        "components"
      ],
      "lastModified": "2025-06-12T21:57:32.796Z",
      "breadcrumbs": [
        "Docs",
        "Test Components"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Component Test Page",
          "id": "component-test-page"
        },
        {
          "level": 2,
          "text": "Callout Component",
          "id": "callout-component"
        },
        {
          "level": 2,
          "text": "Tabs Component",
          "id": "tabs-component"
        },
        {
          "level": 2,
          "text": "Accordion Component",
          "id": "accordion-component"
        },
        {
          "level": 2,
          "text": "Card Component",
          "id": "card-component"
        },
        {
          "level": 2,
          "text": "Code Block",
          "id": "code-block"
        },
        {
          "level": 2,
          "text": "Tooltip Component",
          "id": "tooltip-component"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-type-sync",
      "title": "Type-Sync",
      "url": "/docs/type-sync",
      "content": "\n# Type-Sync\n\nType-Sync is a tool for FARM applications that automates TypeScript type generation and API client code. It extracts an OpenAPI schema from your FastAPI backend and generates strongly typed artifacts, keeping your front-end and back-end in sync. Type-Sync supports incremental builds, caching, and watch mode for a seamless developer experience.\n\n## Key Features\n\n- **OpenAPI Extraction**: Pulls schemas from a running or temporary FastAPI server, with fallback to cached/static schemas.\n- **Type & Client Generation**: Emits TypeScript types, an axios-based API client, React Query hooks, and optional AI hooks.\n- **Incremental & Parallel Generation**: Only regenerates changed files and runs generators in parallel for speed.\n- **Caching**: Disk-based cache with compression, expiration, and metrics.\n- **Watch Mode**: Watches Python source files and regenerates types on change, triggering frontend reloads.\n- **Error Handling**: Graceful fallback to cached schemas and detailed logging.\n\n## Architecture Overview\n\n```\n┌─────────────────────────────┐\n│     TypeSync Orchestrator   │\n├─────────────────────────────┤\n│  ┌───────────────┐          │\n│  │ OpenAPI       │          │\n│  │ Extractor     │          │\n│  └───────────────┘          │\n│  ┌───────────────┐          │\n│  │ Generation    │          │\n│  │ Cache         │          │\n│  └───────────────┘          │\n│  ┌───────────────┐          │\n│  │  Generators   │─ Types   │\n│  │               │─ Client  │\n│  │               │─ Hooks   │\n│  │               │─ AIHooks │\n│  └───────────────┘          │\n│  ┌───────────────┐          │\n│  │   Watcher     │          │\n│  └───────────────┘          │\n└─────────────────────────────┘\n```\n\n## Usage\n\n### Programmatic API\n\n```ts\nimport { TypeSyncOrchestrator } from \"@farm/type-sync\";\n\nconst orchestrator = new TypeSyncOrchestrator();\nawait orchestrator.initialize({\n  apiUrl: \"http://localhost:8000\",\n  features: { client: true, hooks: true, streaming: true, aiHooks: false },\n});\n\nconst result = await orchestrator.syncOnce();\nconsole.log(`Generated ${result.filesGenerated} files`);\n```\n\n### Watch Mode\n\n```ts\nconst watcher = new TypeSyncWatcher(orchestrator);\nawait watcher.start();\n```\n\nPress `Ctrl+C` to stop watching.\n\n### CLI & Scripts\n\nRun the provided npm scripts to build the package:\n\n```bash\npnpm run build:bundle     # Build ESM/CJS bundles\npnpm run build:watch      # Build in watch mode\npnpm run type-check       # Run TypeScript type checker\n```\n\n## Configuration Example\n\n```ts\nawait orchestrator.initialize({\n  apiUrl: \"http://localhost:8000\",\n  outputDir: \"generated/types\",\n  features: {\n    client: true,\n    hooks: true,\n    streaming: true,\n    aiHooks: true,\n  },\n  performance: {\n    enableMonitoring: true,\n    enableIncrementalGeneration: true,\n    maxConcurrency: 4,\n    cacheTimeout: 300000,\n  },\n  generators: {\n    typescript: { exportStyle: \"named\" },\n    apiClient: { baseURL: \"http://localhost:8000\" },\n    reactHooks: { enableInfiniteQueries: true },\n    aiHooks: { defaultProvider: \"ollama\" },\n  },\n});\n```\n\n## File Structure\n\n```\npackages/type-sync/\n├── src/\n│   ├── cache.ts                # Generation cache implementation\n│   ├── orchestrator.ts         # Main orchestrator\n│   ├── watcher.ts              # File watcher for dev mode\n│   ├── type-sync.ts            # Type differ utilities\n│   ├── extractors/\n│   │   └── openapi.ts          # FastAPI OpenAPI extractor\n│   ├── generators/\n│   │   ├── typescript.ts       # TS type generator\n│   │   ├── api-client.ts       # API client generator\n│   │   ├── react-hooks.ts      # React hook generator\n│   │   └── ai-hooks.ts         # AI hook generator\n│   ├── utils/\n│   │   └── fetchWithRetry.ts   # Helper for fetch with retries\n│   └── types.ts                # Shared type definitions\n├── tsup.config.ts              # Build configuration\n├── tsconfig.json               # TypeScript config\n├── package.json                # Package metadata\n└── README.md                   # This guide\n```\n\n## Integration\n\n- Used by the FARM CLI for `farm sync-types`\n- Works with the development server to regenerate types on the fly\n- Produced artifacts live in `generated/` by default\n\n## Next Steps\n\nPlanned improvements:\n\n1. Smarter schema diffing and selective regeneration\n2. Additional generators (e.g., Python client)\n3. Improved error messaging and IDE integration\n",
      "excerpt": "Type-Sync is a tool for FARM applications that automates TypeScript type generation and API client code.",
      "category": "tools",
      "type": "reference",
      "difficulty": "intermediate",
      "tags": [
        "typescript",
        "api",
        "codegen",
        "automation"
      ],
      "lastModified": "2024-01-20",
      "breadcrumbs": [
        "Docs",
        "Type Sync",
        "Type-Sync"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Type-Sync",
          "id": "type-sync"
        },
        {
          "level": 2,
          "text": "Key Features",
          "id": "key-features"
        },
        {
          "level": 2,
          "text": "Architecture Overview",
          "id": "architecture-overview"
        },
        {
          "level": 2,
          "text": "Usage",
          "id": "usage"
        },
        {
          "level": 3,
          "text": "Programmatic API",
          "id": "programmatic-api"
        },
        {
          "level": 3,
          "text": "Watch Mode",
          "id": "watch-mode"
        },
        {
          "level": 3,
          "text": "CLI & Scripts",
          "id": "cli-scripts"
        },
        {
          "level": 2,
          "text": "Configuration Example",
          "id": "configuration-example"
        },
        {
          "level": 2,
          "text": "File Structure",
          "id": "file-structure"
        },
        {
          "level": 2,
          "text": "Integration",
          "id": "integration"
        },
        {
          "level": 2,
          "text": "Next Steps",
          "id": "next-steps"
        }
      ],
      "sidebarTitle": "Type-Sync",
      "icon": "refresh",
      "author": "FARM Team",
      "featured": false,
      "deprecated": false
    },
    {
      "id": "docs-typography-showcase",
      "title": "Typography Showcase",
      "url": "/docs/typography-showcase",
      "content": "# Typography Showcase\n\nThis page demonstrates all the available typography and custom components for MDX documentation.\n\n## Headings\n\n# H1 Heading\n\n## H2 Heading\n\n### H3 Heading\n\n#### H4 Heading\n\n##### H5 Heading\n\n###### H6 Heading\n\n## Text Elements\n\nThis is a regular paragraph with some **bold text**, _italic text_, and `inline code`. You can also include [links](https://farmframework.com) that are styled consistently.\n\n<Lead>\n  This is a lead paragraph that stands out from regular text with larger, more\n  prominent styling.\n</Lead>\n\n<Large>This is large text for emphasis.</Large>\n\n<Small>This is small text for less important information.</Small>\n\n<Muted>This is muted text for secondary information.</Muted>\n\n## Lists\n\n### Unordered List\n\n- First item\n- Second item with some longer text to demonstrate wrapping\n- Third item\n  - Nested item\n  - Another nested item\n\n### Ordered List\n\n1. First step\n2. Second step\n3. Third step\n   1. Sub-step\n   2. Another sub-step\n\n## Code Examples\n\nHere's an inline code example: `npm install farm-framework`\n\n### JavaScript Example\n\n```javascript\nimport { createFarmApp } from \"farm-framework\";\n\nconst app = createFarmApp({\n  plugins: [\"auth\", \"database\"],\n  config: {\n    port: 3000,\n    database: {\n      url: process.env.DATABASE_URL,\n    },\n  },\n});\n\napp.listen(() => {\n  console.log(\"Farm app running!\");\n});\n```\n\n### TypeScript Example\n\n```typescript\ninterface FarmConfig {\n  port: number;\n  database: {\n    url: string;\n    pool?: {\n      min: number;\n      max: number;\n    };\n  };\n  auth?: {\n    providers: string[];\n    jwt: {\n      secret: string;\n      expiresIn: string;\n    };\n  };\n}\n\nconst config: FarmConfig = {\n  port: 3000,\n  database: {\n    url: process.env.DATABASE_URL!,\n    pool: {\n      min: 2,\n      max: 10,\n    },\n  },\n};\n```\n\n### Multiple Language Examples\n\n<CodeTabs examples={[\n  {\n    language: \"javascript\",\n    label: \"JavaScript\",\n    code: `import { createFarmApp } from \"farm-framework\";\n\nconst app = createFarmApp({\nplugins: [\"auth\", \"database\"],\nconfig: {\nport: 3000,\ndatabase: {\nurl: process.env.DATABASE_URL,\n},\n},\n});\n\napp.listen(() => {\nconsole.log(\"Farm app running!\");\n});`  },\n  {\n    language: \"typescript\",\n    label: \"TypeScript\",\n    code:`import { createFarmApp, FarmConfig } from \"farm-framework\";\n\nconst config: FarmConfig = {\nport: 3000,\ndatabase: {\nurl: process.env.DATABASE_URL!,\npool: {\nmin: 2,\nmax: 10,\n},\n},\nauth: {\nproviders: [\"github\", \"google\"],\njwt: {\nsecret: process.env.JWT_SECRET!,\nexpiresIn: \"7d\",\n},\n},\n};\n\nconst app = createFarmApp(config);\n\napp.listen(() => {\nconsole.log(\"Farm app running!\");\n});`  },\n  {\n    language: \"python\",\n    label: \"Python\",\n    code:`from farm_framework import create_farm_app\n\napp = create_farm_app({\n\"plugins\": [\"auth\", \"database\"],\n\"config\": {\n\"port\": 3000,\n\"database\": {\n\"url\": os.environ.get(\"DATABASE_URL\"),\n},\n},\n})\n\nif **name** == \"**main**\":\napp.run()`\n}\n]} />\n\n## Custom Components\n\n### Callouts\n\n<Callout type=\"info\">\n  This is an info callout that provides helpful information to readers.\n</Callout>\n\n<Callout type=\"warning\">\n  This is a warning callout that alerts readers to potential issues.\n</Callout>\n\n<Callout type=\"error\">\n  This is an error callout that highlights critical information.\n</Callout>\n\n### Enhanced Notes\n\n<Note title=\"Pro Tip\">\n  Use these note components to highlight important information that doesn't fit\n  into a regular callout.\n</Note>\n\n<Warning title=\"Breaking Change\">\n  This feature has been deprecated and will be removed in version 2.0.\n</Warning>\n\n<Info title=\"New Feature\">\n  This feature was added in version 1.5 and provides enhanced functionality.\n</Info>\n\n### Step-by-Step Instructions\n\n<Step number={1} title=\"Install the Framework\">\nFirst, install the FARM framework using your preferred package manager:\n\n```bash\nnpm install farm-framework\n# or\npnpm add farm-framework\n# or\nyarn add farm-framework\n```\n\n</Step>\n\n<Step number={2} title=\"Configure Your App\">\nCreate a configuration file to set up your application:\n\n```typescript\n// farm.config.ts\nexport default {\n  database: {\n    provider: \"postgresql\",\n    url: process.env.DATABASE_URL,\n  },\n  auth: {\n    providers: [\"github\", \"google\"],\n  },\n};\n```\n\n</Step>\n\n<Step number={3} title=\"Start Development\">\nRun the development server to start building your application:\n\n```bash\nnpm run dev\n```\n\n</Step>\n\n## Tables\n\n| Feature        | Basic     | Pro        | Enterprise         |\n| -------------- | --------- | ---------- | ------------------ |\n| API Access     | ✓         | ✓          | ✓                  |\n| Database       | SQLite    | PostgreSQL | PostgreSQL + Redis |\n| Auth Providers | 2         | 5          | Unlimited          |\n| Support        | Community | Email      | Priority + Phone   |\n| Price          | Free      | $29/mo     | $99/mo             |\n\n## Blockquotes\n\n> \"The FARM framework has revolutionized how we build full-stack applications. The developer experience is incredible and the performance is outstanding.\"\n>\n> — Sarah Chen, Lead Developer at TechCorp\n\n---\n\n## Horizontal Rules\n\nYou can use horizontal rules to separate sections:\n\n---\n\n## More Advanced Examples\n\n### Nested Components\n\n<Info title=\"Advanced Usage\">\nYou can nest other components inside callouts and notes:\n\n```typescript\nimport { useFarm } from \"farm-framework\";\n\nexport function MyComponent() {\n  const { auth, db } = useFarm();\n\n  return (\n    <div>\n      <h1>Welcome {auth.user?.name}</h1>\n    </div>\n  );\n}\n```\n\n<Warning>\nMake sure to handle loading states properly when using these hooks.\n</Warning>\n</Info>\n\n### Complex Code Examples\n\n```bash\n# Installation\npnpm create farm-app my-project\n\n# Navigate to project\ncd my-project\n\n# Install dependencies\npnpm install\n\n# Set up environment\ncp .env.example .env.local\n\n# Generate database schema\npnpm db:generate\n\n# Start development server\npnpm dev\n```\n\nThis showcase demonstrates the full range of typography and components available for creating rich, engaging documentation with the FARM framework.\n\n## Documentation Components\n\n### Feature Lists\n\n<FeatureList\n  features={[\n    {\n      name: \"TypeScript Support\",\n      included: true,\n      description: \"Full TypeScript integration out of the box\",\n    },\n    {\n      name: \"Hot Module Replacement\",\n      included: true,\n      description: \"Fast development with instant updates\",\n    },\n    {\n      name: \"Built-in Authentication\",\n      included: true,\n      description: \"Multiple auth providers supported\",\n    },\n    {\n      name: \"GraphQL Support\",\n      included: false,\n      description: \"Coming in version 2.0\",\n    },\n    {\n      name: \"Real-time Features\",\n      included: false,\n      description: \"WebSocket integration planned\",\n    },\n  ]}\n/>\n\n### API Documentation\n\n<ApiMethod method=\"POST\" path=\"/api/users\" description=\"Create a new user account with the provided information\">\n\n**Request Body:**\n\n```json\n{\n  \"email\": \"user@example.com\",\n  \"password\": \"securePassword123\",\n  \"name\": \"John Doe\"\n}\n```\n\n**Response:**\n\n```json\n{\n  \"id\": \"user_123\",\n  \"email\": \"user@example.com\",\n  \"name\": \"John Doe\",\n  \"createdAt\": \"2025-06-08T16:30:00Z\"\n}\n```\n\n</ApiMethod>\n\n<ApiMethod method=\"GET\" path=\"/api/users/{id}\" description=\"Retrieve user information by ID\">\n\n**Path Parameters:**\n\n- `id` (string): The unique user identifier\n\n**Response:**\n\n```json\n{\n  \"id\": \"user_123\",\n  \"email\": \"user@example.com\",\n  \"name\": \"John Doe\",\n  \"lastLogin\": \"2025-06-08T15:45:00Z\"\n}\n```\n\n</ApiMethod>\n\n### Property Tables\n\n<PropertyTable\n  properties={[\n    {\n      name: \"apiKey\",\n      type: \"string\",\n      required: true,\n      description: \"Your API key for authentication\",\n    },\n    {\n      name: \"timeout\",\n      type: \"number\",\n      required: false,\n      description: \"Request timeout in milliseconds\",\n      default: \"5000\",\n    },\n    {\n      name: \"retries\",\n      type: \"number\",\n      required: false,\n      description: \"Number of retry attempts for failed requests\",\n      default: \"3\",\n    },\n    {\n      name: \"baseURL\",\n      type: \"string\",\n      required: false,\n      description: \"Base URL for all API requests\",\n      default: \"https://api.farmframework.com\",\n    },\n  ]}\n/>\n",
      "excerpt": "This page demonstrates all the available typography and custom components for MDX documentation.",
      "category": "docs",
      "type": "reference",
      "tags": [
        "farm",
        "typescript",
        "python",
        "authentication",
        "database"
      ],
      "lastModified": "2025-06-12T21:57:32.797Z",
      "breadcrumbs": [
        "Docs",
        "Typography Showcase"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Typography Showcase",
          "id": "typography-showcase"
        },
        {
          "level": 2,
          "text": "Headings",
          "id": "headings"
        },
        {
          "level": 1,
          "text": "H1 Heading",
          "id": "h1-heading"
        },
        {
          "level": 2,
          "text": "H2 Heading",
          "id": "h2-heading"
        },
        {
          "level": 3,
          "text": "H3 Heading",
          "id": "h3-heading"
        },
        {
          "level": 4,
          "text": "H4 Heading",
          "id": "h4-heading"
        },
        {
          "level": 5,
          "text": "H5 Heading",
          "id": "h5-heading"
        },
        {
          "level": 6,
          "text": "H6 Heading",
          "id": "h6-heading"
        },
        {
          "level": 2,
          "text": "Text Elements",
          "id": "text-elements"
        },
        {
          "level": 2,
          "text": "Lists",
          "id": "lists"
        },
        {
          "level": 3,
          "text": "Unordered List",
          "id": "unordered-list"
        },
        {
          "level": 3,
          "text": "Ordered List",
          "id": "ordered-list"
        },
        {
          "level": 2,
          "text": "Code Examples",
          "id": "code-examples"
        },
        {
          "level": 3,
          "text": "JavaScript Example",
          "id": "javascript-example"
        },
        {
          "level": 3,
          "text": "TypeScript Example",
          "id": "typescript-example"
        },
        {
          "level": 3,
          "text": "Multiple Language Examples",
          "id": "multiple-language-examples"
        },
        {
          "level": 2,
          "text": "Custom Components",
          "id": "custom-components"
        },
        {
          "level": 3,
          "text": "Callouts",
          "id": "callouts"
        },
        {
          "level": 3,
          "text": "Enhanced Notes",
          "id": "enhanced-notes"
        },
        {
          "level": 3,
          "text": "Step-by-Step Instructions",
          "id": "step-by-step-instructions"
        },
        {
          "level": 1,
          "text": "or",
          "id": "or"
        },
        {
          "level": 1,
          "text": "or",
          "id": "or"
        },
        {
          "level": 2,
          "text": "Tables",
          "id": "tables"
        },
        {
          "level": 2,
          "text": "Blockquotes",
          "id": "blockquotes"
        },
        {
          "level": 2,
          "text": "Horizontal Rules",
          "id": "horizontal-rules"
        },
        {
          "level": 2,
          "text": "More Advanced Examples",
          "id": "more-advanced-examples"
        },
        {
          "level": 3,
          "text": "Nested Components",
          "id": "nested-components"
        },
        {
          "level": 3,
          "text": "Complex Code Examples",
          "id": "complex-code-examples"
        },
        {
          "level": 1,
          "text": "Installation",
          "id": "installation"
        },
        {
          "level": 1,
          "text": "Navigate to project",
          "id": "navigate-to-project"
        },
        {
          "level": 1,
          "text": "Install dependencies",
          "id": "install-dependencies"
        },
        {
          "level": 1,
          "text": "Set up environment",
          "id": "set-up-environment"
        },
        {
          "level": 1,
          "text": "Generate database schema",
          "id": "generate-database-schema"
        },
        {
          "level": 1,
          "text": "Start development server",
          "id": "start-development-server"
        },
        {
          "level": 2,
          "text": "Documentation Components",
          "id": "documentation-components"
        },
        {
          "level": 3,
          "text": "Feature Lists",
          "id": "feature-lists"
        },
        {
          "level": 3,
          "text": "API Documentation",
          "id": "api-documentation"
        },
        {
          "level": 3,
          "text": "Property Tables",
          "id": "property-tables"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "enterprise",
      "title": "Enterprise",
      "url": "/enterprise",
      "content": "# Enterprise\n\nScale your business with FARM Framework's enterprise-grade features, dedicated support, and professional services. Trusted by organizations worldwide for mission-critical applications.\n\n<Callout type=\"success\">\n  **99.9% uptime SLA** • **24/7 support** • **SOC 2 Type II certified** •\n  **HIPAA compliant**\n</Callout>\n\n## Enterprise Features\n\n### 🔒 Advanced Security & Compliance\n\n<FeatureList>\n  - **Multi-Factor Authentication (MFA)** with TOTP, SMS, and hardware keys -\n  **Single Sign-On (SSO)** integration with Active Directory, SAML, OIDC, and\n  OAuth providers - **Role-Based Access Control (RBAC)** with attribute-based\n  permissions and dynamic roles - **Zero-Trust Security Model** with\n  micro-segmentation and identity verification - **Data Loss Prevention (DLP)**\n  with content inspection and policy enforcement - **Audit Logging &\n  Compliance** with immutable logs and regulatory reporting - **Vulnerability\n  Scanning** with automated security assessments - **End-to-End Encryption** for\n  data at rest, in transit, and in processing\n</FeatureList>\n\n**Compliance Certifications:**\n\n<div className=\"flex gap-2 mt-4\">\n  <Badge variant=\"default\">SOC 2 Type II</Badge>\n  <Badge variant=\"secondary\">HIPAA</Badge>\n  <Badge variant=\"secondary\">GDPR</Badge>\n  <Badge variant=\"secondary\">PCI DSS</Badge>\n  <Badge variant=\"secondary\">ISO 27001</Badge>\n</div>\n\n### ⚡ Performance & Scalability\n\n<FeatureList>\n  - **Auto-Scaling Infrastructure** with predictive scaling and cost\n  optimization - **Global CDN Integration** with edge caching and geographic\n  distribution - **Database Optimization** with sharding, read replicas, and\n  connection pooling - **Caching Strategies** with Redis, Memcached, and\n  application-level caching - **Load Balancing** with health checks, failover,\n  and traffic distribution - **Performance Monitoring** with real-time metrics,\n  alerting, and root cause analysis - **Code Splitting & Optimization** with\n  tree shaking and bundle analysis - **Edge Computing** with serverless\n  functions and global deployment\n</FeatureList>\n\n**Performance Benchmarks:**\n\n<ComparisonTable>\n| Metric | Community | Professional | Enterprise |\n|--------|-----------|-------------|------------|\n| **Response Time** | < 200ms | < 100ms | < 50ms |\n| **Concurrent Users** | 1K | 10K | 100K+ |\n| **Database Connections** | 100 | 1K | 10K+ |\n| **API Rate Limit** | 1K/min | 10K/min | Unlimited |\n| **Storage** | 10GB | 100GB | Unlimited |\n| **Bandwidth** | 100GB/mo | 1TB/mo | Unlimited |\n</ComparisonTable>\n\n### 🛠 Developer Experience & DevOps\n\n<FeatureList>\n  - **Advanced CLI Tools** with project scaffolding, deployment automation, and\n  environment management - **CI/CD Pipeline Integration** with GitHub Actions,\n  GitLab CI, Jenkins, and Azure DevOps - **Infrastructure as Code (IaC)** with\n  Terraform, Kubernetes, and Docker support - **Environment Management** with\n  staging, testing, and production environments - **Blue-Green Deployments**\n  with zero-downtime deployments and automated rollbacks - **Feature Flags & A/B\n  Testing** with gradual rollouts and experimentation - **Observability Stack**\n  with distributed tracing, metrics collection, and log aggregation -\n  **Developer Productivity Tools** with IDE extensions, code generators, and\n  debugging tools\n</FeatureList>\n\n### 🤖 AI & Machine Learning Enterprise Features\n\n<FeatureList>\n  - **Enterprise AI Models** with fine-tuned models for specific business\n  domains - **Model Deployment & Versioning** with MLOps pipeline and model\n  registry - **GPU Cluster Management** with resource allocation and cost\n  optimization - **Edge AI Deployment** with model optimization for edge devices\n  - **Custom Model Training** with domain-specific datasets and transfer\n  learning - **AI Governance & Ethics** with bias detection and explainable AI -\n  **Data Pipeline Automation** with ETL/ELT processes and data quality\n  monitoring - **Federated Learning** with privacy-preserving machine learning\n</FeatureList>\n\n## Support & Service Plans\n\n<div className=\"grid gap-6 md:grid-cols-3\">\n\n<Card>\n<CardContent>\n### Starter Plan\n**$199/month**\n\nPerfect for growing teams and small enterprises.\n\n<FeatureList>\n  - Email support (24h response SLA) - Community forum access - Basic monitoring\n  & alerting - Standard security features - Up to 10 developers - 99.5% uptime\n  SLA - Monthly check-ins\n</FeatureList>\n\n<div className=\"mt-4\">\n  <Badge variant=\"outline\">Email Support</Badge>\n  <Badge variant=\"outline\">Community</Badge>\n</div>\n</CardContent>\n</Card>\n\n<Card>\n<CardContent>\n### Professional Plan\n**$599/month**\n\nEnhanced support for production applications.\n\n<FeatureList>\n  - Priority support (8h response SLA) - Video consultations & code reviews -\n  Advanced monitoring & analytics - Enhanced security features - Up to 50\n  developers - 99.9% uptime SLA - Weekly check-ins - Custom integrations (up to\n  5)\n</FeatureList>\n\n<div className=\"mt-4\">\n  <Badge variant=\"default\">Priority Support</Badge>\n  <Badge variant=\"secondary\">Video Calls</Badge>\n</div>\n</CardContent>\n</Card>\n\n<Card>\n<CardContent>\n### Enterprise Plan\n**Custom pricing**\n\nComprehensive support for mission-critical applications.\n\n<FeatureList>\n  - 24/7 dedicated support (1h response SLA) - Dedicated customer success\n  manager - On-premise deployment options - Advanced security & compliance -\n  Unlimited developers - 99.99% uptime SLA - Daily check-ins available -\n  Unlimited custom integrations - Architecture review & optimization\n</FeatureList>\n\n<div className=\"mt-4\">\n  <Badge variant=\"default\">24/7 Support</Badge>\n  <Badge variant=\"default\">Dedicated CSM</Badge>\n</div>\n</CardContent>\n</Card>\n\n</div>\n\n## Professional Services\n\n### 🏗 Architecture & Design Services\n\n<Card>\n<CardContent>\n#### System Architecture Review\n**Starting at $5,000**\n\nComprehensive analysis of your current or planned system architecture with detailed recommendations for optimization, scalability, and security.\n\n**Deliverables:**\n\n<div className=\"mt-4\">\n  <p>✓ Architecture assessment report</p>\n  <p>✓ Performance optimization recommendations</p>\n  <p>✓ Security vulnerability analysis</p>\n  <p>✓ Scalability roadmap</p>\n  <p>✓ Technology stack recommendations</p>\n</div>\n</CardContent>\n</Card>\n\n<Card>\n<CardContent>\n#### Custom Application Development\n**Starting at $25,000**\n\nFull-stack application development with FARM Framework, tailored to your specific business requirements and industry standards.\n\n**Services:**\n\n<div className=\"mt-4\">\n  <p>✓ Requirements analysis & planning</p>\n  <p>✓ UI/UX design & prototyping</p>\n  <p>✓ Full-stack development</p>\n  <p>✓ Testing & quality assurance</p>\n  <p>✓ Deployment & DevOps setup</p>\n  <p>✓ Post-launch support & maintenance</p>\n</div>\n</CardContent>\n</Card>\n\n### 🔄 Migration & Modernization\n\n<Card>\n<CardContent>\n#### Legacy System Migration\n**Starting at $15,000**\n\nModernize your legacy applications with a strategic migration to FARM Framework, ensuring minimal downtime and maximum performance gains.\n\n**Migration Path:**\n\n<div className=\"mt-4\">\n  <p>✓ Legacy system analysis</p>\n  <p>✓ Migration strategy & timeline</p>\n  <p>✓ Data migration & validation</p>\n  <p>✓ Parallel system testing</p>\n  <p>✓ Phased rollout planning</p>\n  <p>✓ Training & knowledge transfer</p>\n</div>\n</CardContent>\n</Card>\n\n### 📚 Training & Enablement\n\n<CodeTabs defaultValue=\"team-training\">\n<CodeTab value=\"team-training\" label=\"Team Training\">\n\n#### Developer Team Training\n\n**$2,500 per team (up to 10 developers)**\n\nComprehensive training program to get your development team productive with FARM Framework quickly.\n\n**Training Modules:**\n\n- FARM Framework fundamentals\n- Best practices & patterns\n- Security implementation\n- Performance optimization\n- AI integration techniques\n- DevOps & deployment strategies\n\n**Format:** 2-day intensive workshop + 30-day follow-up support\n\n</CodeTab>\n<CodeTab value=\"certification\" label=\"Certification\">\n\n#### FARM Framework Certification\n\n**$500 per developer**\n\nOfficial certification program validating expertise in FARM Framework development and best practices.\n\n**Certification Levels:**\n\n- **Associate Developer** - Fundamentals & basic implementation\n- **Professional Developer** - Advanced features & optimization\n- **Solutions Architect** - System design & enterprise patterns\n\n**Benefits:** Official certificate, digital badge, priority support access\n\n</CodeTab>\n</CodeTabs>\n\n## Enterprise Customer Success Stories\n\n<Callout type=\"success\">\n### Fortune 500 Manufacturing Company\n**Challenge:** Legacy ERP modernization for 50,000+ employees  \n**Solution:** FARM Framework migration with custom AI analytics  \n**Results:** 60% faster processing, $2M annual savings, 99.9% uptime\n\n_\"FARM Framework enabled us to modernize our entire ERP system while maintaining business continuity. The AI integration capabilities transformed our decision-making process.\"_\n\n— **Sarah Johnson**, CTO, GlobalManufacturing Corp\n\n</Callout>\n\n<Callout type=\"info\">\n### Healthcare Technology Startup\n**Challenge:** HIPAA-compliant telehealth platform for rapid scaling  \n**Solution:** FARM Framework with enterprise security features  \n**Results:** 0 to 100K users in 6 months, full HIPAA compliance, $50M funding\n\n_\"The built-in security features and compliance tools in FARM Framework Enterprise allowed us to focus on our core product instead of infrastructure concerns.\"_\n\n— **Dr. Michael Chen**, Founder & CEO, TeleHealth Innovations\n\n</Callout>\n\n## Security & Compliance Deep Dive\n\n### Data Protection & Privacy\n\n<FeatureList>\n  - **Data Residency Controls** - Choose specific geographic regions for data\n  storage - **Right to be Forgotten** - Automated personal data deletion\n  workflows - **Consent Management** - Granular privacy preferences and consent\n  tracking - **Data Classification** - Automatic sensitive data identification\n  and handling - **Backup & Recovery** - Point-in-time recovery with encrypted\n  backup storage - **Data Anonymization** - Production-safe data masking for\n  development/testing\n</FeatureList>\n\n### Incident Response & Business Continuity\n\n<FeatureList>\n- **24/7 Security Operations Center (SOC)** - Real-time threat monitoring\n- **Incident Response Team** - Dedicated security experts for critical issues\n- **Disaster Recovery** - RTO < 4 hours, RPO < 1 hour\n- **Business Continuity Planning** - Comprehensive continuity strategies\n- **Penetration Testing** - Quarterly security assessments\n- **Threat Intelligence** - Proactive threat detection and prevention\n</FeatureList>\n\n## Deployment Options\n\n<ComparisonTable>\n| Feature | Cloud (SaaS) | Hybrid Cloud | On-Premise |\n|---------|-------------|-------------|------------|\n| **Setup Time** | < 1 hour | 1-2 weeks | 2-4 weeks |\n| **Maintenance** | Fully managed | Shared | Self-managed |\n| **Scalability** | Auto-scaling | Manual/Auto | Manual |\n| **Compliance** | Standard | Custom | Full control |\n| **Cost Model** | Subscription | Usage-based | License + Infrastructure |\n| **Support Level** | Standard | Enhanced | Premium |\n</ComparisonTable>\n\n## Getting Started with Enterprise\n\n### Step 1: Assessment & Planning\n\n**Free consultation** to understand your requirements, current architecture, and business objectives.\n\n### Step 2: Proof of Concept\n\n**30-day POC** to validate FARM Framework fit for your specific use case and requirements.\n\n### Step 3: Implementation Planning\n\n**Detailed roadmap** with timelines, milestones, and resource requirements for full implementation.\n\n### Step 4: Production Deployment\n\n**Guided deployment** with our expert team ensuring successful launch and optimal configuration.\n\n### Step 5: Ongoing Support\n\n**Continuous partnership** with dedicated support, regular reviews, and optimization recommendations.\n\n<Card>\n### Ready to Scale?\n\nContact our enterprise team for a customized solution that meets your specific needs.\n\n**Enterprise Sales:** enterprise@farm-framework.com  \n**Phone:** +1 (555) 123-FARM  \n**Schedule Demo:** [Book a consultation](https://cal.com/farm-framework/enterprise-demo)\n\n**Response Time:** < 4 hours for enterprise inquiries\n\n</Card>\n\n<Callout type=\"tip\">\n  **Free Enterprise Trial:** Get started with a 60-day free trial of FARM\n  Framework Enterprise, including full support and professional services\n  consultation.\n</Callout>\n",
      "excerpt": "Scale your business with FARM Framework's enterprise-grade features, dedicated support, and professional services.",
      "category": "General",
      "type": "reference",
      "tags": [
        "farm",
        "authentication",
        "database",
        "api",
        "deployment"
      ],
      "lastModified": "2025-06-12T21:57:32.797Z",
      "breadcrumbs": [
        "Enterprise"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Enterprise",
          "id": "enterprise"
        },
        {
          "level": 2,
          "text": "Enterprise Features",
          "id": "enterprise-features"
        },
        {
          "level": 3,
          "text": "🔒 Advanced Security & Compliance",
          "id": "-advanced-security-compliance"
        },
        {
          "level": 3,
          "text": "⚡ Performance & Scalability",
          "id": "-performance-scalability"
        },
        {
          "level": 3,
          "text": "🛠 Developer Experience & DevOps",
          "id": "-developer-experience-devops"
        },
        {
          "level": 3,
          "text": "🤖 AI & Machine Learning Enterprise Features",
          "id": "-ai-machine-learning-enterprise-features"
        },
        {
          "level": 2,
          "text": "Support & Service Plans",
          "id": "support-service-plans"
        },
        {
          "level": 3,
          "text": "Starter Plan",
          "id": "starter-plan"
        },
        {
          "level": 3,
          "text": "Professional Plan",
          "id": "professional-plan"
        },
        {
          "level": 3,
          "text": "Enterprise Plan",
          "id": "enterprise-plan"
        },
        {
          "level": 2,
          "text": "Professional Services",
          "id": "professional-services"
        },
        {
          "level": 3,
          "text": "🏗 Architecture & Design Services",
          "id": "-architecture-design-services"
        },
        {
          "level": 4,
          "text": "System Architecture Review",
          "id": "system-architecture-review"
        },
        {
          "level": 4,
          "text": "Custom Application Development",
          "id": "custom-application-development"
        },
        {
          "level": 3,
          "text": "🔄 Migration & Modernization",
          "id": "-migration-modernization"
        },
        {
          "level": 4,
          "text": "Legacy System Migration",
          "id": "legacy-system-migration"
        },
        {
          "level": 3,
          "text": "📚 Training & Enablement",
          "id": "-training-enablement"
        },
        {
          "level": 4,
          "text": "Developer Team Training",
          "id": "developer-team-training"
        },
        {
          "level": 4,
          "text": "FARM Framework Certification",
          "id": "farm-framework-certification"
        },
        {
          "level": 2,
          "text": "Enterprise Customer Success Stories",
          "id": "enterprise-customer-success-stories"
        },
        {
          "level": 3,
          "text": "Fortune 500 Manufacturing Company",
          "id": "fortune-500-manufacturing-company"
        },
        {
          "level": 3,
          "text": "Healthcare Technology Startup",
          "id": "healthcare-technology-startup"
        },
        {
          "level": 2,
          "text": "Security & Compliance Deep Dive",
          "id": "security-compliance-deep-dive"
        },
        {
          "level": 3,
          "text": "Data Protection & Privacy",
          "id": "data-protection-privacy"
        },
        {
          "level": 3,
          "text": "Incident Response & Business Continuity",
          "id": "incident-response-business-continuity"
        },
        {
          "level": 2,
          "text": "Deployment Options",
          "id": "deployment-options"
        },
        {
          "level": 2,
          "text": "Getting Started with Enterprise",
          "id": "getting-started-with-enterprise"
        },
        {
          "level": 3,
          "text": "Step 1: Assessment & Planning",
          "id": "step-1-assessment-planning"
        },
        {
          "level": 3,
          "text": "Step 2: Proof of Concept",
          "id": "step-2-proof-of-concept"
        },
        {
          "level": 3,
          "text": "Step 3: Implementation Planning",
          "id": "step-3-implementation-planning"
        },
        {
          "level": 3,
          "text": "Step 4: Production Deployment",
          "id": "step-4-production-deployment"
        },
        {
          "level": 3,
          "text": "Step 5: Ongoing Support",
          "id": "step-5-ongoing-support"
        },
        {
          "level": 3,
          "text": "Ready to Scale?",
          "id": "ready-to-scale"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "index",
      "title": "Index",
      "url": "/",
      "content": "# Welcome to FARM Framework\n\nThis is the new landing page placeholder that will be replaced by the React component.\n",
      "excerpt": "This is the new landing page placeholder that will be replaced by the React component. .",
      "category": "General",
      "type": "reference",
      "tags": [
        "react",
        "farm"
      ],
      "lastModified": "2025-06-12T21:57:32.798Z",
      "breadcrumbs": [
        "Index"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Welcome to FARM Framework",
          "id": "welcome-to-farm-framework"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "learn",
      "title": "Learn",
      "url": "/learn",
      "content": "# Learn\r\n\r\nMaster FARM Framework with our comprehensive learning resources.\r\n\r\n## Tutorials\r\n\r\nStep-by-step guides to help you build real applications.\r\n\r\n<Card>\r\n  <CardContent>\r\n    ### Beginner Tutorials - **Your First FARM App** - Build a todo application\r\n    from scratch - **Authentication Setup** - Implement user registration and\r\n    login - **Database Integration** - Connect and query MongoDB - **API\r\n    Development** - Create RESTful endpoints with FastAPI\r\n  </CardContent>\r\n</Card>\r\n\r\n<Card>\r\n  <CardContent>\r\n    ### Intermediate Tutorials - **Real-time Features** - Add WebSocket\r\n    communication - **File Uploads** - Handle media and document uploads -\r\n    **Payment Integration** - Process payments with Stripe - **Deployment\r\n    Guide** - Deploy to production with Docker\r\n  </CardContent>\r\n</Card>\r\n\r\n<Card>\r\n  <CardContent>\r\n    ### Advanced Tutorials - **Microservices** - Break down monoliths into\r\n    services - **Performance Optimization** - Scale to handle high traffic -\r\n    **Testing Strategies** - Comprehensive testing approaches - **CI/CD\r\n    Pipelines** - Automated deployment workflows\r\n  </CardContent>\r\n</Card>\r\n\r\n## Best Practices\r\n\r\nLearn from the community's collective experience.\r\n\r\n- **Code Organization** - Structure your FARM projects\r\n- **Security Patterns** - Protect your applications\r\n- **Performance Tips** - Optimize for speed and efficiency\r\n- **Error Handling** - Graceful failure management\r\n\r\n## Video Courses\r\n\r\nVisual learners, we've got you covered with comprehensive video content.\r\n\r\n<Card>\r\n  <CardContent>\r\n    ### FARM Fundamentals (4 hours) Complete introduction to FARM Framework\r\n    covering all essential concepts.\r\n  </CardContent>\r\n</Card>\r\n\r\n<Card>\r\n  <CardContent>\r\n    ### Building Production Apps (8 hours) Advanced course on building scalable,\r\n    production-ready applications.\r\n  </CardContent>\r\n</Card>\r\n\r\n<Card>\r\n  <CardContent>\r\n    ### DevOps for FARM (6 hours) Deployment, monitoring, and maintenance of\r\n    FARM applications.\r\n  </CardContent>\r\n</Card>\r\n\r\n<Callout type=\"tip\">\r\n  All video courses include downloadable code examples and exercises.\r\n</Callout>\r\n",
      "excerpt": "Master FARM Framework with our comprehensive learning resources. Step-by-step guides to help you build real applications.",
      "category": "General",
      "type": "reference",
      "tags": [
        "fastapi",
        "mongodb",
        "farm",
        "authentication",
        "database"
      ],
      "lastModified": "2025-06-12T21:57:32.798Z",
      "breadcrumbs": [
        "Learn"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Learn",
          "id": "learn"
        },
        {
          "level": 2,
          "text": "Tutorials",
          "id": "tutorials"
        },
        {
          "level": 2,
          "text": "Best Practices",
          "id": "best-practices"
        },
        {
          "level": 2,
          "text": "Video Courses",
          "id": "video-courses"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "showcase",
      "title": "Showcase",
      "url": "/showcase",
      "content": "# Showcase\r\n\r\nDiscover amazing applications built with FARM Framework by our community.\r\n\r\n## Featured Projects\r\n\r\nHandpicked projects that showcase the power of FARM Framework.\r\n\r\n<Card>\r\n<CardContent>\r\n### TaskFlow Pro\r\nA comprehensive project management application with real-time collaboration, built for enterprise teams.\r\n\r\n**Features:** Real-time updates, team collaboration, advanced analytics  \r\n**Tech Stack:** FARM + WebSockets + Redis  \r\n**Live Demo:** [taskflow-pro.com](https://taskflow-pro.com)\r\n\r\n</CardContent>\r\n</Card>\r\n\r\n<Card>\r\n<CardContent>\r\n### EcoMarket\r\nSustainable marketplace connecting eco-friendly businesses with conscious consumers.\r\n\r\n**Features:** Vendor management, payment processing, environmental impact tracking  \r\n**Tech Stack:** FARM + Stripe + GIS  \r\n**Live Demo:** [ecomarket.app](https://ecomarket.app)\r\n\r\n</CardContent>\r\n</Card>\r\n\r\n<Card>\r\n<CardContent>\r\n### MindSpace\r\nMental health platform providing therapy matching and progress tracking.\r\n\r\n**Features:** Secure messaging, appointment scheduling, progress analytics  \r\n**Tech Stack:** FARM + WebRTC + ML  \r\n**Live Demo:** [mindspace.health](https://mindspace.health)\r\n\r\n</CardContent>\r\n</Card>\r\n\r\n## Community Projects\r\n\r\nBuilt by developers like you, for the community.\r\n\r\n- **Recipe Keeper** - Personal recipe management\r\n- **Fitness Tracker** - Workout and nutrition tracking\r\n- **Study Buddy** - Collaborative learning platform\r\n- **LocalEvents** - Community event discovery\r\n\r\n## Submit Your Project\r\n\r\nShare your FARM Framework project with the community!\r\n\r\n<Callout type=\"success\">\r\n  We're always looking for inspiring projects to feature. Submit yours today!\r\n</Callout>\r\n",
      "excerpt": "Discover amazing applications built with FARM Framework by our community. Handpicked projects that showcase the power of FARM Framework.",
      "category": "General",
      "type": "reference",
      "tags": [
        "farm"
      ],
      "lastModified": "2025-06-12T21:57:32.798Z",
      "breadcrumbs": [
        "Showcase"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Showcase",
          "id": "showcase"
        },
        {
          "level": 2,
          "text": "Featured Projects",
          "id": "featured-projects"
        },
        {
          "level": 3,
          "text": "TaskFlow Pro",
          "id": "taskflow-pro"
        },
        {
          "level": 3,
          "text": "EcoMarket",
          "id": "ecomarket"
        },
        {
          "level": 3,
          "text": "MindSpace",
          "id": "mindspace"
        },
        {
          "level": 2,
          "text": "Community Projects",
          "id": "community-projects"
        },
        {
          "level": 2,
          "text": "Submit Your Project",
          "id": "submit-your-project"
        }
      ],
      "featured": false,
      "deprecated": false
    },
    {
      "id": "templates",
      "title": "Templates",
      "url": "/templates",
      "content": "# Templates\n\nJumpstart your FARM Framework project with our professionally crafted templates. Each template is production-ready and includes comprehensive documentation, best practices, and deployment guides.\n\n<Callout type=\"info\">\n  All templates are fully typed with TypeScript and include Docker\n  configurations for seamless deployment.\n</Callout>\n\n## Quick Start\n\nGet started with any template using the FARM CLI:\n\n<CodeBlock language=\"bash\">\n  npx create-farm-app my-app --template [template-name] cd my-app npm run dev\n</CodeBlock>\n\n## Template Showcase\n\n<CodeTabs defaultValue=\"basic\">\n<CodeTab value=\"basic\" label=\"Basic\">\n\n### Basic Template\n\n**Perfect for:** General web applications, MVPs, learning projects\n\n<FeatureList>\n  - React + TypeScript frontend with Vite - FastAPI backend with automatic API\n  generation - MongoDB database with ODM - Tailwind CSS for styling - Zustand\n  for state management - TanStack Query for data fetching - Docker\n  configurations included\n</FeatureList>\n\n<CodeBlock language=\"bash\">\n  npx create-farm-app my-app --template basic\n</CodeBlock>\n\n**Project Structure:**\n\n```\nmy-farm-app/\n├── apps/\n│   ├── web/              # React frontend\n│   │   ├── src/\n│   │   │   ├── components/\n│   │   │   ├── pages/\n│   │   │   ├── stores/\n│   │   │   └── services/\n│   │   └── package.json\n│   └── api/              # FastAPI backend\n│       ├── src/\n│       │   ├── routes/\n│       │   ├── models/\n│       │   └── database/\n│       └── requirements.txt\n└── farm.config.ts\n```\n\n</CodeTab>\n<CodeTab value=\"ai-chat\" label=\"AI Chat\">\n\n### AI Chat Template\n\n**Perfect for:** Chatbots, AI assistants, conversational apps\n\n<FeatureList>\n  - Streaming AI responses with WebSocket support - Multiple AI provider support\n  (Ollama, OpenAI) - Conversation management and history - Real-time typing\n  indicators - Message threading and contexts - Local AI model integration with\n  Ollama - WebSocket-based real-time communication\n</FeatureList>\n\n<CodeBlock language=\"bash\">\n  npx create-farm-app my-chat-app --template ai-chat\n</CodeBlock>\n\n**Key Features:**\n\n- **Streaming Responses**: Real-time AI response streaming\n- **Multi-Provider**: Switch between local and cloud AI models\n- **Conversation Memory**: Persistent chat history\n- **WebSocket Integration**: Real-time bidirectional communication\n\n</CodeTab>\n<CodeTab value=\"ai-dashboard\" label=\"AI Dashboard\">\n\n### AI Dashboard Template\n\n**Perfect for:** Analytics platforms, ML dashboards, data visualization\n\n<FeatureList>\n  - Interactive data visualization with Recharts & D3.js - ML model integration\n  and monitoring - Real-time analytics and metrics - Custom chart components -\n  Data processing pipelines - AI-powered insights generation - Export\n  capabilities for reports\n</FeatureList>\n\n<CodeBlock language=\"bash\">\n  npx create-farm-app my-dashboard --template ai-dashboard\n</CodeBlock>\n\n**Includes:**\n\n- **Chart Library**: Line, bar, pie charts, and heatmaps\n- **ML Integration**: Model metrics and prediction viewers\n- **Data Processing**: Pandas, NumPy, Scikit-learn\n- **Visualization**: Plotly integration for advanced charts\n\n</CodeTab>\n<CodeTab value=\"ecommerce\" label=\"E-commerce\">\n\n### E-commerce Template\n\n**Perfect for:** Online stores, marketplace platforms, retail applications\n\n<FeatureList>\n  - Complete shopping cart functionality - Product catalog with search and\n  filters - Payment processing (Stripe, PayPal) - Order management system -\n  Inventory tracking - Admin dashboard for store management - User\n  authentication and profiles - Mobile-responsive design\n</FeatureList>\n\n<CodeBlock language=\"bash\">\n  npx create-farm-app my-store --template ecommerce\n</CodeBlock>\n\n**Commerce Features:**\n\n- **Payment Integration**: Stripe and PayPal support\n- **Inventory Management**: Real-time stock tracking\n- **Order Processing**: Complete order lifecycle\n- **Admin Panel**: Store and product management\n\n</CodeTab>\n<CodeTab value=\"cms\" label=\"CMS\">\n\n### Content Management System\n\n**Perfect for:** Blogs, documentation sites, content platforms\n\n<FeatureList>\n  - Rich text editor with media support - Content versioning and publishing\n  workflow - SEO optimization tools - Media library with cloud storage - User\n  roles and permissions - Multi-language support - Custom content types -\n  API-first architecture\n</FeatureList>\n\n<CodeBlock language=\"bash\">npx create-farm-app my-cms --template cms</CodeBlock>\n\n**Content Features:**\n\n- **Rich Editor**: TipTap-based content editing\n- **Media Management**: Image and document handling\n- **Publishing Workflow**: Draft, review, publish states\n- **SEO Tools**: Meta tags, sitemap generation\n\n</CodeTab>\n<CodeTab value=\"api-only\" label=\"API Only\">\n\n### API Only Template\n\n**Perfect for:** Microservices, mobile backends, headless applications\n\n<FeatureList>\n  - FastAPI-only architecture (no frontend) - Enhanced API documentation with\n  OpenAPI - Advanced authentication and authorization - Microservice-ready\n  structure - Database migrations and seeding - Comprehensive testing suite -\n  Docker and Kubernetes configurations\n</FeatureList>\n\n<CodeBlock language=\"bash\">\n  npx create-farm-app my-api --template api-only\n</CodeBlock>\n\n**API Features:**\n\n- **OpenAPI Docs**: Automatic API documentation\n- **Testing Suite**: Comprehensive test coverage\n- **Auth System**: JWT and OAuth integration\n- **Microservice Ready**: Scalable architecture\n\n</CodeTab>\n</CodeTabs>\n\n## Template Comparison\n\n<ComparisonTable>\n  | Feature | Basic | AI Chat | AI Dashboard | E-commerce | CMS | API Only |\n  |---------|--------|---------|-------------|------------|-----|----------| |\n  **Frontend** | ✅ React | ✅ React | ✅ React | ✅ React | ✅ React | ❌ None\n  | | **Backend** | ✅ FastAPI | ✅ FastAPI | ✅ FastAPI | ✅ FastAPI | ✅\n  FastAPI | ✅ FastAPI | | **Database** | ✅ MongoDB | ✅ MongoDB | ✅ MongoDB |\n  ✅ MongoDB | ✅ MongoDB | ✅ MongoDB | | **AI Integration** | ❌ | ✅\n  Ollama/OpenAI | ✅ ML Models | ❌ | ❌ | ❌ | | **Real-time** | ❌ | ✅\n  WebSocket | ✅ Analytics | ❌ | ❌ | ❌ | | **Payment** | ❌ | ❌ | ❌ | ✅\n  Stripe/PayPal | ❌ | ❌ | | **CMS Features** | ❌ | ❌ | ❌ | ❌ | ✅ Full CMS\n  | ❌ | | **Auth System** | Basic | ✅ Advanced | ✅ Advanced | ✅ Advanced |\n  ✅ Advanced | ✅ Advanced | | **Best For** | Learning | Chat Apps | Analytics\n  | E-commerce | Content | APIs |\n</ComparisonTable>\n\n## Feature Add-ons\n\nEnhance any template with additional features:\n\n<Card>\n<CardContent>\n### Authentication Feature\nAdd comprehensive authentication to any template:\n\n<CodeBlock language=\"bash\">\n  npx create-farm-app my-app --template basic --features auth\n</CodeBlock>\n\n**Includes:**\n\n<div className=\"mt-4\">\n  <p>✓ JWT token management</p>\n  <p>✓ OAuth provider support</p>\n  <p>✓ User registration and login</p>\n  <p>✓ Protected routes and middleware</p>\n  <p>✓ Password reset functionality</p>\n</div>\n</CardContent>\n</Card>\n\n<Card>\n<CardContent>\n### AI Integration Feature\nAdd AI capabilities to any template:\n\n<CodeBlock language=\"bash\">\n  npx create-farm-app my-app --template basic --features ai\n</CodeBlock>\n\n**Includes:**\n\n<div className=\"mt-4\">\n  <p>✓ Ollama local AI integration</p>\n  <p>✓ OpenAI API support</p>\n  <p>✓ Model management utilities</p>\n  <p>✓ Inference caching</p>\n  <p>✓ GPU acceleration support</p>\n</div>\n</CardContent>\n</Card>\n\n<Card>\n<CardContent>\n### Real-time Feature\nAdd WebSocket real-time functionality:\n\n<CodeBlock language=\"bash\">\n  npx create-farm-app my-app --template basic --features realtime\n</CodeBlock>\n\n**Includes:**\n\n<div className=\"mt-4\">\n  <p>✓ WebSocket connection management</p>\n  <p>✓ Real-time data synchronization</p>\n  <p>✓ Live updates and notifications</p>\n  <p>✓ Connection status monitoring</p>\n</div>\n</CardContent>\n</Card>\n\n## Advanced Configuration\n\n### Database Options\n\n<CodeTabs defaultValue=\"mongodb\">\n  <CodeTab value=\"mongodb\" label=\"MongoDB\">\n    <CodeBlock language=\"typescript\">\n      {`// farm.config.ts\nexport default defineConfig({\n  database: {\n    type: 'mongodb',\n    url: process.env.MONGODB_URL || 'mongodb://localhost:27017/farmapp'\n  }\n});`}\n    </CodeBlock>\n  </CodeTab>\n  <CodeTab value=\"postgresql\" label=\"PostgreSQL\">\n    <CodeBlock language=\"typescript\">\n      {`// farm.config.ts\nexport default defineConfig({\n  database: {\n    type: 'postgresql',\n    url: process.env.DATABASE_URL || 'postgresql://user:pass@localhost/farmapp'\n  }\n});`}\n    </CodeBlock>\n  </CodeTab>\n</CodeTabs>\n\n### AI Configuration\n\nFor AI-enabled templates, configure your AI providers:\n\n<CodeBlock language=\"typescript\">\n  {`// farm.config.ts - AI Chat Template Example\nexport default defineConfig({\n  template: 'ai-chat',\n  ai: {\n    providers: {\n      ollama: {\n        enabled: true,\n        url: 'http://localhost:11434',\n        models: ['llama3.1', 'codestral'],\n        defaultModel: 'llama3.1',\n        autoStart: true,\n        autoPull: ['llama3.1']\n      },\n      openai: {\n        enabled: true,\n        apiKey: process.env.OPENAI_API_KEY,\n        models: ['gpt-4', 'gpt-3.5-turbo'],\n        defaultModel: 'gpt-3.5-turbo'\n      }\n    },\n    routing: {\n      development: 'ollama',\n      production: 'openai'\n    }\n  }\n});`}\n</CodeBlock>\n\n## Next Steps\n\nAfter creating your project:\n\n1. **Setup Environment**\n\n   <CodeBlock language=\"bash\">\n     cp .env.example .env # Edit .env with your configuration\n   </CodeBlock>\n\n2. **Install Dependencies**\n\n   <CodeBlock language=\"bash\">npm install</CodeBlock>\n\n3. **Start Development**\n\n   <CodeBlock language=\"bash\">npm run dev</CodeBlock>\n\n4. **Deploy to Production**\n   <CodeBlock language=\"bash\">npm run build npm run deploy</CodeBlock>\n\n<Callout type=\"tip\">\n  Need help choosing a template? Check out our [Template Selector\n  Tool](/templates/selector) or join our [Discord\n  community](https://discord.gg/JmeShQtv) for personalized recommendations.\n</Callout>\n",
      "excerpt": "Jumpstart your FARM Framework project with our professionally crafted templates.",
      "category": "General",
      "type": "reference",
      "tags": [
        "fastapi",
        "react",
        "mongodb",
        "farm",
        "typescript"
      ],
      "lastModified": "2025-06-12T21:57:32.798Z",
      "breadcrumbs": [
        "Templates"
      ],
      "headings": [
        {
          "level": 1,
          "text": "Templates",
          "id": "templates"
        },
        {
          "level": 2,
          "text": "Quick Start",
          "id": "quick-start"
        },
        {
          "level": 2,
          "text": "Template Showcase",
          "id": "template-showcase"
        },
        {
          "level": 3,
          "text": "Basic Template",
          "id": "basic-template"
        },
        {
          "level": 3,
          "text": "AI Chat Template",
          "id": "ai-chat-template"
        },
        {
          "level": 3,
          "text": "AI Dashboard Template",
          "id": "ai-dashboard-template"
        },
        {
          "level": 3,
          "text": "E-commerce Template",
          "id": "e-commerce-template"
        },
        {
          "level": 3,
          "text": "Content Management System",
          "id": "content-management-system"
        },
        {
          "level": 3,
          "text": "API Only Template",
          "id": "api-only-template"
        },
        {
          "level": 2,
          "text": "Template Comparison",
          "id": "template-comparison"
        },
        {
          "level": 2,
          "text": "Feature Add-ons",
          "id": "feature-add-ons"
        },
        {
          "level": 3,
          "text": "Authentication Feature",
          "id": "authentication-feature"
        },
        {
          "level": 3,
          "text": "AI Integration Feature",
          "id": "ai-integration-feature"
        },
        {
          "level": 3,
          "text": "Real-time Feature",
          "id": "real-time-feature"
        },
        {
          "level": 2,
          "text": "Advanced Configuration",
          "id": "advanced-configuration"
        },
        {
          "level": 3,
          "text": "Database Options",
          "id": "database-options"
        },
        {
          "level": 3,
          "text": "AI Configuration",
          "id": "ai-configuration"
        },
        {
          "level": 2,
          "text": "Next Steps",
          "id": "next-steps"
        }
      ],
      "featured": false,
      "deprecated": false
    }
  ],
  "generated": "2025-06-12T21:57:32.799Z",
  "total": 58
}